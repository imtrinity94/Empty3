/// <reference path="Intrinsics-1.0.0.d.ts"/>


  
    // Regular classes.  
	interface base64Binary
	{

	}

	declare const base64Binary: base64Binary;

	declare class VcAboutInfo
	{
		apiType: String;
		apiVersion: String;
		build: String;
		fullName: String;
		instanceUuid: String;
		licenseProductName: String;
		licenseProductVersion: String;
		localeBuild: String;
		localeVersion: String;
		name: String;
		osType: String;
		productLineId: String;
		vendor: String;
		version: String;

		constructor();
	}

	declare class VcAccountCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		spec: VcHostAccountSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAccountRemovedEvent
	{
		account: String;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAccountUpdatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		spec: VcHostAccountSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAction
	{

		constructor();
	}

	interface VcActionParameter
	{
		readonly _alarm: String;
		readonly _alarmName: String;
		readonly _declaringSummary: String;
		readonly _eventDescription: String;
		readonly _newStatus: String;
		readonly _oldStatus: String;
		readonly _target: String;
		readonly _targetName: String;
		readonly _triggeringSummary: String;
		readonly alarm: VcActionParameter;
		readonly alarmName: VcActionParameter;
		readonly declaringSummary: VcActionParameter;
		readonly eventDescription: VcActionParameter;
		readonly id: String;
		readonly name: String;
		readonly newStatus: VcActionParameter;
		readonly oldStatus: VcActionParameter;
		readonly target: VcActionParameter;
		readonly targetName: VcActionParameter;
		readonly triggeringSummary: VcActionParameter;
		readonly value: String;

		fromString(value?: String): VcActionParameter;
	}

	interface VcActionParameterConstructor {
		new(value?:any): VcActionParameter;
		readonly prototype: VcActionParameter;
	}

	declare const VcActionParameter: VcActionParameterConstructor;

	interface VcActionType
	{
		readonly _DecreaseMigrationThresholdV1: String;
		readonly _DecreaseOthersReservationV1: String;
		readonly _HostMaintenanceV1: String;
		readonly _HostPowerV1: String;
		readonly _IncreaseClusterCapacityV1: String;
		readonly _IncreaseLimitV1: String;
		readonly _IncreaseReservationV1: String;
		readonly _IncreaseSharesV1: String;
		readonly _IncreaseSizeV1: String;
		readonly _MigrationV1: String;
		readonly _PlacementV1: String;
		readonly _StorageMigrationV1: String;
		readonly _StoragePlacementV1: String;
		readonly _VmPowerV1: String;
		readonly DecreaseMigrationThresholdV1: VcActionType;
		readonly DecreaseOthersReservationV1: VcActionType;
		readonly HostMaintenanceV1: VcActionType;
		readonly HostPowerV1: VcActionType;
		readonly id: String;
		readonly IncreaseClusterCapacityV1: VcActionType;
		readonly IncreaseLimitV1: VcActionType;
		readonly IncreaseReservationV1: VcActionType;
		readonly IncreaseSharesV1: VcActionType;
		readonly IncreaseSizeV1: VcActionType;
		readonly MigrationV1: VcActionType;
		readonly name: String;
		readonly PlacementV1: VcActionType;
		readonly StorageMigrationV1: VcActionType;
		readonly StoragePlacementV1: VcActionType;
		readonly value: String;
		readonly VmPowerV1: VcActionType;

		fromString(value?: String): VcActionType;
	}

	interface VcActionTypeConstructor {
		new(value?:any): VcActionType;
		readonly prototype: VcActionType;
	}

	declare const VcActionType: VcActionTypeConstructor;

	declare class VcActiveDirectoryProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcAdminPasswordNotChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcAffinityType
	{
		readonly _cpu: String;
		readonly _memory: String;
		readonly cpu: VcAffinityType;
		readonly id: String;
		readonly memory: VcAffinityType;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcAffinityType;
	}

	interface VcAffinityTypeConstructor {
		new(value?:any): VcAffinityType;
		readonly prototype: VcAffinityType;
	}

	declare const VcAffinityType: VcAffinityTypeConstructor;

	declare class VcAfterStartupTaskScheduler
	{
		activeTime: Date;
		expireTime: Date;
		minute: Number;

		constructor();
	}

	interface VcAgentInstallFailedReason
	{
		readonly _AgentNotReachable: String;
		readonly _AgentNotRunning: String;
		readonly _AgentUploadFailed: String;
		readonly _AgentUploadTimedout: String;
		readonly _InstallTimedout: String;
		readonly _NotEnoughSpaceOnDevice: String;
		readonly _PrepareToUpgradeFailed: String;
		readonly _SignatureVerificationFailed: String;
		readonly _UnknownInstallerError: String;
		readonly AgentNotReachable: VcAgentInstallFailedReason;
		readonly AgentNotRunning: VcAgentInstallFailedReason;
		readonly AgentUploadFailed: VcAgentInstallFailedReason;
		readonly AgentUploadTimedout: VcAgentInstallFailedReason;
		readonly id: String;
		readonly InstallTimedout: VcAgentInstallFailedReason;
		readonly name: String;
		readonly NotEnoughSpaceOnDevice: VcAgentInstallFailedReason;
		readonly PrepareToUpgradeFailed: VcAgentInstallFailedReason;
		readonly SignatureVerificationFailed: VcAgentInstallFailedReason;
		readonly UnknownInstallerError: VcAgentInstallFailedReason;
		readonly value: String;

		fromString(value?: String): VcAgentInstallFailedReason;
	}

	interface VcAgentInstallFailedReasonConstructor {
		new(value?:any): VcAgentInstallFailedReason;
		readonly prototype: VcAgentInstallFailedReason;
	}

	declare const VcAgentInstallFailedReason: VcAgentInstallFailedReasonConstructor;

	interface VcAlarm
	{
		availableField: VcCustomFieldDef[];
		readonly id: String;
		info: VcAlarmInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureAlarm(spec?: VcAlarmSpec): void;
		removeAlarm(): void;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcAlarm: VcAlarm;

	declare class VcAlarmAcknowledgedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		source: VcManagedEntityEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmAction
	{

		constructor();
	}

	declare class VcAlarmActionTriggeredEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		source: VcManagedEntityEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmClearedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		from: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		source: VcManagedEntityEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmCreatedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmDescription
	{
		action: VcTypeDescription[];
		datastoreConnectionState: VcElementDescription[];
		entityStatus: VcElementDescription[];
		expr: VcTypeDescription[];
		hostSystemConnectionState: VcElementDescription[];
		hostSystemPowerState: VcElementDescription[];
		metricOperator: VcElementDescription[];
		stateOperator: VcElementDescription[];
		virtualMachineGuestHeartbeatStatus: VcElementDescription[];
		virtualMachinePowerState: VcElementDescription[];

		constructor();
	}

	declare class VcAlarmEmailCompletedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		to: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmEmailFailedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		to: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmEventArgument
	{
		alarm: VcAlarm;
		name: String;

		constructor();
	}

	declare class VcAlarmExpression
	{

		constructor();
	}

	declare class VcAlarmInfo
	{
		action: VcAlarmAction;
		actionFrequency: Number;
		alarm: VcAlarm;
		alarmMetadata: String;
		creationEventId: Number;
		description: String;
		enabled: boolean;
		entity: VcManagedEntity;
		expression: VcAlarmExpression;
		key: String;
		lastModifiedTime: Date;
		lastModifiedUser: String;
		name: String;
		setting: VcAlarmSetting;
		systemName: String;

		constructor();
	}

	interface VcAlarmManager
	{
		defaultExpression: VcAlarmExpression[];
		description: VcAlarmDescription;
		readonly id: String;
		lastTriggerId: Number;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		acknowledgeAlarm(alarm?: VcAlarm, entity?: VcManagedEntity): void;
		areAlarmActionsEnabled(entity?: VcManagedEntity): boolean;
		createAlarm(entity?: VcManagedEntity, spec?: VcAlarmSpec): VcAlarm;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		enableAlarmActions(entity?: VcManagedEntity, enabled?: boolean): void;
		getAlarm(entity?: VcManagedEntity): VcAlarm[];
		getAlarmState(entity?: VcManagedEntity): VcAlarmState[];
	}

	declare const VcAlarmManager: VcAlarmManager;

	declare class VcAlarmReconfiguredEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmRemovedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmScriptCompleteEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		script: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmScriptFailedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		script: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmSetting
	{
		reportingFrequency: Number;
		toleranceRange: Number;

		constructor();
	}

	declare class VcAlarmSnmpCompletedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmSnmpFailedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmSpec
	{
		action: VcAlarmAction;
		actionFrequency: Number;
		alarmMetadata: String;
		description: String;
		enabled: boolean;
		expression: VcAlarmExpression;
		name: String;
		setting: VcAlarmSetting;
		systemName: String;

		constructor();
	}

	declare class VcAlarmState
	{
		acknowledged: boolean;
		acknowledgedByUser: String;
		acknowledgedTime: Date;
		alarm: VcAlarm;
		entity: VcManagedEntity;
		eventKey: Number;
		key: String;
		overallStatus: VcManagedEntityStatus;
		time: Date;

		constructor();
	}

	declare class VcAlarmStatusChangedEvent
	{
		alarm: VcAlarmEventArgument;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		from: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		source: VcManagedEntityEventArgument;
		to: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlarmTriggeringAction
	{
		action: VcAction;
		green2yellow: boolean;
		red2yellow: boolean;
		transitionSpecs: VcAlarmTriggeringActionTransitionSpec[];
		yellow2green: boolean;
		yellow2red: boolean;

		constructor();
	}

	declare class VcAlarmTriggeringActionTransitionSpec
	{
		finalState: VcManagedEntityStatus;
		repeats: boolean;
		startState: VcManagedEntityStatus;

		constructor();
	}

	declare class VcAllVirtualMachinesLicensedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAlreadyAuthenticatedSessionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcAndAlarmExpression
	{
		expression: VcAlarmExpression[];

		constructor();
	}

	declare class VcAnswerFile
	{
		createdTime: Date;
		modifiedTime: Date;
		userInput: VcProfileDeferredPolicyOptionParameter[];

		constructor();
	}

	declare class VcAnswerFileCreateSpec
	{
		validating: boolean;

		constructor();
	}

	declare class VcAnswerFileOptionsCreateSpec
	{
		userInput: VcProfileDeferredPolicyOptionParameter[];
		validating: boolean;

		constructor();
	}

	declare class VcAnswerFileSerializedCreateSpec
	{
		answerFileConfigString: String;
		validating: boolean;

		constructor();
	}

	declare class VcAnswerFileStatusError
	{
		errMsg: VcLocalizableMessage;
		userInputPath: VcProfilePropertyPath;

		constructor();
	}

	declare class VcAnswerFileStatusResult
	{
		checkedTime: Date;
		error: VcAnswerFileStatusError[];
		host: VcHostSystem;
		status: String;

		constructor();
	}

	declare class VcAnswerFileUpdateFailure
	{
		errMsg: VcLocalizableMessage;
		userInputPath: VcProfilePropertyPath;

		constructor();
	}

	interface VcApiHooksCallbackHandler
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		executePostCallback(hookManagerMoId?: String, instanceId?: String, opId?: String, userSession?: VcUserSession, vmodlFunctionName?: String, target?: Object, ourPreResult?: VcPreCallbackResult, overallPreCallbackResult?: VcPreCallbackResultResult, args?: Object, bodyResult?: Object): void;
		executePreCallback(hookManagerMoId?: String, instanceId?: String, opId?: String, userSession?: VcUserSession, vmodlFunctionName?: String, target?: Object, args?: Object): VcPreCallbackResult;
	}

	declare const VcApiHooksCallbackHandler: VcApiHooksCallbackHandler;

	interface VcApiProxyServiceManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		apiProxyDisableService(serviceKey?: String): void;
		apiProxyEnableService(serviceKey?: String): void;
		apiProxyIsEnabled(serviceKey?: String): boolean;
		apiProxyListServices(): VcServiceInfo[];
		apiProxyRegisterService(service?: VcServiceInfo): void;
		apiProxyUnregisterService(serviceKey?: String): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcApiProxyServiceManager: VcApiProxyServiceManager;

	declare class VcApplyProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcApplyStorageRecommendationResult
	{
		vm: VcVirtualMachine;

		constructor();
	}

	interface VcArrayUpdateOperation
	{
		readonly _add: String;
		readonly _edit: String;
		readonly _remove: String;
		readonly add: VcArrayUpdateOperation;
		readonly edit: VcArrayUpdateOperation;
		readonly id: String;
		readonly name: String;
		readonly remove: VcArrayUpdateOperation;
		readonly value: String;

		fromString(value?: String): VcArrayUpdateOperation;
	}

	interface VcArrayUpdateOperationConstructor {
		new(value?:any): VcArrayUpdateOperation;
		readonly prototype: VcArrayUpdateOperation;
	}

	declare const VcArrayUpdateOperation: VcArrayUpdateOperationConstructor;

	declare class VcArrayUpdateSpec
	{
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcAuthenticationProfile
	{
		activeDirectory: VcActiveDirectoryProfile;
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcAuthorizationDescription
	{
		privilege: VcElementDescription[];
		privilegeGroup: VcElementDescription[];

		constructor();
	}

	declare class VcAuthorizationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcAuthorizationManager
	{
		description: VcAuthorizationDescription;
		readonly id: String;
		privilegeList: VcAuthorizationPrivilege[];
		readonly reference: VcManagedObjectReference;
		roleList: VcAuthorizationRole[];
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addAuthorizationRole(name?: String, privIds?: String[]): Number;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		hasPrivilegeOnEntities(entity?: VcManagedEntity[], sessionId?: String, privId?: String[]): VcEntityPrivilege[];
		hasPrivilegeOnEntity(entity?: VcManagedEntity, sessionId?: String, privId?: String[]): boolean[];
		mergePermissions(srcRoleId?: Number, dstRoleId?: Number): void;
		removeAuthorizationRole(roleId?: Number, failIfUsed?: boolean): void;
		removeEntityPermission(entity?: VcManagedEntity, user?: String, isGroup?: boolean): void;
		resetEntityPermissions(entity?: VcManagedEntity, permission?: VcPermission[]): void;
		retrieveAllPermissions(): VcPermission[];
		retrieveEntityPermissions(entity?: VcManagedEntity, inherited?: boolean): VcPermission[];
		retrieveRolePermissions(roleId?: Number): VcPermission[];
		setEntityPermissions(entity?: VcManagedEntity, permission?: VcPermission[]): void;
		updateAuthorizationRole(roleId?: Number, newName?: String, privIds?: String[]): void;
	}

	declare const VcAuthorizationManager: VcAuthorizationManager;

	declare class VcAuthorizationPrivilege
	{
		name: String;
		onParent: boolean;
		privGroupName: String;
		privId: String;

		constructor();
	}

	declare class VcAuthorizationRole
	{
		info: VcDescription;
		name: String;
		privilege: String[];
		roleId: Number;
		system: boolean;

		constructor();
	}

	interface VcAutoStartAction
	{
		readonly _guestShutdown: String;
		readonly _none: String;
		readonly _powerOff: String;
		readonly _powerOn: String;
		readonly _suspend: String;
		readonly _systemDefault: String;
		readonly guestShutdown: VcAutoStartAction;
		readonly id: String;
		readonly name: String;
		readonly none: VcAutoStartAction;
		readonly powerOff: VcAutoStartAction;
		readonly powerOn: VcAutoStartAction;
		readonly suspend: VcAutoStartAction;
		readonly systemDefault: VcAutoStartAction;
		readonly value: String;

		fromString(value?: String): VcAutoStartAction;
	}

	interface VcAutoStartActionConstructor {
		new(value?:any): VcAutoStartAction;
		readonly prototype: VcAutoStartAction;
	}

	declare const VcAutoStartAction: VcAutoStartActionConstructor;

	declare class VcAutoStartDefaults
	{
		enabled: boolean;
		startDelay: Number;
		stopAction: String;
		stopDelay: Number;
		waitForHeartbeat: boolean;

		constructor();
	}

	declare class VcAutoStartPowerInfo
	{
		key: VcVirtualMachine;
		startAction: String;
		startDelay: Number;
		startOrder: Number;
		stopAction: String;
		stopDelay: Number;
		waitForHeartbeat: VcAutoStartWaitHeartbeatSetting;

		constructor();
	}

	interface VcAutoStartWaitHeartbeatSetting
	{
		readonly _no: String;
		readonly _systemDefault: String;
		readonly _yes: String;
		readonly id: String;
		readonly name: String;
		readonly no: VcAutoStartWaitHeartbeatSetting;
		readonly systemDefault: VcAutoStartWaitHeartbeatSetting;
		readonly value: String;
		readonly yes: VcAutoStartWaitHeartbeatSetting;

		fromString(value?: String): VcAutoStartWaitHeartbeatSetting;
	}

	interface VcAutoStartWaitHeartbeatSettingConstructor {
		new(value?:any): VcAutoStartWaitHeartbeatSetting;
		readonly prototype: VcAutoStartWaitHeartbeatSetting;
	}

	declare const VcAutoStartWaitHeartbeatSetting: VcAutoStartWaitHeartbeatSettingConstructor;

	declare class VcBadUsernameSessionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ipAddress: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcBatchResult
	{
		ds: VcDatastore;
		fault: VcLocalizedMethodFault;
		hostKey: String;
		result: String;

		constructor();
	}

	interface VcBatchResultResult
	{
		readonly _fail: String;
		readonly _success: String;
		readonly fail: VcBatchResultResult;
		readonly id: String;
		readonly name: String;
		readonly success: VcBatchResultResult;
		readonly value: String;

		fromString(value?: String): VcBatchResultResult;
	}

	interface VcBatchResultResultConstructor {
		new(value?:any): VcBatchResultResult;
		readonly prototype: VcBatchResultResult;
	}

	declare const VcBatchResultResult: VcBatchResultResultConstructor;

	declare class VcBoolOption
	{
		defaultValue: boolean;
		supported: boolean;
		valueIsReadonly: boolean;

		constructor();
	}

	declare class VcBoolPolicy
	{
		inherited: boolean;
		value: boolean;

		constructor();
	}

	declare class VcCanceledHostOperationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcCannotEnableVmcpForClusterReason
	{
		readonly _APDTimeoutDisabled: String;
		readonly _IncompatibleHostVersion: String;
		readonly APDTimeoutDisabled: VcCannotEnableVmcpForClusterReason;
		readonly id: String;
		readonly IncompatibleHostVersion: VcCannotEnableVmcpForClusterReason;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcCannotEnableVmcpForClusterReason;
	}

	interface VcCannotEnableVmcpForClusterReasonConstructor {
		new(value?:any): VcCannotEnableVmcpForClusterReason;
		readonly prototype: VcCannotEnableVmcpForClusterReason;
	}

	declare const VcCannotEnableVmcpForClusterReason: VcCannotEnableVmcpForClusterReasonConstructor;

	interface VcCannotMoveFaultToleranceVmMoveType
	{
		readonly _cluster: String;
		readonly _resourcePool: String;
		readonly cluster: VcCannotMoveFaultToleranceVmMoveType;
		readonly id: String;
		readonly name: String;
		readonly resourcePool: VcCannotMoveFaultToleranceVmMoveType;
		readonly value: String;

		fromString(value?: String): VcCannotMoveFaultToleranceVmMoveType;
	}

	interface VcCannotMoveFaultToleranceVmMoveTypeConstructor {
		new(value?:any): VcCannotMoveFaultToleranceVmMoveType;
		readonly prototype: VcCannotMoveFaultToleranceVmMoveType;
	}

	declare const VcCannotMoveFaultToleranceVmMoveType: VcCannotMoveFaultToleranceVmMoveTypeConstructor;

	interface VcCannotPowerOffVmInClusterOperation
	{
		readonly _guestShutdown: String;
		readonly _guestSuspend: String;
		readonly _powerOff: String;
		readonly _suspend: String;
		readonly guestShutdown: VcCannotPowerOffVmInClusterOperation;
		readonly guestSuspend: VcCannotPowerOffVmInClusterOperation;
		readonly id: String;
		readonly name: String;
		readonly powerOff: VcCannotPowerOffVmInClusterOperation;
		readonly suspend: VcCannotPowerOffVmInClusterOperation;
		readonly value: String;

		fromString(value?: String): VcCannotPowerOffVmInClusterOperation;
	}

	interface VcCannotPowerOffVmInClusterOperationConstructor {
		new(value?:any): VcCannotPowerOffVmInClusterOperation;
		readonly prototype: VcCannotPowerOffVmInClusterOperation;
	}

	declare const VcCannotPowerOffVmInClusterOperation: VcCannotPowerOffVmInClusterOperationConstructor;

	interface VcCannotUseNetworkReason
	{
		readonly _MismatchedDvsVersionOrVendor: String;
		readonly _MismatchedNetworkPolicies: String;
		readonly _NetworkReservationNotSupported: String;
		readonly _VMotionToUnsupportedNetworkType: String;
		readonly id: String;
		readonly MismatchedDvsVersionOrVendor: VcCannotUseNetworkReason;
		readonly MismatchedNetworkPolicies: VcCannotUseNetworkReason;
		readonly name: String;
		readonly NetworkReservationNotSupported: VcCannotUseNetworkReason;
		readonly value: String;
		readonly VMotionToUnsupportedNetworkType: VcCannotUseNetworkReason;

		fromString(value?: String): VcCannotUseNetworkReason;
	}

	interface VcCannotUseNetworkReasonConstructor {
		new(value?:any): VcCannotUseNetworkReason;
		readonly prototype: VcCannotUseNetworkReason;
	}

	declare const VcCannotUseNetworkReason: VcCannotUseNetworkReasonConstructor;

	declare class VcCapability
	{
		multiHostSupported: boolean;
		networkBackupAndRestoreSupported: boolean;
		provisioningSupported: boolean;
		supportedEVCMode: VcEVCMode[];
		userShellAccessSupported: boolean;

		constructor();
	}

	interface VcCertificateManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		certMgrRefreshCACertificatesAndCRLs_Task(host?: VcHostSystem[]): VcTask;
		certMgrRefreshCertificates_Task(host?: VcHostSystem[]): VcTask;
		certMgrRevokeCertificates_Task(host?: VcHostSystem[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcCertificateManager: VcCertificateManager;

	declare class VcChangeOwnerOfFileEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		filename: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newOwner: String;
		oldOwner: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcChangeOwnerOfFileFailedEvent
	{
		attemptedOwner: String;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		filename: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		owner: String;
		reason: VcLocalizedMethodFault;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCheckResult
	{
		error: VcLocalizedMethodFault[];
		host: VcHostSystem;
		vm: VcVirtualMachine;
		warning: VcLocalizedMethodFault[];

		constructor();
	}

	interface VcCheckTestConditionOpType
	{
		readonly _clone: String;
		readonly _compat: String;
		readonly _migrate: String;
		readonly _powerOn: String;
		readonly clone: VcCheckTestConditionOpType;
		readonly compat: VcCheckTestConditionOpType;
		readonly id: String;
		readonly migrate: VcCheckTestConditionOpType;
		readonly name: String;
		readonly powerOn: VcCheckTestConditionOpType;
		readonly value: String;

		fromString(value?: String): VcCheckTestConditionOpType;
	}

	interface VcCheckTestConditionOpTypeConstructor {
		new(value?:any): VcCheckTestConditionOpType;
		readonly prototype: VcCheckTestConditionOpType;
	}

	declare const VcCheckTestConditionOpType: VcCheckTestConditionOpTypeConstructor;

	declare class VcCheckTestKey
	{
		providerName: String;
		testName: String;

		constructor();
	}

	interface VcCheckTestletTestLanguage
	{
		readonly _Lua: String;
		readonly id: String;
		readonly Lua: VcCheckTestletTestLanguage;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcCheckTestletTestLanguage;
	}

	interface VcCheckTestletTestLanguageConstructor {
		new(value?:any): VcCheckTestletTestLanguage;
		readonly prototype: VcCheckTestletTestLanguage;
	}

	declare const VcCheckTestletTestLanguage: VcCheckTestletTestLanguageConstructor;

	interface VcCheckTestType
	{
		readonly _datastoreTests: String;
		readonly _hostTests: String;
		readonly _networkTests: String;
		readonly _resourcePoolTests: String;
		readonly _sourceTests: String;
		readonly datastoreTests: VcCheckTestType;
		readonly hostTests: VcCheckTestType;
		readonly id: String;
		readonly name: String;
		readonly networkTests: VcCheckTestType;
		readonly resourcePoolTests: VcCheckTestType;
		readonly sourceTests: VcCheckTestType;
		readonly value: String;

		fromString(value?: String): VcCheckTestType;
	}

	interface VcCheckTestTypeConstructor {
		new(value?:any): VcCheckTestType;
		readonly prototype: VcCheckTestType;
	}

	declare const VcCheckTestType: VcCheckTestTypeConstructor;

	declare class VcChoiceOption
	{
		choiceInfo: VcElementDescription[];
		defaultIndex: Number;
		valueIsReadonly: boolean;

		constructor();
	}

	declare class VcClusterAction
	{
		target: VcManagedObjectReference;
		type: String;

		constructor();
	}

	declare class VcClusterActionHistory
	{
		action: VcClusterAction;
		time: Date;

		constructor();
	}

	declare class VcClusterAffinityRuleSpec
	{
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;
		vm: VcVirtualMachine[];

		constructor();
	}

	declare class VcClusterAntiAffinityRuleSpec
	{
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;
		vm: VcVirtualMachine[];

		constructor();
	}

	declare class VcClusterAttemptedVmInfo
	{
		task: VcTask;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcClusterComplianceCheckedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcClusterComputeResource
	{
		actionHistory: VcClusterActionHistory[];
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		configuration: VcClusterConfigInfo;
		configurationEx: VcComputeResourceConfigInfo;
		customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		drsFault: VcClusterDrsFaults[];
		drsRecommendation: VcClusterDrsRecommendation[];
		effectiveRole: Number[];
		environmentBrowser: VcEnvironmentBrowser;
		host: VcHostSystem[];
		readonly id: String;
		migrationHistory: VcClusterDrsMigration[];
		name: String;
		network: VcNetwork[];
		readonly network_DistributedVirtualPortgroup: DistributedVirtualPortgroup[];
		readonly network_Network: Network[];
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		recommendation: VcClusterRecommendation[];
		readonly reference: VcManagedObjectReference;
		resourcePool: VcResourcePool;
		readonly resourcePool_ResourcePool: ResourcePool[];
		readonly resourcePool_VirtualApp: VirtualApp[];
		readonly sdkConnection: VcSdkConnection;
		summary: VcComputeResourceSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addHost_Task(spec?: VcHostConnectSpec, asConnected?: boolean, resourcePool?: VcResourcePool, license?: String): VcTask;
		applyRecommendation(key?: String): void;
		cancelRecommendation(key?: String): void;
		clusterEnterMaintenanceMode(host?: VcHostSystem[], option?: VcOptionValue[]): VcClusterEnterMaintenanceResult;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		evcManager(): VcClusterEVCManager;
		findRulesForVm(vm?: VcVirtualMachine): VcClusterRuleInfo[];
		getResourceUsage(): VcClusterResourceUsageSummary;
		moveHostInto_Task(host?: VcHostSystem, resourcePool?: VcResourcePool): VcTask;
		moveInto_Task(host?: VcHostSystem[]): VcTask;
		placeVm(placementSpec?: VcPlacementSpec): VcPlacementResult;
		recommendHostsForVm(vm?: VcVirtualMachine, pool?: VcResourcePool): VcClusterHostRecommendation[];
		reconfigureCluster_Task(spec?: VcClusterConfigSpec, modify?: boolean): VcTask;
		reconfigureComputeResource_Task(spec?: VcComputeResourceConfigSpec, modify?: boolean): VcTask;
		refreshRecommendation(): void;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		retrieveDasAdvancedRuntimeInfo(): VcClusterDasAdvancedRuntimeInfo;
		setCustomValue(key?: String, value?: String): void;
		stampAllRulesWithUuid_Task(): VcTask;
	}

	declare const VcClusterComputeResource: VcClusterComputeResource;

	declare class VcClusterComputeResourceSummary
	{
		admissionControlInfo: VcClusterDasAdmissionControlInfo;
		currentBalance: Number;
		currentEVCModeKey: String;
		currentFailoverLevel: Number;
		dasData: VcClusterDasData;
		effectiveCpu: Number;
		effectiveMemory: Number;
		numCpuCores: Number;
		numCpuThreads: Number;
		numEffectiveHosts: Number;
		numHosts: Number;
		numVmotions: Number;
		overallStatus: VcManagedEntityStatus;
		targetBalance: Number;
		totalCpu: Number;
		totalMemory: Number;
		usageSummary: VcClusterUsageSummary;

		constructor();
	}

	declare class VcClusterConfigInfo
	{
		dasConfig: VcClusterDasConfigInfo;
		dasVmConfig: VcClusterDasVmConfigInfo[];
		drsConfig: VcClusterDrsConfigInfo;
		drsVmConfig: VcClusterDrsVmConfigInfo[];
		rule: VcClusterRuleInfo[];

		constructor();
	}

	declare class VcClusterConfigInfoEx
	{
		dasConfig: VcClusterDasConfigInfo;
		dasVmConfig: VcClusterDasVmConfigInfo[];
		defaultHardwareVersionKey: String;
		dpmConfigInfo: VcClusterDpmConfigInfo;
		dpmHostConfig: VcClusterDpmHostConfigInfo[];
		drsConfig: VcClusterDrsConfigInfo;
		drsVmConfig: VcClusterDrsVmConfigInfo[];
		group: VcClusterGroupInfo[];
		rule: VcClusterRuleInfo[];
		spbmEnabled: boolean;
		vmSwapPlacement: String;
		vsanConfigInfo: VcVsanClusterConfigInfo;
		vsanHostConfig: VcVsanHostConfigInfo[];

		constructor();
	}

	declare class VcClusterConfigSpec
	{
		dasConfig: VcClusterDasConfigInfo;
		dasVmConfigSpec: VcClusterDasVmConfigSpec[];
		drsConfig: VcClusterDrsConfigInfo;
		drsVmConfigSpec: VcClusterDrsVmConfigSpec[];
		rulesSpec: VcClusterRuleSpec[];

		constructor();
	}

	declare class VcClusterConfigSpecEx
	{
		dasConfig: VcClusterDasConfigInfo;
		dasVmConfigSpec: VcClusterDasVmConfigSpec[];
		defaultHardwareVersionKey: String;
		dpmConfig: VcClusterDpmConfigInfo;
		dpmHostConfigSpec: VcClusterDpmHostConfigSpec[];
		drsConfig: VcClusterDrsConfigInfo;
		drsVmConfigSpec: VcClusterDrsVmConfigSpec[];
		groupSpec: VcClusterGroupSpec[];
		rulesSpec: VcClusterRuleSpec[];
		spbmEnabled: boolean;
		vmSwapPlacement: String;
		vsanConfig: VcVsanClusterConfigInfo;
		vsanHostConfigSpec: VcVsanHostConfigInfo[];

		constructor();
	}

	declare class VcClusterCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		parent: VcFolderEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcClusterDasAamHostInfo
	{
		hostDasState: VcClusterDasAamNodeState[];
		primaryHosts: String[];

		constructor();
	}

	declare class VcClusterDasAamNodeState
	{
		configState: String;
		host: VcHostSystem;
		name: String;
		runtimeState: String;

		constructor();
	}

	interface VcClusterDasAamNodeStateDasState
	{
		readonly _agentShutdown: String;
		readonly _configuring: String;
		readonly _error: String;
		readonly _initialized: String;
		readonly _nodeFailed: String;
		readonly _running: String;
		readonly _unconfiguring: String;
		readonly _uninitialized: String;
		readonly agentShutdown: VcClusterDasAamNodeStateDasState;
		readonly configuring: VcClusterDasAamNodeStateDasState;
		readonly error: VcClusterDasAamNodeStateDasState;
		readonly id: String;
		readonly initialized: VcClusterDasAamNodeStateDasState;
		readonly name: String;
		readonly nodeFailed: VcClusterDasAamNodeStateDasState;
		readonly running: VcClusterDasAamNodeStateDasState;
		readonly unconfiguring: VcClusterDasAamNodeStateDasState;
		readonly uninitialized: VcClusterDasAamNodeStateDasState;
		readonly value: String;

		fromString(value?: String): VcClusterDasAamNodeStateDasState;
	}

	interface VcClusterDasAamNodeStateDasStateConstructor {
		new(value?:any): VcClusterDasAamNodeStateDasState;
		readonly prototype: VcClusterDasAamNodeStateDasState;
	}

	declare const VcClusterDasAamNodeStateDasState: VcClusterDasAamNodeStateDasStateConstructor;

	declare class VcClusterDasAdmissionControlInfo
	{

		constructor();
	}

	declare class VcClusterDasAdmissionControlPolicy
	{

		constructor();
	}

	declare class VcClusterDasAdvancedRuntimeInfo
	{
		dasHostInfo: VcClusterDasHostInfo;
		heartbeatDatastoreInfo: VcDasHeartbeatDatastoreInfo[];
		vmcpSupported: VcClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo;

		constructor();
	}

	declare class VcClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo
	{
		storageAPDSupported: boolean;
		storagePDLSupported: boolean;

		constructor();
	}

	declare class VcClusterDasConfigInfo
	{
		admissionControlEnabled: boolean;
		admissionControlPolicy: VcClusterDasAdmissionControlPolicy;
		defaultVmSettings: VcClusterDasVmSettings;
		enabled: boolean;
		failoverLevel: Number;
		hBDatastoreCandidatePolicy: String;
		heartbeatDatastore: VcDatastore[];
		hostMonitoring: String;
		metroHASettings: VcClusterDasMetroHASettings;
		option: VcOptionValue[];
		vmComponentProtecting: String;
		vmMonitoring: String;

		constructor();
	}

	interface VcClusterDasConfigInfoHBDatastoreCandidate
	{
		readonly _allFeasibleDs: String;
		readonly _allFeasibleDsWithUserPreference: String;
		readonly _userSelectedDs: String;
		readonly allFeasibleDs: VcClusterDasConfigInfoHBDatastoreCandidate;
		readonly allFeasibleDsWithUserPreference: VcClusterDasConfigInfoHBDatastoreCandidate;
		readonly id: String;
		readonly name: String;
		readonly userSelectedDs: VcClusterDasConfigInfoHBDatastoreCandidate;
		readonly value: String;

		fromString(value?: String): VcClusterDasConfigInfoHBDatastoreCandidate;
	}

	interface VcClusterDasConfigInfoHBDatastoreCandidateConstructor {
		new(value?:any): VcClusterDasConfigInfoHBDatastoreCandidate;
		readonly prototype: VcClusterDasConfigInfoHBDatastoreCandidate;
	}

	declare const VcClusterDasConfigInfoHBDatastoreCandidate: VcClusterDasConfigInfoHBDatastoreCandidateConstructor;

	interface VcClusterDasConfigInfoServiceState
	{
		readonly _disabled: String;
		readonly _enabled: String;
		readonly disabled: VcClusterDasConfigInfoServiceState;
		readonly enabled: VcClusterDasConfigInfoServiceState;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcClusterDasConfigInfoServiceState;
	}

	interface VcClusterDasConfigInfoServiceStateConstructor {
		new(value?:any): VcClusterDasConfigInfoServiceState;
		readonly prototype: VcClusterDasConfigInfoServiceState;
	}

	declare const VcClusterDasConfigInfoServiceState: VcClusterDasConfigInfoServiceStateConstructor;

	interface VcClusterDasConfigInfoVmMonitoringState
	{
		readonly _vmAndAppMonitoring: String;
		readonly _vmMonitoringDisabled: String;
		readonly _vmMonitoringOnly: String;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmAndAppMonitoring: VcClusterDasConfigInfoVmMonitoringState;
		readonly vmMonitoringDisabled: VcClusterDasConfigInfoVmMonitoringState;
		readonly vmMonitoringOnly: VcClusterDasConfigInfoVmMonitoringState;

		fromString(value?: String): VcClusterDasConfigInfoVmMonitoringState;
	}

	interface VcClusterDasConfigInfoVmMonitoringStateConstructor {
		new(value?:any): VcClusterDasConfigInfoVmMonitoringState;
		readonly prototype: VcClusterDasConfigInfoVmMonitoringState;
	}

	declare const VcClusterDasConfigInfoVmMonitoringState: VcClusterDasConfigInfoVmMonitoringStateConstructor;

	declare class VcClusterDasData
	{

		constructor();
	}

	declare class VcClusterDasDataSummary
	{
		clusterConfigVersion: Number;
		compatListVersion: Number;
		hostListVersion: Number;

		constructor();
	}

	declare class VcClusterDasFailoverLevelAdvancedRuntimeInfo
	{
		dasHostInfo: VcClusterDasHostInfo;
		heartbeatDatastoreInfo: VcDasHeartbeatDatastoreInfo[];
		hostSlots: VcClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots[];
		slotInfo: VcClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo;
		totalGoodHosts: Number;
		totalHosts: Number;
		totalSlots: Number;
		totalVms: Number;
		unreservedSlots: Number;
		usedSlots: Number;
		vmcpSupported: VcClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo;
		vmsRequiringMultipleSlots: VcClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots[];

		constructor();
	}

	declare class VcClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots
	{
		host: VcHostSystem;
		slots: Number;

		constructor();
	}

	declare class VcClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo
	{
		cpuMHz: Number;
		memoryMB: Number;
		numVcpus: Number;

		constructor();
	}

	declare class VcClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots
	{
		slots: Number;
		vm: VcVirtualMachine;

		constructor();
	}

	interface VcClusterDasFdmAvailabilityState
	{
		readonly _connectedToMaster: String;
		readonly _election: String;
		readonly _fdmUnreachable: String;
		readonly _hostDown: String;
		readonly _initializationError: String;
		readonly _master: String;
		readonly _networkIsolated: String;
		readonly _networkPartitionedFromMaster: String;
		readonly _uninitializationError: String;
		readonly _uninitialized: String;
		readonly connectedToMaster: VcClusterDasFdmAvailabilityState;
		readonly election: VcClusterDasFdmAvailabilityState;
		readonly fdmUnreachable: VcClusterDasFdmAvailabilityState;
		readonly hostDown: VcClusterDasFdmAvailabilityState;
		readonly id: String;
		readonly initializationError: VcClusterDasFdmAvailabilityState;
		readonly master: VcClusterDasFdmAvailabilityState;
		readonly name: String;
		readonly networkIsolated: VcClusterDasFdmAvailabilityState;
		readonly networkPartitionedFromMaster: VcClusterDasFdmAvailabilityState;
		readonly uninitializationError: VcClusterDasFdmAvailabilityState;
		readonly uninitialized: VcClusterDasFdmAvailabilityState;
		readonly value: String;

		fromString(value?: String): VcClusterDasFdmAvailabilityState;
	}

	interface VcClusterDasFdmAvailabilityStateConstructor {
		new(value?:any): VcClusterDasFdmAvailabilityState;
		readonly prototype: VcClusterDasFdmAvailabilityState;
	}

	declare const VcClusterDasFdmAvailabilityState: VcClusterDasFdmAvailabilityStateConstructor;

	declare class VcClusterDasFdmHostState
	{
		state: String;
		stateReporter: VcHostSystem;

		constructor();
	}

	declare class VcClusterDasHostInfo
	{

		constructor();
	}

	declare class VcClusterDasHostRecommendation
	{
		drsRating: Number;
		host: VcHostSystem;

		constructor();
	}

	declare class VcClusterDasMetroHASettings
	{
		enabled: boolean;

		constructor();
	}

	declare class VcClusterDasVmConfigInfo
	{
		dasSettings: VcClusterDasVmSettings;
		goldenSnapshot: VcVirtualMachineSnapshot;
		key: VcVirtualMachine;
		powerOffOnIsolation: boolean;
		restartPriority: VcDasVmPriority;

		constructor();
	}

	declare class VcClusterDasVmConfigSpec
	{
		info: VcClusterDasVmConfigInfo;
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcClusterDasVmSettings
	{
		isolationResponse: String;
		restartPriority: String;
		vmComponentProtectionSettings: VcClusterVmComponentProtectionSettings;
		vmToolsMonitoringSettings: VcClusterVmToolsMonitoringSettings;

		constructor();
	}

	interface VcClusterDasVmSettingsIsolationResponse
	{
		readonly _clusterIsolationResponse: String;
		readonly _none: String;
		readonly _powerOff: String;
		readonly _shutdown: String;
		readonly clusterIsolationResponse: VcClusterDasVmSettingsIsolationResponse;
		readonly id: String;
		readonly name: String;
		readonly none: VcClusterDasVmSettingsIsolationResponse;
		readonly powerOff: VcClusterDasVmSettingsIsolationResponse;
		readonly shutdown: VcClusterDasVmSettingsIsolationResponse;
		readonly value: String;

		fromString(value?: String): VcClusterDasVmSettingsIsolationResponse;
	}

	interface VcClusterDasVmSettingsIsolationResponseConstructor {
		new(value?:any): VcClusterDasVmSettingsIsolationResponse;
		readonly prototype: VcClusterDasVmSettingsIsolationResponse;
	}

	declare const VcClusterDasVmSettingsIsolationResponse: VcClusterDasVmSettingsIsolationResponseConstructor;

	interface VcClusterDasVmSettingsRestartPriority
	{
		readonly _clusterRestartPriority: String;
		readonly _disabled: String;
		readonly _high: String;
		readonly _low: String;
		readonly _medium: String;
		readonly clusterRestartPriority: VcClusterDasVmSettingsRestartPriority;
		readonly disabled: VcClusterDasVmSettingsRestartPriority;
		readonly high: VcClusterDasVmSettingsRestartPriority;
		readonly id: String;
		readonly low: VcClusterDasVmSettingsRestartPriority;
		readonly medium: VcClusterDasVmSettingsRestartPriority;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcClusterDasVmSettingsRestartPriority;
	}

	interface VcClusterDasVmSettingsRestartPriorityConstructor {
		new(value?:any): VcClusterDasVmSettingsRestartPriority;
		readonly prototype: VcClusterDasVmSettingsRestartPriority;
	}

	declare const VcClusterDasVmSettingsRestartPriority: VcClusterDasVmSettingsRestartPriorityConstructor;

	declare class VcClusterDestroyedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcClusterDiagnoseResourceAllocationResultVmStaticEntitlement
	{
		staticEntitlement: VcClusterPerResourceValue[];
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcClusterDpmConfigInfo
	{
		defaultDpmBehavior: VcDpmBehavior;
		enabled: boolean;
		hostPowerActionRate: Number;
		option: VcOptionValue[];

		constructor();
	}

	declare class VcClusterDpmHostConfigInfo
	{
		behavior: VcDpmBehavior;
		enabled: boolean;
		key: VcHostSystem;

		constructor();
	}

	declare class VcClusterDpmHostConfigSpec
	{
		info: VcClusterDpmHostConfigInfo;
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcClusterDrsConfigInfo
	{
		defaultVmBehavior: VcDrsBehavior;
		enabled: boolean;
		enableVmBehaviorOverrides: boolean;
		option: VcOptionValue[];
		vmotionRate: Number;

		constructor();
	}

	declare class VcClusterDrsFaults
	{
		faultsByVm: VcClusterDrsFaultsFaultsByVm[];
		reason: String;

		constructor();
	}

	declare class VcClusterDrsFaultsFaultsByVirtualDisk
	{
		disk: VcVirtualDiskId;
		fault: VcLocalizedMethodFault[];
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcClusterDrsFaultsFaultsByVm
	{
		fault: VcLocalizedMethodFault[];
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcClusterDrsMigration
	{
		cpuLoad: Number;
		destination: VcHostSystem;
		destinationCpuLoad: Number;
		destinationMemoryLoad: Number;
		key: String;
		memoryLoad: Number;
		source: VcHostSystem;
		sourceCpuLoad: Number;
		sourceMemoryLoad: Number;
		time: Date;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcClusterDrsRecommendation
	{
		key: String;
		migrationList: VcClusterDrsMigration[];
		rating: Number;
		reason: String;
		reasonText: String;

		constructor();
	}

	declare class VcClusterDrsVmConfigInfo
	{
		behavior: VcDrsBehavior;
		enabled: boolean;
		key: VcVirtualMachine;

		constructor();
	}

	declare class VcClusterDrsVmConfigSpec
	{
		info: VcClusterDrsVmConfigInfo;
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcClusterEnterMaintenanceResult
	{
		fault: VcClusterDrsFaults;
		recommendations: VcClusterRecommendation[];

		constructor();
	}

	interface VcClusterEVCManager
	{
		availableField: VcCustomFieldDef[];
		evcState: VcClusterEVCManagerEVCState;
		readonly id: String;
		managedCluster: VcClusterComputeResource;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		checkAddHostEvc_Task(cnxSpec?: VcHostConnectSpec): VcTask;
		checkConfigureEvcMode_Task(evcModeKey?: String): VcTask;
		configureEvcMode_Task(evcModeKey?: String): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		disableEvcMode_Task(): VcTask;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcClusterEVCManager: VcClusterEVCManager;

	declare class VcClusterEVCManagerCheckResult
	{
		error: VcLocalizedMethodFault;
		evcModeKey: String;
		host: VcHostSystem[];

		constructor();
	}

	declare class VcClusterEVCManagerEVCState
	{
		currentEVCModeKey: String;
		featureCapability: VcHostFeatureCapability[];
		featureMask: VcHostFeatureMask[];
		featureRequirement: VcVirtualMachineFeatureRequirement[];
		guaranteedCPUFeatures: VcHostCpuIdInfo[];
		supportedEVCMode: VcEVCMode[];

		constructor();
	}

	declare class VcClusterEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcClusterFailoverHostAdmissionControlInfo
	{
		hostStatus: VcClusterFailoverHostAdmissionControlInfoHostStatus[];

		constructor();
	}

	declare class VcClusterFailoverHostAdmissionControlInfoHostStatus
	{
		host: VcHostSystem;
		status: VcManagedEntityStatus;

		constructor();
	}

	declare class VcClusterFailoverHostAdmissionControlPolicy
	{
		failoverHosts: VcHostSystem[];

		constructor();
	}

	declare class VcClusterFailoverLevelAdmissionControlInfo
	{
		currentFailoverLevel: Number;

		constructor();
	}

	declare class VcClusterFailoverLevelAdmissionControlPolicy
	{
		failoverLevel: Number;
		slotPolicy: VcClusterSlotPolicy;

		constructor();
	}

	declare class VcClusterFailoverResourcesAdmissionControlInfo
	{
		currentCpuFailoverResourcesPercent: Number;
		currentMemoryFailoverResourcesPercent: Number;

		constructor();
	}

	declare class VcClusterFailoverResourcesAdmissionControlPolicy
	{
		cpuFailoverResourcesPercent: Number;
		memoryFailoverResourcesPercent: Number;

		constructor();
	}

	declare class VcClusterFixedSizeSlotPolicy
	{
		cpu: Number;
		memory: Number;

		constructor();
	}

	declare class VcClusterFtVmHostRuleInfo
	{
		enabled: boolean;
		hostGroupName: String[];
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		primaryVmGroupName: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;

		constructor();
	}

	declare class VcClusterGroupInfo
	{
		name: String;
		uniqueID: String;
		userCreated: boolean;

		constructor();
	}

	declare class VcClusterGroupSpec
	{
		info: VcClusterGroupInfo;
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcClusterHostGroup
	{
		host: VcHostSystem[];
		name: String;
		uniqueID: String;
		userCreated: boolean;

		constructor();
	}

	declare class VcClusterHostPowerAction
	{
		cpuCapacityMHz: Number;
		memCapacityMB: Number;
		operationType: VcHostPowerOperationType;
		powerConsumptionWatt: Number;
		target: VcManagedObjectReference;
		type: String;

		constructor();
	}

	declare class VcClusterHostRecommendation
	{
		host: VcHostSystem;
		rating: Number;

		constructor();
	}

	declare class VcClusterIncreaseAllocationAction
	{
		delta: VcClusterPerResourceValue;
		target: VcManagedObjectReference;
		type: String;

		constructor();
	}

	declare class VcClusterIncreaseCpuCapacityAction
	{
		delta: Number;
		numCpus: Number;
		target: VcManagedObjectReference;
		type: String;

		constructor();
	}

	declare class VcClusterInitialPlacementAction
	{
		pool: VcResourcePool;
		target: VcManagedObjectReference;
		targetHost: VcHostSystem;
		type: String;

		constructor();
	}

	declare class VcClusterIoFilterInfo
	{
		id: String;
		name: String;
		opType: String;
		releaseDate: String;
		summary: String;
		vendor: String;
		version: String;

		constructor();
	}

	declare class VcClusterMigrationAction
	{
		drsMigration: VcClusterDrsMigration;
		target: VcManagedObjectReference;
		type: String;

		constructor();
	}

	declare class VcClusterNotAttemptedVmInfo
	{
		fault: VcLocalizedMethodFault;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcClusterOvercommittedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcClusterPerResourceValue
	{
		resourceType: String;
		value: Number;

		constructor();
	}

	interface VcClusterPowerOnVmOption
	{
		readonly _OverrideAutomationLevel: String;
		readonly _ReserveResources: String;
		readonly id: String;
		readonly name: String;
		readonly OverrideAutomationLevel: VcClusterPowerOnVmOption;
		readonly ReserveResources: VcClusterPowerOnVmOption;
		readonly value: String;

		fromString(value?: String): VcClusterPowerOnVmOption;
	}

	interface VcClusterPowerOnVmOptionConstructor {
		new(value?:any): VcClusterPowerOnVmOption;
		readonly prototype: VcClusterPowerOnVmOption;
	}

	declare const VcClusterPowerOnVmOption: VcClusterPowerOnVmOptionConstructor;

	declare class VcClusterPowerOnVmResult
	{
		attempted: VcClusterAttemptedVmInfo[];
		notAttempted: VcClusterNotAttemptedVmInfo[];
		recommendations: VcClusterRecommendation[];

		constructor();
	}

	interface VcClusterProfile
	{
		complianceStatus: String;
		config: VcProfileConfigInfo;
		createdTime: Date;
		description: VcProfileDescription;
		entity: VcManagedEntity[];
		readonly id: String;
		modifiedTime: Date;
		name: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		associateProfile(entity?: VcManagedEntity[]): void;
		checkProfileCompliance_Task(entity?: VcManagedEntity[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyProfile(): void;
		dissociateProfile(entity?: VcManagedEntity[]): void;
		exportProfile(): String;
		retrieveDescription(): VcProfileDescription;
		updateClusterProfile(config?: VcClusterProfileConfigSpec): void;
	}

	declare const VcClusterProfile: VcClusterProfile;

	declare class VcClusterProfileCompleteConfigSpec
	{
		annotation: String;
		complyProfile: VcComplianceProfile;
		enabled: boolean;
		name: String;

		constructor();
	}

	declare class VcClusterProfileConfigInfo
	{
		annotation: String;
		complyProfile: VcComplianceProfile;
		enabled: boolean;
		name: String;

		constructor();
	}

	declare class VcClusterProfileConfigServiceCreateSpec
	{
		annotation: String;
		enabled: boolean;
		name: String;
		serviceType: String[];

		constructor();
	}

	declare class VcClusterProfileConfigSpec
	{
		annotation: String;
		enabled: boolean;
		name: String;

		constructor();
	}

	declare class VcClusterProfileCreateSpec
	{
		annotation: String;
		enabled: boolean;
		name: String;

		constructor();
	}

	interface VcClusterProfileManager
	{
		readonly id: String;
		profile: VcProfile[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createProfile(createSpec?: VcProfileCreateSpec): VcProfile;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		findAssociatedProfile(entity?: VcManagedEntity): VcProfile[];
		queryPolicyMetadata(policyName?: String[], profile?: VcProfile): VcProfilePolicyMetadata[];
	}

	declare const VcClusterProfileManager: VcClusterProfileManager;

	interface VcClusterProfileServiceType
	{
		readonly _DPM: String;
		readonly _DRS: String;
		readonly _FT: String;
		readonly _HA: String;
		readonly DPM: VcClusterProfileServiceType;
		readonly DRS: VcClusterProfileServiceType;
		readonly FT: VcClusterProfileServiceType;
		readonly HA: VcClusterProfileServiceType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcClusterProfileServiceType;
	}

	interface VcClusterProfileServiceTypeConstructor {
		new(value?:any): VcClusterProfileServiceType;
		readonly prototype: VcClusterProfileServiceType;
	}

	declare const VcClusterProfileServiceType: VcClusterProfileServiceTypeConstructor;

	declare class VcClusterRecommendation
	{
		action: VcClusterAction[];
		key: String;
		prerequisite: String[];
		rating: Number;
		reason: String;
		reasonText: String;
		target: VcManagedObjectReference;
		time: Date;
		type: String;
		warningDetails: VcLocalizableMessage;
		warningText: String;

		constructor();
	}

	declare class VcClusterReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcClusterResourceUsageSummary
	{
		cpuCapacityMHz: Number;
		cpuUsedMHz: Number;
		memCapacityMB: Number;
		memUsedMB: Number;
		storageCapacityMB: Number;
		storageUsedMB: Number;

		constructor();
	}

	declare class VcClusterRuleInfo
	{
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;

		constructor();
	}

	declare class VcClusterRuleSpec
	{
		info: VcClusterRuleInfo;
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcClusterSlotPolicy
	{

		constructor();
	}

	declare class VcClusterStatusChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newStatus: String;
		oldStatus: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcClusterUsageSummary
	{
		cpuDemandMhz: Number;
		cpuEntitledMhz: Number;
		cpuReservationMhz: Number;
		memDemandMB: Number;
		memEntitledMB: Number;
		memReservationMB: Number;
		poweredOffCpuReservationMhz: Number;
		poweredOffMemReservationMB: Number;
		poweredOffVmCount: Number;
		statsGenNumber: Number;
		totalCpuCapacityMhz: Number;
		totalMemCapacityMB: Number;
		totalVmCount: Number;

		constructor();
	}

	declare class VcClusterVmComponentProtectionSettings
	{
		enableAPDTimeoutForHosts: boolean;
		vmReactionOnAPDCleared: String;
		vmStorageProtectionForAPD: String;
		vmStorageProtectionForPDL: String;
		vmTerminateDelayForAPDSec: Number;

		constructor();
	}

	interface VcClusterVmComponentProtectionSettingsStorageVmReaction
	{
		readonly _clusterDefault: String;
		readonly _disabled: String;
		readonly _restartAggressive: String;
		readonly _restartConservative: String;
		readonly _warning: String;
		readonly clusterDefault: VcClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly disabled: VcClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly id: String;
		readonly name: String;
		readonly restartAggressive: VcClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly restartConservative: VcClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly value: String;
		readonly warning: VcClusterVmComponentProtectionSettingsStorageVmReaction;

		fromString(value?: String): VcClusterVmComponentProtectionSettingsStorageVmReaction;
	}

	interface VcClusterVmComponentProtectionSettingsStorageVmReactionConstructor {
		new(value?:any): VcClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly prototype: VcClusterVmComponentProtectionSettingsStorageVmReaction;
	}

	declare const VcClusterVmComponentProtectionSettingsStorageVmReaction: VcClusterVmComponentProtectionSettingsStorageVmReactionConstructor;

	interface VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared
	{
		readonly _none: String;
		readonly _reset: String;
		readonly _useClusterDefault: String;
		readonly id: String;
		readonly name: String;
		readonly none: VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
		readonly reset: VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
		readonly useClusterDefault: VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
		readonly value: String;

		fromString(value?: String): VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
	}

	interface VcClusterVmComponentProtectionSettingsVmReactionOnAPDClearedConstructor {
		new(value?:any): VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
		readonly prototype: VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
	}

	declare const VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared: VcClusterVmComponentProtectionSettingsVmReactionOnAPDClearedConstructor;

	declare class VcClusterVmGroup
	{
		name: String;
		uniqueID: String;
		userCreated: boolean;
		vm: VcVirtualMachine[];

		constructor();
	}

	declare class VcClusterVmHostRuleInfo
	{
		affineHostGroupName: String;
		antiAffineHostGroupName: String;
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;
		vmGroupName: String;

		constructor();
	}

	declare class VcClusterVmToolsMonitoringSettings
	{
		clusterSettings: boolean;
		enabled: boolean;
		failureInterval: Number;
		maxFailures: Number;
		maxFailureWindow: Number;
		minUpTime: Number;
		vmMonitoring: String;

		constructor();
	}

	declare class VcComplianceFailure
	{
		expressionName: String;
		failureType: String;
		message: VcLocalizableMessage;

		constructor();
	}

	declare class VcComplianceLocator
	{
		applyPath: VcProfilePropertyPath;
		expressionName: String;

		constructor();
	}

	declare class VcComplianceProfile
	{
		expression: VcProfileExpression[];
		rootExpression: String;

		constructor();
	}

	declare class VcComplianceResult
	{
		checkTime: Date;
		complianceStatus: String;
		entity: VcManagedEntity;
		failure: VcComplianceFailure[];
		profile: VcProfile;

		constructor();
	}

	interface VcComplianceResultStatus
	{
		readonly _compliant: String;
		readonly _nonCompliant: String;
		readonly _unknown: String;
		readonly compliant: VcComplianceResultStatus;
		readonly id: String;
		readonly name: String;
		readonly nonCompliant: VcComplianceResultStatus;
		readonly unknown: VcComplianceResultStatus;
		readonly value: String;

		fromString(value?: String): VcComplianceResultStatus;
	}

	interface VcComplianceResultStatusConstructor {
		new(value?:any): VcComplianceResultStatus;
		readonly prototype: VcComplianceResultStatus;
	}

	declare const VcComplianceResultStatus: VcComplianceResultStatusConstructor;

	declare class VcCompositePolicyOption
	{
		id: String;
		option: VcPolicyOption[];
		parameter: VcKeyAnyValue[];

		constructor();
	}

	interface VcComputeResource
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		configurationEx: VcComputeResourceConfigInfo;
		customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		environmentBrowser: VcEnvironmentBrowser;
		host: VcHostSystem[];
		readonly id: String;
		name: String;
		network: VcNetwork[];
		readonly network_DistributedVirtualPortgroup: DistributedVirtualPortgroup[];
		readonly network_Network: Network[];
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		resourcePool: VcResourcePool;
		readonly resourcePool_ResourcePool: ResourcePool[];
		readonly resourcePool_VirtualApp: VirtualApp[];
		readonly sdkConnection: VcSdkConnection;
		summary: VcComputeResourceSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		reconfigureComputeResource_Task(spec?: VcComputeResourceConfigSpec, modify?: boolean): VcTask;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcComputeResource: VcComputeResource;

	declare class VcComputeResourceConfigInfo
	{
		defaultHardwareVersionKey: String;
		spbmEnabled: boolean;
		vmSwapPlacement: String;

		constructor();
	}

	declare class VcComputeResourceConfigSpec
	{
		defaultHardwareVersionKey: String;
		spbmEnabled: boolean;
		vmSwapPlacement: String;

		constructor();
	}

	declare class VcComputeResourceEventArgument
	{
		computeResource: VcComputeResource;
		name: String;

		constructor();
	}

	declare class VcComputeResourceHostSPBMLicenseInfo
	{
		host: VcHostSystem;
		licenseState: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;

		constructor();
	}

	interface VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState
	{
		readonly _licensed: String;
		readonly _unknown: String;
		readonly _unlicensed: String;
		readonly id: String;
		readonly licensed: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
		readonly name: String;
		readonly unknown: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
		readonly unlicensed: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
		readonly value: String;

		fromString(value?: String): VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
	}

	interface VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseStateConstructor {
		new(value?:any): VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
		readonly prototype: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
	}

	declare const VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState: VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseStateConstructor;

	declare class VcComputeResourceSummary
	{
		effectiveCpu: Number;
		effectiveMemory: Number;
		numCpuCores: Number;
		numCpuThreads: Number;
		numEffectiveHosts: Number;
		numHosts: Number;
		overallStatus: VcManagedEntityStatus;
		totalCpu: Number;
		totalMemory: Number;

		constructor();
	}

	interface VcConfigSpecOperation
	{
		readonly _add: String;
		readonly _edit: String;
		readonly _remove: String;
		readonly add: VcConfigSpecOperation;
		readonly edit: VcConfigSpecOperation;
		readonly id: String;
		readonly name: String;
		readonly remove: VcConfigSpecOperation;
		readonly value: String;

		fromString(value?: String): VcConfigSpecOperation;
	}

	interface VcConfigSpecOperationConstructor {
		new(value?:any): VcConfigSpecOperation;
		readonly prototype: VcConfigSpecOperation;
	}

	declare const VcConfigSpecOperation: VcConfigSpecOperationConstructor;

	declare class VcConfigTarget
	{
		autoVmotion: boolean;
		cdRom: VcVirtualMachineCdromInfo[];
		datastore: VcVirtualMachineDatastoreInfo[];
		distributedVirtualPortgroup: VcDistributedVirtualPortgroupInfo[];
		distributedVirtualSwitch: VcDistributedVirtualSwitchInfo[];
		floppy: VcVirtualMachineFloppyInfo[];
		ideDisk: VcVirtualMachineIdeDiskDeviceInfo[];
		legacyNetworkInfo: VcVirtualMachineLegacyNetworkSwitchInfo[];
		maxMemMBOptimalPerf: Number;
		network: VcVirtualMachineNetworkInfo[];
		numCpuCores: Number;
		numCpus: Number;
		numNumaNodes: Number;
		opaqueNetwork: VcOpaqueNetworkTargetInfo[];
		parallel: VcVirtualMachineParallelInfo[];
		pciPassthrough: VcVirtualMachinePciPassthroughInfo[];
		resourcePool: VcResourcePoolRuntimeInfo;
		scsiDisk: VcVirtualMachineScsiDiskDeviceInfo[];
		scsiPassthrough: VcVirtualMachineScsiPassthroughInfo[];
		serial: VcVirtualMachineSerialInfo[];
		sharedGpuPassthroughTypes: VcVirtualMachinePciSharedGpuPassthroughInfo[];
		smcPresent: boolean;
		sound: VcVirtualMachineSoundInfo[];
		sriov: VcVirtualMachineSriovInfo[];
		usb: VcVirtualMachineUsbInfo[];
		vFlashModule: VcVirtualMachineVFlashModuleInfo[];

		constructor();
	}

	declare class VcConflictingConfigurationConfig
	{
		entity: VcManagedEntity;
		propertyPath: String;

		constructor();
	}

	interface VcContainerView
	{

	}

	declare const VcContainerView: VcContainerView;

	declare class VcCreateTaskAction
	{
		cancelable: boolean;
		taskTypeId: String;

		constructor();
	}

	declare class VcCustomFieldDef
	{
		fieldDefPrivileges: VcPrivilegePolicyDef;
		fieldInstancePrivileges: VcPrivilegePolicyDef;
		key: Number;
		managedObjectType: String;
		name: String;
		type: String;

		constructor();
	}

	declare class VcCustomFieldDefAddedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fieldKey: Number;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		name: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomFieldDefEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fieldKey: Number;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		name: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomFieldDefRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fieldKey: Number;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		name: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomFieldDefRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fieldKey: Number;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		name: String;
		net: VcNetworkEventArgument;
		newName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomFieldEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcCustomFieldsManager
	{
		field: VcCustomFieldDef[];
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addCustomFieldDef(name?: String, moType?: String, fieldDefPolicy?: VcPrivilegePolicyDef, fieldPolicy?: VcPrivilegePolicyDef): VcCustomFieldDef;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		removeCustomFieldDef(key?: Number): void;
		renameCustomFieldDef(key?: Number, name?: String): void;
		setField(entity?: VcManagedEntity, key?: Number, value?: String): void;
	}

	declare const VcCustomFieldsManager: VcCustomFieldsManager;

	declare class VcCustomFieldStringValue
	{
		key: Number;
		value: String;

		constructor();
	}

	declare class VcCustomFieldValue
	{
		key: Number;

		constructor();
	}

	declare class VcCustomFieldValueChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fieldKey: Number;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		name: String;
		net: VcNetworkEventArgument;
		userName: String;
		value: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomizationAdapterMapping
	{
		adapter: VcCustomizationIPSettings;
		macAddress: String;

		constructor();
	}

	declare class VcCustomizationAutoIpV6Generator
	{

		constructor();
	}

	declare class VcCustomizationCustomIpGenerator
	{
		argument: String;

		constructor();
	}

	declare class VcCustomizationCustomIpV6Generator
	{
		argument: String;

		constructor();
	}

	declare class VcCustomizationCustomName
	{
		argument: String;

		constructor();
	}

	declare class VcCustomizationDhcpIpGenerator
	{

		constructor();
	}

	declare class VcCustomizationDhcpIpV6Generator
	{

		constructor();
	}

	declare class VcCustomizationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomizationFailed
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomizationFixedIp
	{
		ipAddress: String;

		constructor();
	}

	declare class VcCustomizationFixedIpV6
	{
		ipAddress: String;
		subnetMask: Number;

		constructor();
	}

	declare class VcCustomizationFixedName
	{
		name: String;

		constructor();
	}

	declare class VcCustomizationGlobalIPSettings
	{
		dnsServerList: String[];
		dnsSuffixList: String[];

		constructor();
	}

	interface VcCustomizationGuestInstallManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		cleanupAfterUnattendedInstall(): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		prepareForUnattendedInstall(spec?: VcUnattendedInstallSpec): void;
	}

	declare const VcCustomizationGuestInstallManager: VcCustomizationGuestInstallManager;

	declare class VcCustomizationGuiRunOnce
	{
		commandList: String[];

		constructor();
	}

	declare class VcCustomizationGuiUnattended
	{
		autoLogon: boolean;
		autoLogonCount: Number;
		password: VcCustomizationPassword;
		timeZone: Number;

		constructor();
	}

	declare class VcCustomizationIdentification
	{
		domainAdmin: String;
		domainAdminPassword: VcCustomizationPassword;
		joinDomain: String;
		joinWorkgroup: String;

		constructor();
	}

	declare class VcCustomizationIdentitySettings
	{

		constructor();
	}

	declare class VcCustomizationIpGenerator
	{

		constructor();
	}

	declare class VcCustomizationIPSettings
	{
		dnsDomain: String;
		dnsServerList: String[];
		gateway: String[];
		ip: VcCustomizationIpGenerator;
		ipV6Spec: VcCustomizationIPSettingsIpV6AddressSpec;
		netBIOS: VcCustomizationNetBIOSMode;
		primaryWINS: String;
		secondaryWINS: String;
		subnetMask: String;

		constructor();
	}

	declare class VcCustomizationIPSettingsIpV6AddressSpec
	{
		gateway: String[];
		ip: VcCustomizationIpV6Generator[];

		constructor();
	}

	declare class VcCustomizationIpV6Generator
	{

		constructor();
	}

	interface VcCustomizationLicenseDataMode
	{
		readonly _perSeat: String;
		readonly _perServer: String;
		readonly id: String;
		readonly name: String;
		readonly perSeat: VcCustomizationLicenseDataMode;
		readonly perServer: VcCustomizationLicenseDataMode;
		readonly value: String;

		fromString(value?: String): VcCustomizationLicenseDataMode;
	}

	interface VcCustomizationLicenseDataModeConstructor {
		new(value?:any): VcCustomizationLicenseDataMode;
		readonly prototype: VcCustomizationLicenseDataMode;
	}

	declare const VcCustomizationLicenseDataMode: VcCustomizationLicenseDataModeConstructor;

	declare class VcCustomizationLicenseFilePrintData
	{
		autoMode: VcCustomizationLicenseDataMode;
		autoUsers: Number;

		constructor();
	}

	declare class VcCustomizationLinuxIdentityFailed
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomizationLinuxOptions
	{

		constructor();
	}

	declare class VcCustomizationLinuxPrep
	{
		domain: String;
		hostName: VcCustomizationName;
		hwClockUTC: boolean;
		timeZone: String;

		constructor();
	}

	declare class VcCustomizationName
	{

		constructor();
	}

	interface VcCustomizationNetBIOSMode
	{
		readonly _disableNetBIOS: String;
		readonly _enableNetBIOS: String;
		readonly _enableNetBIOSViaDhcp: String;
		readonly disableNetBIOS: VcCustomizationNetBIOSMode;
		readonly enableNetBIOS: VcCustomizationNetBIOSMode;
		readonly enableNetBIOSViaDhcp: VcCustomizationNetBIOSMode;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcCustomizationNetBIOSMode;
	}

	interface VcCustomizationNetBIOSModeConstructor {
		new(value?:any): VcCustomizationNetBIOSMode;
		readonly prototype: VcCustomizationNetBIOSMode;
	}

	declare const VcCustomizationNetBIOSMode: VcCustomizationNetBIOSModeConstructor;

	declare class VcCustomizationNetworkSetupFailed
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomizationOptions
	{

		constructor();
	}

	declare class VcCustomizationPassword
	{
		plainText: boolean;
		value: String;

		constructor();
	}

	declare class VcCustomizationPrefixName
	{
		base: String;

		constructor();
	}

	declare class VcCustomizationSpec
	{
		encryptionKey: Number[];
		globalIPSettings: VcCustomizationGlobalIPSettings;
		identity: VcCustomizationIdentitySettings;
		nicSettingMap: VcCustomizationAdapterMapping[];
		options: VcCustomizationOptions;

		constructor();
	}

	declare class VcCustomizationSpecInfo
	{
		changeVersion: String;
		description: String;
		lastUpdateTime: Date;
		name: String;
		type: String;

		constructor();
	}

	declare class VcCustomizationSpecItem
	{
		info: VcCustomizationSpecInfo;
		spec: VcCustomizationSpec;

		constructor();
	}

	interface VcCustomizationSpecManager
	{
		encryptionKey: Number[];
		readonly id: String;
		info: VcCustomizationSpecInfo[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		checkCustomizationResources(guestOs?: String): void;
		createCustomizationSpec(item?: VcCustomizationSpecItem): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		customizationSpecItemToXml(item?: VcCustomizationSpecItem): String;
		deleteCustomizationSpec(name?: String): void;
		doesCustomizationSpecExist(name?: String): boolean;
		duplicateCustomizationSpec(name?: String, newName?: String): void;
		getCustomizationSpec(name?: String): VcCustomizationSpecItem;
		overwriteCustomizationSpec(item?: VcCustomizationSpecItem): void;
		renameCustomizationSpec(name?: String, newName?: String): void;
		xmlToCustomizationSpecItem(specItemXml?: String): VcCustomizationSpecItem;
	}

	declare const VcCustomizationSpecManager: VcCustomizationSpecManager;

	declare class VcCustomizationStartedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomizationStatelessIpV6Generator
	{

		constructor();
	}

	declare class VcCustomizationSucceeded
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomizationSysprep
	{
		guiRunOnce: VcCustomizationGuiRunOnce;
		guiUnattended: VcCustomizationGuiUnattended;
		identification: VcCustomizationIdentification;
		licenseFilePrintData: VcCustomizationLicenseFilePrintData;
		userData: VcCustomizationUserData;

		constructor();
	}

	declare class VcCustomizationSysprepFailed
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		sysprepVersion: String;
		systemVersion: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcCustomizationSysprepRebootOption
	{
		readonly _noreboot: String;
		readonly _reboot: String;
		readonly _shutdown: String;
		readonly id: String;
		readonly name: String;
		readonly noreboot: VcCustomizationSysprepRebootOption;
		readonly reboot: VcCustomizationSysprepRebootOption;
		readonly shutdown: VcCustomizationSysprepRebootOption;
		readonly value: String;

		fromString(value?: String): VcCustomizationSysprepRebootOption;
	}

	interface VcCustomizationSysprepRebootOptionConstructor {
		new(value?:any): VcCustomizationSysprepRebootOption;
		readonly prototype: VcCustomizationSysprepRebootOption;
	}

	declare const VcCustomizationSysprepRebootOption: VcCustomizationSysprepRebootOptionConstructor;

	declare class VcCustomizationSysprepText
	{
		value: String;

		constructor();
	}

	declare class VcCustomizationUnknownFailure
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		logLocation: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcCustomizationUnknownIpGenerator
	{

		constructor();
	}

	declare class VcCustomizationUnknownIpV6Generator
	{

		constructor();
	}

	declare class VcCustomizationUnknownName
	{

		constructor();
	}

	declare class VcCustomizationUserData
	{
		computerName: VcCustomizationName;
		fullName: String;
		orgName: String;
		productId: String;

		constructor();
	}

	declare class VcCustomizationVirtualMachineName
	{

		constructor();
	}

	declare class VcCustomizationWinOptions
	{
		changeSID: boolean;
		deleteAccounts: boolean;
		reboot: VcCustomizationSysprepRebootOption;

		constructor();
	}

	declare class VcDailyTaskScheduler
	{
		activeTime: Date;
		expireTime: Date;
		hour: Number;
		interval: Number;
		minute: Number;

		constructor();
	}

	declare class VcDasAdmissionControlDisabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDasAdmissionControlEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDasAgentFoundEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDasAgentUnavailableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDasClusterIsolatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcDasConfigFaultDasConfigFaultReason
	{
		readonly _CreateConfigVvolFailed: String;
		readonly _DasNetworkMisconfiguration: String;
		readonly _HostMisconfiguration: String;
		readonly _HostNetworkMisconfiguration: String;
		readonly _InsufficientPrivileges: String;
		readonly _NoDatastoresConfigured: String;
		readonly _NoPrimaryAgentAvailable: String;
		readonly _Other: String;
		readonly _VSanNotSupportedOnHost: String;
		readonly CreateConfigVvolFailed: VcDasConfigFaultDasConfigFaultReason;
		readonly DasNetworkMisconfiguration: VcDasConfigFaultDasConfigFaultReason;
		readonly HostMisconfiguration: VcDasConfigFaultDasConfigFaultReason;
		readonly HostNetworkMisconfiguration: VcDasConfigFaultDasConfigFaultReason;
		readonly id: String;
		readonly InsufficientPrivileges: VcDasConfigFaultDasConfigFaultReason;
		readonly name: String;
		readonly NoDatastoresConfigured: VcDasConfigFaultDasConfigFaultReason;
		readonly NoPrimaryAgentAvailable: VcDasConfigFaultDasConfigFaultReason;
		readonly Other: VcDasConfigFaultDasConfigFaultReason;
		readonly value: String;
		readonly VSanNotSupportedOnHost: VcDasConfigFaultDasConfigFaultReason;

		fromString(value?: String): VcDasConfigFaultDasConfigFaultReason;
	}

	interface VcDasConfigFaultDasConfigFaultReasonConstructor {
		new(value?:any): VcDasConfigFaultDasConfigFaultReason;
		readonly prototype: VcDasConfigFaultDasConfigFaultReason;
	}

	declare const VcDasConfigFaultDasConfigFaultReason: VcDasConfigFaultDasConfigFaultReasonConstructor;

	declare class VcDasDisabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDasEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDasHeartbeatDatastoreInfo
	{
		datastore: VcDatastore;
		hosts: VcHostSystem[];

		constructor();
	}

	declare class VcDasHostFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		failedHost: VcHostEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDasHostIsolatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		isolatedHost: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcDasVmPriority
	{
		readonly _disabled: String;
		readonly _high: String;
		readonly _low: String;
		readonly _medium: String;
		readonly disabled: VcDasVmPriority;
		readonly high: VcDasVmPriority;
		readonly id: String;
		readonly low: VcDasVmPriority;
		readonly medium: VcDasVmPriority;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcDasVmPriority;
	}

	interface VcDasVmPriorityConstructor {
		new(value?:any): VcDasVmPriority;
		readonly prototype: VcDasVmPriority;
	}

	declare const VcDasVmPriority: VcDasVmPriorityConstructor;

	declare class VcDatabaseSizeEstimate
	{
		size: Number;

		constructor();
	}

	declare class VcDatabaseSizeParam
	{
		inventoryDesc: VcInventoryDescription;
		perfStatsDesc: VcPerformanceStatisticsDescription;

		constructor();
	}

	interface VcDatacenter
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		configuration: VcDatacenterConfigInfo;
		customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		datastoreFolder: VcFolder;
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		hostFolder: VcFolder;
		readonly id: String;
		name: String;
		network: VcNetwork[];
		networkFolder: VcFolder;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;
		readonly vmFolder: VcFolder;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		powerOnMultiVM_Task(vm?: VcVirtualMachine[], option?: VcOptionValue[]): VcTask;
		queryConnectionInfo(hostname?: String, port?: Number, username?: String, password?: String, sslThumbprint?: String): VcHostConnectInfo;
		queryConnectionInfoViaSpec(spec?: VcHostConnectSpec): VcHostConnectInfo;
		queryDatacenterConfigOptionDescriptor(): VcVirtualMachineConfigOptionDescriptor[];
		reconfigureDatacenter_Task(spec?: VcDatacenterConfigSpec, modify?: boolean): VcTask;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcDatacenter: VcDatacenter;

	declare class VcDatacenterConfigInfo
	{
		defaultHardwareVersionKey: String;

		constructor();
	}

	declare class VcDatacenterConfigSpec
	{
		defaultHardwareVersionKey: String;

		constructor();
	}

	declare class VcDatacenterCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		parent: VcFolderEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatacenterEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatacenterEventArgument
	{
		datacenter: VcDatacenter;
		name: String;

		constructor();
	}

	declare class VcDatacenterMismatchArgument
	{
		entity: VcManagedEntity;
		inputDatacenter: VcDatacenter;

		constructor();
	}

	declare class VcDatacenterRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcDatastore
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		browser: VcHostDatastoreBrowser;
		capability: VcDatastoreCapability;
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		host: VcDatastoreHostMount[];
		readonly id: String;
		info: VcDatastoreInfo;
		iormConfiguration: VcStorageIORMInfo;
		name: String;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		summary: VcDatastoreSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;
		vm: VcVirtualMachine[];

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		datastoreEnterMaintenanceMode(): VcStoragePlacementResult;
		datastoreExitMaintenanceMode_Task(): VcTask;
		destroy_Task(): VcTask;
		destroyDatastore(): void;
		refreshDatastore(): void;
		refreshDatastoreStorageInfo(): void;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		renameDatastore(newName?: String): void;
		setCustomValue(key?: String, value?: String): void;
		updateVirtualMachineFiles_Task(mountPathDatastoreMapping?: VcDatastoreMountPathDatastorePair[]): VcTask;
	}

	declare const VcDatastore: VcDatastore;

	interface VcDatastoreAccessible
	{
		readonly _False: String;
		readonly _True: String;
		readonly False: VcDatastoreAccessible;
		readonly id: String;
		readonly name: String;
		readonly True: VcDatastoreAccessible;
		readonly value: String;

		fromString(value?: String): VcDatastoreAccessible;
	}

	interface VcDatastoreAccessibleConstructor {
		new(value?:any): VcDatastoreAccessible;
		readonly prototype: VcDatastoreAccessible;
	}

	declare const VcDatastoreAccessible: VcDatastoreAccessibleConstructor;

	declare class VcDatastoreCapability
	{
		directoryHierarchySupported: boolean;
		nativeSnapshotCopySupported: boolean;
		nativeSnapshotSupported: boolean;
		perFileThinProvisioningSupported: boolean;
		rawDiskMappingsSupported: boolean;
		seSparseSupported: boolean;
		storageIORMSupported: boolean;
		topLevelDirectoryCreateSupported: boolean;

		constructor();
	}

	declare class VcDatastoreCapacityIncreasedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newCapacity: Number;
		oldCapacity: Number;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreDestroyedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreDiscoveredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreDuplicatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreEventArgument
	{
		datastore: VcDatastore;
		name: String;

		constructor();
	}

	declare class VcDatastoreFileCopiedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDatastore: VcDatastoreEventArgument;
		sourceFile: String;
		targetFile: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreFileDeletedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		targetFile: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreFileEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		targetFile: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreFileMovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDatastore: VcDatastoreEventArgument;
		sourceFile: String;
		targetFile: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreHostMount
	{
		key: VcHostSystem;
		mountInfo: VcHostMountInfo;

		constructor();
	}

	declare class VcDatastoreInfo
	{
		containerId: String;
		freeSpace: Number;
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxVirtualDiskCapacity: Number;
		name: String;
		timestamp: Date;
		url: String;

		constructor();
	}

	declare class VcDatastoreIORMReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreMountPathDatastorePair
	{
		datastore: VcDatastore;
		oldMountPath: String;

		constructor();
	}

	interface VcDatastoreNamespaceManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createDirectory(datastore?: VcDatastore, displayName?: String, policy?: String): String;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteDirectory(datacenter?: VcDatacenter, datastorePath?: String): void;
	}

	declare const VcDatastoreNamespaceManager: VcDatastoreNamespaceManager;

	declare class VcDatastoreOption
	{
		unsupportedVolumes: VcVirtualMachineDatastoreVolumeOption[];

		constructor();
	}

	declare class VcDatastorePrincipalConfigured
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastorePrincipal: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreRemovedOnHostEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreRenamedOnHostEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDatastoreSummary
	{
		accessible: boolean;
		capacity: Number;
		datastore: VcDatastore;
		freeSpace: Number;
		maintenanceMode: String;
		multipleHostAccess: boolean;
		name: String;
		type: String;
		uncommitted: Number;
		url: String;

		constructor();
	}

	interface VcDatastoreSummaryMaintenanceModeState
	{
		readonly _enteringMaintenance: String;
		readonly _inMaintenance: String;
		readonly _normal: String;
		readonly enteringMaintenance: VcDatastoreSummaryMaintenanceModeState;
		readonly id: String;
		readonly inMaintenance: VcDatastoreSummaryMaintenanceModeState;
		readonly name: String;
		readonly normal: VcDatastoreSummaryMaintenanceModeState;
		readonly value: String;

		fromString(value?: String): VcDatastoreSummaryMaintenanceModeState;
	}

	interface VcDatastoreSummaryMaintenanceModeStateConstructor {
		new(value?:any): VcDatastoreSummaryMaintenanceModeState;
		readonly prototype: VcDatastoreSummaryMaintenanceModeState;
	}

	declare const VcDatastoreSummaryMaintenanceModeState: VcDatastoreSummaryMaintenanceModeStateConstructor;

	declare class VcDateTimeProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	interface VcDayOfWeek
	{
		readonly _friday: String;
		readonly _monday: String;
		readonly _saturday: String;
		readonly _sunday: String;
		readonly _thursday: String;
		readonly _tuesday: String;
		readonly _wednesday: String;
		readonly friday: VcDayOfWeek;
		readonly id: String;
		readonly monday: VcDayOfWeek;
		readonly name: String;
		readonly saturday: VcDayOfWeek;
		readonly sunday: VcDayOfWeek;
		readonly thursday: VcDayOfWeek;
		readonly tuesday: VcDayOfWeek;
		readonly value: String;
		readonly wednesday: VcDayOfWeek;

		fromString(value?: String): VcDayOfWeek;
	}

	interface VcDayOfWeekConstructor {
		new(value?:any): VcDayOfWeek;
		readonly prototype: VcDayOfWeek;
	}

	declare const VcDayOfWeek: VcDayOfWeekConstructor;

	declare class VcDescription
	{
		label: String;
		summary: String;

		constructor();
	}

	declare class VcDeviceBackedVirtualDiskSpec
	{
		adapterType: String;
		device: String;
		diskType: String;

		constructor();
	}

	interface VcDeviceNotSupportedReason
	{
		readonly _guest: String;
		readonly _host: String;
		readonly guest: VcDeviceNotSupportedReason;
		readonly host: VcDeviceNotSupportedReason;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcDeviceNotSupportedReason;
	}

	interface VcDeviceNotSupportedReasonConstructor {
		new(value?:any): VcDeviceNotSupportedReason;
		readonly prototype: VcDeviceNotSupportedReason;
	}

	declare const VcDeviceNotSupportedReason: VcDeviceNotSupportedReasonConstructor;

	interface VcDiagnosticManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		browseDiagnosticLog(host?: VcHostSystem, key?: String, start?: Number, lines?: Number): VcDiagnosticManagerLogHeader;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		generateLogBundles_Task(includeDefault?: boolean, host?: VcHostSystem[], supportOptions?: VcKeyValue[]): VcTask;
		queryDescriptions(host?: VcHostSystem): VcDiagnosticManagerLogDescriptor[];
	}

	declare const VcDiagnosticManager: VcDiagnosticManager;

	declare class VcDiagnosticManagerBundleInfo
	{
		system: VcHostSystem;
		url: String;

		constructor();
	}

	interface VcDiagnosticManagerLogCreator
	{
		readonly _hostd: String;
		readonly _install: String;
		readonly _recordLog: String;
		readonly _serverd: String;
		readonly _vpxa: String;
		readonly _vpxClient: String;
		readonly _vpxd: String;
		readonly hostd: VcDiagnosticManagerLogCreator;
		readonly id: String;
		readonly install: VcDiagnosticManagerLogCreator;
		readonly name: String;
		readonly recordLog: VcDiagnosticManagerLogCreator;
		readonly serverd: VcDiagnosticManagerLogCreator;
		readonly value: String;
		readonly vpxa: VcDiagnosticManagerLogCreator;
		readonly vpxClient: VcDiagnosticManagerLogCreator;
		readonly vpxd: VcDiagnosticManagerLogCreator;

		fromString(value?: String): VcDiagnosticManagerLogCreator;
	}

	interface VcDiagnosticManagerLogCreatorConstructor {
		new(value?:any): VcDiagnosticManagerLogCreator;
		readonly prototype: VcDiagnosticManagerLogCreator;
	}

	declare const VcDiagnosticManagerLogCreator: VcDiagnosticManagerLogCreatorConstructor;

	declare class VcDiagnosticManagerLogDescriptor
	{
		creator: String;
		fileName: String;
		format: String;
		info: VcDescription;
		key: String;
		mimeType: String;

		constructor();
	}

	interface VcDiagnosticManagerLogFormat
	{
		readonly _plain: String;
		readonly id: String;
		readonly name: String;
		readonly plain: VcDiagnosticManagerLogFormat;
		readonly value: String;

		fromString(value?: String): VcDiagnosticManagerLogFormat;
	}

	interface VcDiagnosticManagerLogFormatConstructor {
		new(value?:any): VcDiagnosticManagerLogFormat;
		readonly prototype: VcDiagnosticManagerLogFormat;
	}

	declare const VcDiagnosticManagerLogFormat: VcDiagnosticManagerLogFormatConstructor;

	declare class VcDiagnosticManagerLogHeader
	{
		lineEnd: Number;
		lineStart: Number;
		lineText: String[];

		constructor();
	}

	interface VcDiagnosticPartitionStorageType
	{
		readonly _directAttached: String;
		readonly _networkAttached: String;
		readonly directAttached: VcDiagnosticPartitionStorageType;
		readonly id: String;
		readonly name: String;
		readonly networkAttached: VcDiagnosticPartitionStorageType;
		readonly value: String;

		fromString(value?: String): VcDiagnosticPartitionStorageType;
	}

	interface VcDiagnosticPartitionStorageTypeConstructor {
		new(value?:any): VcDiagnosticPartitionStorageType;
		readonly prototype: VcDiagnosticPartitionStorageType;
	}

	declare const VcDiagnosticPartitionStorageType: VcDiagnosticPartitionStorageTypeConstructor;

	interface VcDiagnosticPartitionType
	{
		readonly _multiHost: String;
		readonly _singleHost: String;
		readonly id: String;
		readonly multiHost: VcDiagnosticPartitionType;
		readonly name: String;
		readonly singleHost: VcDiagnosticPartitionType;
		readonly value: String;

		fromString(value?: String): VcDiagnosticPartitionType;
	}

	interface VcDiagnosticPartitionTypeConstructor {
		new(value?:any): VcDiagnosticPartitionType;
		readonly prototype: VcDiagnosticPartitionType;
	}

	declare const VcDiagnosticPartitionType: VcDiagnosticPartitionTypeConstructor;

	interface VcDisallowedChangeByServiceDisallowedChange
	{
		readonly _hotExtendDisk: String;
		readonly hotExtendDisk: VcDisallowedChangeByServiceDisallowedChange;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcDisallowedChangeByServiceDisallowedChange;
	}

	interface VcDisallowedChangeByServiceDisallowedChangeConstructor {
		new(value?:any): VcDisallowedChangeByServiceDisallowedChange;
		readonly prototype: VcDisallowedChangeByServiceDisallowedChange;
	}

	declare const VcDisallowedChangeByServiceDisallowedChange: VcDisallowedChangeByServiceDisallowedChangeConstructor;

	declare class VcDiskChangeExtent
	{
		length: Number;
		start: Number;

		constructor();
	}

	declare class VcDiskChangeInfo
	{
		changedArea: VcDiskChangeExtent[];
		length: Number;
		startOffset: Number;

		constructor();
	}

	declare class VcDistributedVirtualPort
	{
		config: VcDVPortConfigInfo;
		conflict: boolean;
		conflictPortKey: String;
		connectee: VcDistributedVirtualSwitchPortConnectee;
		connectionCookie: Number;
		dvsUuid: String;
		hostLocalPort: boolean;
		key: String;
		lastStatusChange: Date;
		portgroupKey: String;
		proxyHost: VcHostSystem;
		state: VcDVPortState;

		constructor();
	}

	interface VcDistributedVirtualPortgroup
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		config: VcDVPortgroupConfigInfo;
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		host: VcHostSystem[];
		readonly id: String;
		key: String;
		name: String;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		portKeys: String[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		summary: VcNetworkSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;
		vm: VcVirtualMachine[];

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		destroyNetwork(): void;
		DVPortgroupRollback_Task(entityBackup?: VcEntityBackupConfig): VcTask;
		reconfigureDVPortgroup_Task(spec?: VcDVPortgroupConfigSpec): VcTask;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcDistributedVirtualPortgroup: VcDistributedVirtualPortgroup;

	declare class VcDistributedVirtualPortgroupInfo
	{
		networkReservationSupported: boolean;
		portgroup: VcDistributedVirtualPortgroup;
		portgroupKey: String;
		portgroupName: String;
		portgroupType: String;
		switchName: String;
		switchUuid: String;
		uplinkPortgroup: boolean;

		constructor();
	}

	interface VcDistributedVirtualPortgroupMetaTagName
	{
		readonly _dvsName: String;
		readonly _portgroupName: String;
		readonly _portIndex: String;
		readonly dvsName: VcDistributedVirtualPortgroupMetaTagName;
		readonly id: String;
		readonly name: String;
		readonly portgroupName: VcDistributedVirtualPortgroupMetaTagName;
		readonly portIndex: VcDistributedVirtualPortgroupMetaTagName;
		readonly value: String;

		fromString(value?: String): VcDistributedVirtualPortgroupMetaTagName;
	}

	interface VcDistributedVirtualPortgroupMetaTagNameConstructor {
		new(value?:any): VcDistributedVirtualPortgroupMetaTagName;
		readonly prototype: VcDistributedVirtualPortgroupMetaTagName;
	}

	declare const VcDistributedVirtualPortgroupMetaTagName: VcDistributedVirtualPortgroupMetaTagNameConstructor;

	interface VcDistributedVirtualPortgroupPortgroupType
	{
		readonly _earlyBinding: String;
		readonly _ephemeral: String;
		readonly _lateBinding: String;
		readonly earlyBinding: VcDistributedVirtualPortgroupPortgroupType;
		readonly ephemeral: VcDistributedVirtualPortgroupPortgroupType;
		readonly id: String;
		readonly lateBinding: VcDistributedVirtualPortgroupPortgroupType;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcDistributedVirtualPortgroupPortgroupType;
	}

	interface VcDistributedVirtualPortgroupPortgroupTypeConstructor {
		new(value?:any): VcDistributedVirtualPortgroupPortgroupType;
		readonly prototype: VcDistributedVirtualPortgroupPortgroupType;
	}

	declare const VcDistributedVirtualPortgroupPortgroupType: VcDistributedVirtualPortgroupPortgroupTypeConstructor;

	interface VcDistributedVirtualSwitch
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		capability: VcDVSCapability;
		config: VcDVSConfigInfo;
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		readonly id: String;
		name: String;
		networkResourcePool: VcDVSNetworkResourcePool[];
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		portgroup: VcDistributedVirtualPortgroup[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		runtime: VcDVSRuntimeInfo;
		readonly sdkConnection: VcSdkConnection;
		summary: VcDVSSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		uuid: String;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addDVPortgroup_Task(spec?: VcDVPortgroupConfigSpec[]): VcTask;
		addNetworkResourcePool(configSpec?: VcDVSNetworkResourcePoolConfigSpec[]): void;
		createDVPortgroup_Task(spec?: VcDVPortgroupConfigSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		DVSClearPortDbEntry_Task(portKey?: String, dbClearSpec?: VcDVSPortDbClearSpec): VcTask;
		DVSFetchPortDb(portKey?: String): VcDVSPortDbQueryResults;
		DVSQueryAvailableOverlayClass(): VcDVSOverlayClassConfigInfo[];
		DVSReconfigureOverlayInstance_Task(configSpec?: VcDVSOverlayInstanceConfigSpec[]): VcTask;
		dvsReconfigureVmVnicNetworkResourcePool_Task(configSpec?: VcDvsVmVnicResourcePoolConfigSpec[]): VcTask;
		DVSRollback_Task(entityBackup?: VcEntityBackupConfig): VcTask;
		enableNetworkResourceManagement(enable?: boolean): void;
		fetchDVPortKeys(criteria?: VcDistributedVirtualSwitchPortCriteria): String[];
		fetchDVPorts(criteria?: VcDistributedVirtualSwitchPortCriteria): VcDistributedVirtualPort[];
		lookupDvPortGroup(portgroupKey?: String): VcDistributedVirtualPortgroup;
		mergeDvs_Task(dvs?: VcDistributedVirtualSwitch): VcTask;
		moveDVPort_Task(portKey?: String[], destinationPortgroupKey?: String): VcTask;
		performDvsProductSpecOperation_Task(operation?: String, productSpec?: VcDistributedVirtualSwitchProductSpec): VcTask;
		queryUsedVlanIdInDvs(): Number[];
		reconfigureDVPort_Task(port?: VcDVPortConfigSpec[]): VcTask;
		reconfigureDvs_Task(spec?: VcDVSConfigSpec): VcTask;
		rectifyDvsHost_Task(hosts?: VcHostSystem[]): VcTask;
		refreshDVPortState(portKeys?: String[]): void;
		reload(): void;
		removeNetworkResourcePool(key?: String[]): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
		updateDvsCapability(capability?: VcDVSCapability): void;
		updateDVSHealthCheckConfig_Task(healthCheckConfig?: VcDVSHealthCheckConfig[]): VcTask;
		updateNetworkResourcePool(configSpec?: VcDVSNetworkResourcePoolConfigSpec[]): void;
	}

	declare const VcDistributedVirtualSwitch: VcDistributedVirtualSwitch;

	interface VcDistributedVirtualSwitchHostInfrastructureTrafficClass
	{
		readonly _faultTolerance: String;
		readonly _hbr: String;
		readonly _iSCSI: String;
		readonly _management: String;
		readonly _nfs: String;
		readonly _vdp: String;
		readonly _virtualMachine: String;
		readonly _vmotion: String;
		readonly _vsan: String;
		readonly faultTolerance: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly hbr: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly id: String;
		readonly iSCSI: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly management: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly name: String;
		readonly nfs: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly value: String;
		readonly vdp: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly virtualMachine: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly vmotion: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly vsan: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;

		fromString(value?: String): VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
	}

	interface VcDistributedVirtualSwitchHostInfrastructureTrafficClassConstructor {
		new(value?:any): VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly prototype: VcDistributedVirtualSwitchHostInfrastructureTrafficClass;
	}

	declare const VcDistributedVirtualSwitchHostInfrastructureTrafficClass: VcDistributedVirtualSwitchHostInfrastructureTrafficClassConstructor;

	declare class VcDistributedVirtualSwitchHostMember
	{
		config: VcDistributedVirtualSwitchHostMemberConfigInfo;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		runtimeState: VcDistributedVirtualSwitchHostMemberRuntimeState;
		status: String;
		statusDetail: String;
		uplinkPortKey: String[];

		constructor();
	}

	declare class VcDistributedVirtualSwitchHostMemberBacking
	{

		constructor();
	}

	declare class VcDistributedVirtualSwitchHostMemberConfigInfo
	{
		backing: VcDistributedVirtualSwitchHostMemberBacking;
		host: VcHostSystem;
		maxProxySwitchPorts: Number;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];

		constructor();
	}

	declare class VcDistributedVirtualSwitchHostMemberConfigSpec
	{
		backing: VcDistributedVirtualSwitchHostMemberBacking;
		host: VcHostSystem;
		maxProxySwitchPorts: Number;
		operation: String;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];

		constructor();
	}

	interface VcDistributedVirtualSwitchHostMemberHostComponentState
	{
		readonly _disconnected: String;
		readonly _down: String;
		readonly _outOfSync: String;
		readonly _pending: String;
		readonly _up: String;
		readonly _warning: String;
		readonly disconnected: VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly down: VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly id: String;
		readonly name: String;
		readonly outOfSync: VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly pending: VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly up: VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly value: String;
		readonly warning: VcDistributedVirtualSwitchHostMemberHostComponentState;

		fromString(value?: String): VcDistributedVirtualSwitchHostMemberHostComponentState;
	}

	interface VcDistributedVirtualSwitchHostMemberHostComponentStateConstructor {
		new(value?:any): VcDistributedVirtualSwitchHostMemberHostComponentState;
		readonly prototype: VcDistributedVirtualSwitchHostMemberHostComponentState;
	}

	declare const VcDistributedVirtualSwitchHostMemberHostComponentState: VcDistributedVirtualSwitchHostMemberHostComponentStateConstructor;

	declare class VcDistributedVirtualSwitchHostMemberPnicBacking
	{
		pnicSpec: VcDistributedVirtualSwitchHostMemberPnicSpec[];

		constructor();
	}

	declare class VcDistributedVirtualSwitchHostMemberPnicSpec
	{
		connectionCookie: Number;
		pnicDevice: String;
		uplinkPortgroupKey: String;
		uplinkPortKey: String;

		constructor();
	}

	declare class VcDistributedVirtualSwitchHostMemberRuntimeState
	{
		currentMaxProxySwitchPorts: Number;

		constructor();
	}

	declare class VcDistributedVirtualSwitchHostProductSpec
	{
		productLineId: String;
		version: String;

		constructor();
	}

	declare class VcDistributedVirtualSwitchInfo
	{
		distributedVirtualSwitch: VcDistributedVirtualSwitch;
		networkReservationSupported: boolean;
		switchName: String;
		switchUuid: String;

		constructor();
	}

	declare class VcDistributedVirtualSwitchKeyedOpaqueBlob
	{
		key: String;
		opaqueData: String;

		constructor();
	}

	interface VcDistributedVirtualSwitchManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		DVSManagerExportEntity_Task(selectionSet?: VcSelectionSet[]): VcTask;
		DVSManagerImportEntity_Task(entityBackup?: VcEntityBackupConfig[], importType?: String): VcTask;
		DVSManagerLookupDvPortGroup(switchUuid?: String, portgroupKey?: String): VcDistributedVirtualPortgroup;
		queryAvailableDvsSpec(recommended?: boolean): VcDistributedVirtualSwitchProductSpec[];
		queryCompatibleHostForExistingDvs(container?: VcManagedEntity, recursive?: boolean, dvs?: VcDistributedVirtualSwitch): VcHostSystem[];
		queryCompatibleHostForNewDvs(container?: VcManagedEntity, recursive?: boolean, switchProductSpec?: VcDistributedVirtualSwitchProductSpec): VcHostSystem[];
		queryDvsByUuid(uuid?: String): VcDistributedVirtualSwitch;
		queryDvsCheckCompatibility(hostContainer?: VcDistributedVirtualSwitchManagerHostContainer, dvsProductSpec?: VcDistributedVirtualSwitchManagerDvsProductSpec, hostFilterSpec?: VcDistributedVirtualSwitchManagerHostDvsFilterSpec[]): VcDistributedVirtualSwitchManagerCompatibilityResult[];
		queryDvsCompatibleHostSpec(switchProductSpec?: VcDistributedVirtualSwitchProductSpec): VcDistributedVirtualSwitchHostProductSpec[];
		queryDvsConfigTarget(host?: VcHostSystem, dvs?: VcDistributedVirtualSwitch): VcDVSManagerDvsConfigTarget;
		queryDvsFeatureCapability(switchProductSpec?: VcDistributedVirtualSwitchProductSpec): VcDVSFeatureCapability;
		rectifyDvsOnHost_Task(hosts?: VcHostSystem[]): VcTask;
	}

	declare const VcDistributedVirtualSwitchManager: VcDistributedVirtualSwitchManager;

	declare class VcDistributedVirtualSwitchManagerCompatibilityResult
	{
		error: VcLocalizedMethodFault[];
		host: VcHostSystem;

		constructor();
	}

	declare class VcDistributedVirtualSwitchManagerDvsProductSpec
	{
		distributedVirtualSwitch: VcDistributedVirtualSwitch;
		newSwitchProductSpec: VcDistributedVirtualSwitchProductSpec;

		constructor();
	}

	declare class VcDistributedVirtualSwitchManagerHostArrayFilter
	{
		host: VcHostSystem[];
		inclusive: boolean;

		constructor();
	}

	declare class VcDistributedVirtualSwitchManagerHostContainer
	{
		container: VcManagedEntity;
		recursive: boolean;

		constructor();
	}

	declare class VcDistributedVirtualSwitchManagerHostContainerFilter
	{
		hostContainer: VcDistributedVirtualSwitchManagerHostContainer;
		inclusive: boolean;

		constructor();
	}

	declare class VcDistributedVirtualSwitchManagerHostDvsFilterSpec
	{
		inclusive: boolean;

		constructor();
	}

	declare class VcDistributedVirtualSwitchManagerHostDvsMembershipFilter
	{
		distributedVirtualSwitch: VcDistributedVirtualSwitch;
		inclusive: boolean;

		constructor();
	}

	declare class VcDistributedVirtualSwitchManagerImportResult
	{
		distributedVirtualPortgroup: VcDistributedVirtualPortgroup[];
		distributedVirtualSwitch: VcDistributedVirtualSwitch[];
		importFault: VcImportOperationBulkFaultFaultOnImport[];

		constructor();
	}

	interface VcDistributedVirtualSwitchNetworkResourceControlVersion
	{
		readonly _version2: String;
		readonly _version3: String;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly version2: VcDistributedVirtualSwitchNetworkResourceControlVersion;
		readonly version3: VcDistributedVirtualSwitchNetworkResourceControlVersion;

		fromString(value?: String): VcDistributedVirtualSwitchNetworkResourceControlVersion;
	}

	interface VcDistributedVirtualSwitchNetworkResourceControlVersionConstructor {
		new(value?:any): VcDistributedVirtualSwitchNetworkResourceControlVersion;
		readonly prototype: VcDistributedVirtualSwitchNetworkResourceControlVersion;
	}

	declare const VcDistributedVirtualSwitchNetworkResourceControlVersion: VcDistributedVirtualSwitchNetworkResourceControlVersionConstructor;

	interface VcDistributedVirtualSwitchNicTeamingPolicyMode
	{
		readonly _failover_explicit: String;
		readonly _loadbalance_ip: String;
		readonly _loadbalance_loadbased: String;
		readonly _loadbalance_srcid: String;
		readonly _loadbalance_srcmac: String;
		readonly failover_explicit: VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly id: String;
		readonly loadbalance_ip: VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly loadbalance_loadbased: VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly loadbalance_srcid: VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly loadbalance_srcmac: VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcDistributedVirtualSwitchNicTeamingPolicyMode;
	}

	interface VcDistributedVirtualSwitchNicTeamingPolicyModeConstructor {
		new(value?:any): VcDistributedVirtualSwitchNicTeamingPolicyMode;
		readonly prototype: VcDistributedVirtualSwitchNicTeamingPolicyMode;
	}

	declare const VcDistributedVirtualSwitchNicTeamingPolicyMode: VcDistributedVirtualSwitchNicTeamingPolicyModeConstructor;

	interface VcDistributedVirtualSwitchOverlayClassType
	{
		readonly _singleton: String;
		readonly _stackable: String;
		readonly id: String;
		readonly name: String;
		readonly singleton: VcDistributedVirtualSwitchOverlayClassType;
		readonly stackable: VcDistributedVirtualSwitchOverlayClassType;
		readonly value: String;

		fromString(value?: String): VcDistributedVirtualSwitchOverlayClassType;
	}

	interface VcDistributedVirtualSwitchOverlayClassTypeConstructor {
		new(value?:any): VcDistributedVirtualSwitchOverlayClassType;
		readonly prototype: VcDistributedVirtualSwitchOverlayClassType;
	}

	declare const VcDistributedVirtualSwitchOverlayClassType: VcDistributedVirtualSwitchOverlayClassTypeConstructor;

	declare class VcDistributedVirtualSwitchOverlayFeatureSpec
	{
		maximumDepth: Number;
		maximumInstance: Number;
		minimumDepth: Number;

		constructor();
	}

	declare class VcDistributedVirtualSwitchPortConnectee
	{
		addressHint: String;
		connectedEntity: VcManagedEntity;
		nicKey: String;
		type: String;

		constructor();
	}

	interface VcDistributedVirtualSwitchPortConnecteeConnecteeType
	{
		readonly _hostConsoleVnic: String;
		readonly _hostVmkVnic: String;
		readonly _pnic: String;
		readonly _vmVnic: String;
		readonly hostConsoleVnic: VcDistributedVirtualSwitchPortConnecteeConnecteeType;
		readonly hostVmkVnic: VcDistributedVirtualSwitchPortConnecteeConnecteeType;
		readonly id: String;
		readonly name: String;
		readonly pnic: VcDistributedVirtualSwitchPortConnecteeConnecteeType;
		readonly value: String;
		readonly vmVnic: VcDistributedVirtualSwitchPortConnecteeConnecteeType;

		fromString(value?: String): VcDistributedVirtualSwitchPortConnecteeConnecteeType;
	}

	interface VcDistributedVirtualSwitchPortConnecteeConnecteeTypeConstructor {
		new(value?:any): VcDistributedVirtualSwitchPortConnecteeConnecteeType;
		readonly prototype: VcDistributedVirtualSwitchPortConnecteeConnecteeType;
	}

	declare const VcDistributedVirtualSwitchPortConnecteeConnecteeType: VcDistributedVirtualSwitchPortConnecteeConnecteeTypeConstructor;

	declare class VcDistributedVirtualSwitchPortConnection
	{
		connectionCookie: Number;
		portgroupKey: String;
		portKey: String;
		switchUuid: String;

		constructor();
	}

	declare class VcDistributedVirtualSwitchPortCriteria
	{
		active: boolean;
		connected: boolean;
		inside: boolean;
		portgroupKey: String[];
		portKey: String[];
		scope: VcManagedEntity;
		uplinkPort: boolean;

		constructor();
	}

	declare class VcDistributedVirtualSwitchPortStatistics
	{
		bytesInBroadcast: Number;
		bytesInMulticast: Number;
		bytesInUnicast: Number;
		bytesOutBroadcast: Number;
		bytesOutMulticast: Number;
		bytesOutUnicast: Number;
		packetsInBroadcast: Number;
		packetsInDropped: Number;
		packetsInException: Number;
		packetsInMulticast: Number;
		packetsInUnicast: Number;
		packetsOutBroadcast: Number;
		packetsOutDropped: Number;
		packetsOutException: Number;
		packetsOutMulticast: Number;
		packetsOutUnicast: Number;

		constructor();
	}

	declare class VcDistributedVirtualSwitchProductSpec
	{
		build: String;
		bundleId: String;
		bundleUrl: String;
		forwardingClass: String;
		name: String;
		vendor: String;
		version: String;

		constructor();
	}

	interface VcDistributedVirtualSwitchProductSpecOperationType
	{
		readonly _notifyAvailableUpgrade: String;
		readonly _preInstall: String;
		readonly _proceedWithUpgrade: String;
		readonly _updateBundleInfo: String;
		readonly _upgrade: String;
		readonly id: String;
		readonly name: String;
		readonly notifyAvailableUpgrade: VcDistributedVirtualSwitchProductSpecOperationType;
		readonly preInstall: VcDistributedVirtualSwitchProductSpecOperationType;
		readonly proceedWithUpgrade: VcDistributedVirtualSwitchProductSpecOperationType;
		readonly updateBundleInfo: VcDistributedVirtualSwitchProductSpecOperationType;
		readonly upgrade: VcDistributedVirtualSwitchProductSpecOperationType;
		readonly value: String;

		fromString(value?: String): VcDistributedVirtualSwitchProductSpecOperationType;
	}

	interface VcDistributedVirtualSwitchProductSpecOperationTypeConstructor {
		new(value?:any): VcDistributedVirtualSwitchProductSpecOperationType;
		readonly prototype: VcDistributedVirtualSwitchProductSpecOperationType;
	}

	declare const VcDistributedVirtualSwitchProductSpecOperationType: VcDistributedVirtualSwitchProductSpecOperationTypeConstructor;

	interface VcDpmBehavior
	{
		readonly _automated: String;
		readonly _manual: String;
		readonly automated: VcDpmBehavior;
		readonly id: String;
		readonly manual: VcDpmBehavior;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcDpmBehavior;
	}

	interface VcDpmBehaviorConstructor {
		new(value?:any): VcDpmBehavior;
		readonly prototype: VcDpmBehavior;
	}

	declare const VcDpmBehavior: VcDpmBehaviorConstructor;

	interface VcDrsBehavior
	{
		readonly _fullyAutomated: String;
		readonly _manual: String;
		readonly _partiallyAutomated: String;
		readonly fullyAutomated: VcDrsBehavior;
		readonly id: String;
		readonly manual: VcDrsBehavior;
		readonly name: String;
		readonly partiallyAutomated: VcDrsBehavior;
		readonly value: String;

		fromString(value?: String): VcDrsBehavior;
	}

	interface VcDrsBehaviorConstructor {
		new(value?:any): VcDrsBehavior;
		readonly prototype: VcDrsBehavior;
	}

	declare const VcDrsBehavior: VcDrsBehaviorConstructor;

	declare class VcDrsDisabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsEnabledEvent
	{
		behavior: String;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsEnteredStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsEnteringStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsExitedStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsExitingStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsExitStandbyModeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcDrsInjectorWorkloadCorrelationState
	{
		readonly _Correlated: String;
		readonly _Uncorrelated: String;
		readonly Correlated: VcDrsInjectorWorkloadCorrelationState;
		readonly id: String;
		readonly name: String;
		readonly Uncorrelated: VcDrsInjectorWorkloadCorrelationState;
		readonly value: String;

		fromString(value?: String): VcDrsInjectorWorkloadCorrelationState;
	}

	interface VcDrsInjectorWorkloadCorrelationStateConstructor {
		new(value?:any): VcDrsInjectorWorkloadCorrelationState;
		readonly prototype: VcDrsInjectorWorkloadCorrelationState;
	}

	declare const VcDrsInjectorWorkloadCorrelationState: VcDrsInjectorWorkloadCorrelationStateConstructor;

	declare class VcDrsInvocationFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcDrsRecommendationReasonCode
	{
		readonly _antiAffin: String;
		readonly _fairnessCpuAvg: String;
		readonly _fairnessMemAvg: String;
		readonly _hostMaint: String;
		readonly _jointAffin: String;
		readonly antiAffin: VcDrsRecommendationReasonCode;
		readonly fairnessCpuAvg: VcDrsRecommendationReasonCode;
		readonly fairnessMemAvg: VcDrsRecommendationReasonCode;
		readonly hostMaint: VcDrsRecommendationReasonCode;
		readonly id: String;
		readonly jointAffin: VcDrsRecommendationReasonCode;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcDrsRecommendationReasonCode;
	}

	interface VcDrsRecommendationReasonCodeConstructor {
		new(value?:any): VcDrsRecommendationReasonCode;
		readonly prototype: VcDrsRecommendationReasonCode;
	}

	declare const VcDrsRecommendationReasonCode: VcDrsRecommendationReasonCodeConstructor;

	declare class VcDrsRecoveredFromFailureEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsResourceConfigureFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsResourceConfigureSyncedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsRuleComplianceEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsRuleViolationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsSoftRuleViolationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsVmMigratedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDatacenter: VcDatacenterEventArgument;
		sourceDatastore: VcDatastoreEventArgument;
		sourceHost: VcHostEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDrsVmPoweredOnEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDuplicateIpDetectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		duplicateIP: String;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		macAddress: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvpgImportEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		importType: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvpgRestoreEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVPortConfigInfo
	{
		configVersion: String;
		description: String;
		name: String;
		scope: VcManagedEntity[];
		setting: VcDVPortSetting;

		constructor();
	}

	declare class VcDVPortConfigSpec
	{
		configVersion: String;
		description: String;
		key: String;
		name: String;
		operation: String;
		scope: VcManagedEntity[];
		setting: VcDVPortSetting;

		constructor();
	}

	declare class VcDVPortgroupConfigInfo
	{
		autoExpand: boolean;
		configVersion: String;
		defaultPortConfig: VcDVPortSetting;
		description: String;
		distributedVirtualSwitch: VcDistributedVirtualSwitch;
		key: String;
		name: String;
		numPorts: Number;
		policy: VcDVPortgroupPolicy;
		portNameFormat: String;
		scope: VcManagedEntity[];
		type: String;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vmVnicNetworkResourcePoolKey: String;

		constructor();
	}

	declare class VcDVPortgroupConfigSpec
	{
		autoExpand: boolean;
		configVersion: String;
		defaultPortConfig: VcDVPortSetting;
		description: String;
		name: String;
		numPorts: Number;
		policy: VcDVPortgroupPolicy;
		portNameFormat: String;
		scope: VcManagedEntity[];
		type: String;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vmVnicNetworkResourcePoolKey: String;

		constructor();
	}

	declare class VcDVPortgroupCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVPortgroupDestroyedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVPortgroupEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVPortgroupPolicy
	{
		blockOverrideAllowed: boolean;
		livePortMovingAllowed: boolean;
		networkResourcePoolOverrideAllowed: boolean;
		overlayParameterOverrideAllowed: boolean;
		portConfigResetAtDisconnect: boolean;
		shapingOverrideAllowed: boolean;
		statefulFirewallOverrideAllowed: boolean;
		switchSecurityOverrideAllowed: boolean;
		trafficFilterOverrideAllowed: boolean;
		vendorConfigOverrideAllowed: boolean;

		constructor();
	}

	declare class VcDVPortgroupReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configSpec: VcDVPortgroupConfigSpec;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVPortgroupRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVPortgroupSelection
	{
		dvsUuid: String;
		portgroupKey: String[];

		constructor();
	}

	declare class VcDVPortOverlayParameter
	{
		overlayInstanceKey: String;
		value: Number;

		constructor();
	}

	declare class VcDVPortOverlayParameterSpec
	{
		operation: String;
		overlayInstanceKey: String;
		value: Number;

		constructor();
	}

	declare class VcDVPortSetting
	{
		blocked: VcBoolPolicy;
		filterPolicy: VcDvsFilterPolicy;
		inShapingPolicy: VcDVSTrafficShapingPolicy;
		networkResourcePoolKey: VcStringPolicy;
		outShapingPolicy: VcDVSTrafficShapingPolicy;
		overlayParameter: VcDVSoverlayParameterPolicy;
		statefulFirewallPolicy: VcDvsStatefulFirewallPolicy;
		switchSecurityConfig: VcDVSSwitchSecurityConfig;
		vendorSpecificConfig: VcDVSVendorSpecificConfig;
		vmDirectPathGen2Allowed: VcBoolPolicy;

		constructor();
	}

	declare class VcDVPortState
	{
		runtimeInfo: VcDVPortStatus;
		stats: VcDistributedVirtualSwitchPortStatistics;
		vendorSpecificState: VcDistributedVirtualSwitchKeyedOpaqueBlob[];

		constructor();
	}

	declare class VcDVPortStatus
	{
		blocked: boolean;
		linkPeer: String;
		linkUp: boolean;
		macAddress: String;
		mtu: Number;
		statusDetail: String;
		trunkingMode: boolean;
		vlanIds: VcNumericRange[];
		vmDirectPathGen2Active: boolean;
		vmDirectPathGen2InactiveReasonExtended: String;
		vmDirectPathGen2InactiveReasonNetwork: String[];
		vmDirectPathGen2InactiveReasonOther: String[];

		constructor();
	}

	interface VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork
	{
		readonly _portNptDisabledForPort: String;
		readonly _portNptIncompatibleDvs: String;
		readonly _portNptNoCompatibleNics: String;
		readonly _portNptNoVirtualFunctionsAvailable: String;
		readonly id: String;
		readonly name: String;
		readonly portNptDisabledForPort: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly portNptIncompatibleDvs: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly portNptNoCompatibleNics: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly portNptNoVirtualFunctionsAvailable: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly value: String;

		fromString(value?: String): VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
	}

	interface VcDVPortStatusVmDirectPathGen2InactiveReasonNetworkConstructor {
		new(value?:any): VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly prototype: VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork;
	}

	declare const VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork: VcDVPortStatusVmDirectPathGen2InactiveReasonNetworkConstructor;

	interface VcDVPortStatusVmDirectPathGen2InactiveReasonOther
	{
		readonly _portNptIncompatibleConnectee: String;
		readonly _portNptIncompatibleHost: String;
		readonly id: String;
		readonly name: String;
		readonly portNptIncompatibleConnectee: VcDVPortStatusVmDirectPathGen2InactiveReasonOther;
		readonly portNptIncompatibleHost: VcDVPortStatusVmDirectPathGen2InactiveReasonOther;
		readonly value: String;

		fromString(value?: String): VcDVPortStatusVmDirectPathGen2InactiveReasonOther;
	}

	interface VcDVPortStatusVmDirectPathGen2InactiveReasonOtherConstructor {
		new(value?:any): VcDVPortStatusVmDirectPathGen2InactiveReasonOther;
		readonly prototype: VcDVPortStatusVmDirectPathGen2InactiveReasonOther;
	}

	declare const VcDVPortStatusVmDirectPathGen2InactiveReasonOther: VcDVPortStatusVmDirectPathGen2InactiveReasonOtherConstructor;

	declare class VcDvsAcceptNetworkRuleAction
	{

		constructor();
	}

	declare class VcDvsApplyOperationFaultFaultOnObject
	{
		fault: VcLocalizedMethodFault;
		objectId: String;
		type: String;

		constructor();
	}

	declare class VcDVSBackupRestoreCapability
	{
		backupRestoreSupported: boolean;

		constructor();
	}

	declare class VcDVSCapability
	{
		compatibleHostComponentProductInfo: VcDistributedVirtualSwitchHostProductSpec[];
		dvPortGroupOperationSupported: boolean;
		dvPortOperationSupported: boolean;
		dvsOperationSupported: boolean;
		featuresSupported: VcDVSFeatureCapability;

		constructor();
	}

	declare class VcDVSConfigInfo
	{
		configVersion: String;
		contact: VcDVSContactInfo;
		createTime: Date;
		defaultPortConfig: VcDVPortSetting;
		defaultProxySwitchMaxNumPorts: Number;
		description: String;
		extensionKey: String;
		healthCheckConfig: VcDVSHealthCheckConfig[];
		host: VcDistributedVirtualSwitchHostMember[];
		infrastructureTrafficResourceConfig: VcDvsHostInfrastructureTrafficResource[];
		maxPorts: Number;
		name: String;
		networkResourceControlVersion: String;
		networkResourceManagementEnabled: boolean;
		numPorts: Number;
		numStandalonePorts: Number;
		overlayInstance: VcDVSOverlayInstanceConfigInfo[];
		pnicCapacityRatioForReservation: Number;
		policy: VcDVSPolicy;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		switchIpAddress: String;
		targetInfo: VcDistributedVirtualSwitchProductSpec;
		uplinkPortgroup: VcDistributedVirtualPortgroup[];
		uplinkPortPolicy: VcDVSUplinkPortPolicy;
		uuid: String;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vmVnicNetworkResourcePool: VcDVSVmVnicNetworkResourcePool[];

		constructor();
	}

	declare class VcDVSConfigSpec
	{
		configVersion: String;
		contact: VcDVSContactInfo;
		defaultPortConfig: VcDVPortSetting;
		defaultProxySwitchMaxNumPorts: Number;
		description: String;
		extensionKey: String;
		host: VcDistributedVirtualSwitchHostMemberConfigSpec[];
		infrastructureTrafficResourceConfig: VcDvsHostInfrastructureTrafficResource[];
		maxPorts: Number;
		name: String;
		networkResourceControlVersion: String;
		numStandalonePorts: Number;
		policy: VcDVSPolicy;
		switchIpAddress: String;
		uplinkPortgroup: VcDistributedVirtualPortgroup[];
		uplinkPortPolicy: VcDVSUplinkPortPolicy;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];

		constructor();
	}

	declare class VcDVSContactInfo
	{
		contact: String;
		name: String;

		constructor();
	}

	declare class VcDvsCopyNetworkRuleAction
	{

		constructor();
	}

	declare class VcDvsCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		parent: VcFolderEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVSCreateSpec
	{
		capability: VcDVSCapability;
		configSpec: VcDVSConfigSpec;
		productInfo: VcDistributedVirtualSwitchProductSpec;

		constructor();
	}

	declare class VcDvsDestroyedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsDivertNetworkRuleAction
	{
		option: String;
		serviceId: String;

		constructor();
	}

	declare class VcDvsDropNetworkRuleAction
	{

		constructor();
	}

	declare class VcDVSDynamicArpInspectionConfig
	{
		arpRateLimit: VcIntPolicy;
		dynamicArpInspectionEnabled: VcBoolPolicy;
		errRateLimit: VcIntPolicy;
		errRateLimitPeriod: VcIntPolicy;
		inherited: boolean;

		constructor();
	}

	declare class VcDvsEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsEventArgument
	{
		dvs: VcDistributedVirtualSwitch;
		name: String;

		constructor();
	}

	declare class VcDVSFailureCriteria
	{
		checkBeacon: VcBoolPolicy;
		checkDuplex: VcBoolPolicy;
		checkErrorPercent: VcBoolPolicy;
		checkSpeed: VcStringPolicy;
		fullDuplex: VcBoolPolicy;
		inherited: boolean;
		percentage: VcIntPolicy;
		speed: VcIntPolicy;

		constructor();
	}

	declare class VcDVSFeatureCapability
	{
		backupRestoreCapability: VcDVSBackupRestoreCapability;
		healthCheckCapability: VcDVSHealthCheckCapability;
		networkFilterSupported: boolean;
		networkResourceManagementCapability: VcDVSNetworkResourceManagementCapability;
		networkResourceManagementSupported: boolean;
		networkResourcePoolHighShareValue: Number;
		nicTeamingPolicy: String[];
		overlayFeatureCapability: VcDistributedVirtualSwitchOverlayFeatureSpec;
		overlaySupported: boolean;
		rollbackCapability: VcDVSRollbackCapability;
		statefulFirewallCapability: VcDvsStatefulFirewallFeatureCapability;
		switchSecurityCapability: VcDVSSwitchSecurityFeatureCapability;
		vmDirectPathGen2Supported: boolean;

		constructor();
	}

	declare class VcDvsFilterConfig
	{
		agentName: String;
		inherited: boolean;
		key: String;
		onFailure: String;
		parameters: VcDvsFilterParameter;
		slotNumber: String;

		constructor();
	}

	declare class VcDvsFilterConfigSpec
	{
		agentName: String;
		inherited: boolean;
		key: String;
		onFailure: String;
		operation: String;
		parameters: VcDvsFilterParameter;
		slotNumber: String;

		constructor();
	}

	interface VcDvsFilterOnFailure
	{
		readonly _failClosed: String;
		readonly _failOpen: String;
		readonly failClosed: VcDvsFilterOnFailure;
		readonly failOpen: VcDvsFilterOnFailure;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcDvsFilterOnFailure;
	}

	interface VcDvsFilterOnFailureConstructor {
		new(value?:any): VcDvsFilterOnFailure;
		readonly prototype: VcDvsFilterOnFailure;
	}

	declare const VcDvsFilterOnFailure: VcDvsFilterOnFailureConstructor;

	declare class VcDvsFilterParameter
	{
		parameters: String[];

		constructor();
	}

	declare class VcDvsFilterPolicy
	{
		filterConfig: VcDvsFilterConfig[];
		inherited: boolean;

		constructor();
	}

	declare class VcDvsForwardToDvportNetworkRuleAction
	{
		dvPortKey: String;
		option: String;

		constructor();
	}

	declare class VcDvsGreEncapNetworkRuleAction
	{
		encapsulationIp: VcSingleIp;

		constructor();
	}

	declare class VcDVSHealthCheckCapability
	{

		constructor();
	}

	declare class VcDVSHealthCheckConfig
	{
		enable: boolean;
		interval: Number;

		constructor();
	}

	declare class VcDvsHealthStatusChangeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsHostBackInSyncEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostBackInSync: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsHostInfrastructureTrafficResource
	{
		allocationInfo: VcDvsHostInfrastructureTrafficResourceAllocation;
		description: String;
		key: String;

		constructor();
	}

	declare class VcDvsHostInfrastructureTrafficResourceAllocation
	{
		limit: Number;
		reservation: Number;
		shares: VcSharesInfo;

		constructor();
	}

	declare class VcDvsHostJoinedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostJoined: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsHostLeftEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostLeft: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVSHostLocalPortInfo
	{
		portKey: String;
		setting: VcDVPortSetting;
		switchUuid: String;
		vnic: String;

		constructor();
	}

	declare class VcDvsHostStatusUpdated
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostMember: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newStatus: String;
		newStatusDetail: String;
		oldStatus: String;
		oldStatusDetail: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsHostVNicProfile
	{
		enabled: boolean;
		ipConfig: VcIpAddressProfile;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcDvsHostWentOutOfSyncEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostOutOfSync: VcDvsOutOfSyncHostArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsImportEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		importType: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVSIPDiscoveryConfig
	{
		inherited: boolean;
		ipDiscoveryEnabled: VcBoolPolicy;
		isTrusted: VcBoolPolicy;
		maxBindingDbSize: VcIntPolicy;
		staticIP: VcDVSStaticIPArray;

		constructor();
	}

	interface VcDVSIPDiscoveryMethod
	{
		readonly _arpSnooping: String;
		readonly _dhcpSnooping: String;
		readonly _staticIp: String;
		readonly _trustOnFirstUse: String;
		readonly arpSnooping: VcDVSIPDiscoveryMethod;
		readonly dhcpSnooping: VcDVSIPDiscoveryMethod;
		readonly id: String;
		readonly name: String;
		readonly staticIp: VcDVSIPDiscoveryMethod;
		readonly trustOnFirstUse: VcDVSIPDiscoveryMethod;
		readonly value: String;

		fromString(value?: String): VcDVSIPDiscoveryMethod;
	}

	interface VcDVSIPDiscoveryMethodConstructor {
		new(value?:any): VcDVSIPDiscoveryMethod;
		readonly prototype: VcDVSIPDiscoveryMethod;
	}

	declare const VcDVSIPDiscoveryMethod: VcDVSIPDiscoveryMethodConstructor;

	declare class VcDVSIPEntry
	{
		ipAddress: String;
		macAddress: String;
		vlanId: Number;

		constructor();
	}

	declare class VcDvsIpNetworkRuleQualifier
	{
		destinationAddress: VcIpAddress;
		destinationIpPort: VcDvsIpPort;
		key: String;
		protocol: VcIntExpression;
		sourceAddress: VcIpAddress;
		sourceIpPort: VcDvsIpPort;
		tcpFlags: VcIntExpression;
		tcpOptions: VcDvsTcpOptions[];

		constructor();
	}

	declare class VcDvsIpPort
	{
		negate: boolean;

		constructor();
	}

	declare class VcDvsIpPortRange
	{
		endPortNumber: Number;
		negate: boolean;
		startPortNumber: Number;

		constructor();
	}

	declare class VcDvsJumpNetworkRuleAction
	{
		option: String;
		ruleSetKey: String;

		constructor();
	}

	declare class VcDvsLogNetworkRuleAction
	{

		constructor();
	}

	declare class VcDvsMacNetworkRuleQualifier
	{
		destinationAddress: VcMacAddress;
		key: String;
		protocol: VcIntExpression;
		sourceAddress: VcMacAddress;
		vlanId: VcIntExpression;

		constructor();
	}

	declare class VcDvsMacRewriteNetworkRuleAction
	{
		rewriteMac: String;

		constructor();
	}

	declare class VcDVSManagerDvsConfigTarget
	{
		distributedVirtualPortgroup: VcDistributedVirtualPortgroupInfo[];
		distributedVirtualSwitch: VcDistributedVirtualSwitchInfo[];

		constructor();
	}

	declare class VcDvsMergedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destinationDvs: VcDvsEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDvs: VcDvsEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVSNameArrayUplinkPortPolicy
	{
		uplinkPortName: String[];

		constructor();
	}

	declare class VcDVSNetworkResourceManagementCapability
	{
		networkResourceControlVersion3Supported: boolean;
		networkResourceManagementSupported: boolean;
		networkResourcePoolHighShareValue: Number;
		qosSupported: boolean;
		userDefinedNetworkResourcePoolsSupported: boolean;

		constructor();
	}

	declare class VcDVSNetworkResourcePool
	{
		allocationInfo: VcDVSNetworkResourcePoolAllocationInfo;
		configVersion: String;
		description: String;
		key: String;
		name: String;

		constructor();
	}

	declare class VcDVSNetworkResourcePoolAllocationInfo
	{
		limit: Number;
		priorityTag: Number;
		shares: VcSharesInfo;

		constructor();
	}

	declare class VcDVSNetworkResourcePoolConfigSpec
	{
		allocationInfo: VcDVSNetworkResourcePoolAllocationInfo;
		configVersion: String;
		description: String;
		key: String;
		name: String;

		constructor();
	}

	declare class VcDvsNetworkRuleAction
	{

		constructor();
	}

	interface VcDvsNetworkRuleDirectionType
	{
		readonly _both: String;
		readonly _incomingPackets: String;
		readonly _outgoingPackets: String;
		readonly both: VcDvsNetworkRuleDirectionType;
		readonly id: String;
		readonly incomingPackets: VcDvsNetworkRuleDirectionType;
		readonly name: String;
		readonly outgoingPackets: VcDvsNetworkRuleDirectionType;
		readonly value: String;

		fromString(value?: String): VcDvsNetworkRuleDirectionType;
	}

	interface VcDvsNetworkRuleDirectionTypeConstructor {
		new(value?:any): VcDvsNetworkRuleDirectionType;
		readonly prototype: VcDvsNetworkRuleDirectionType;
	}

	declare const VcDvsNetworkRuleDirectionType: VcDvsNetworkRuleDirectionTypeConstructor;

	declare class VcDvsNetworkRuleQualifier
	{
		key: String;

		constructor();
	}

	interface VcDvsNetworkRuleRedirectActionOption
	{
		readonly _copy: String;
		readonly _log: String;
		readonly _none: String;
		readonly copy: VcDvsNetworkRuleRedirectActionOption;
		readonly id: String;
		readonly log: VcDvsNetworkRuleRedirectActionOption;
		readonly name: String;
		readonly none: VcDvsNetworkRuleRedirectActionOption;
		readonly value: String;

		fromString(value?: String): VcDvsNetworkRuleRedirectActionOption;
	}

	interface VcDvsNetworkRuleRedirectActionOptionConstructor {
		new(value?:any): VcDvsNetworkRuleRedirectActionOption;
		readonly prototype: VcDvsNetworkRuleRedirectActionOption;
	}

	declare const VcDvsNetworkRuleRedirectActionOption: VcDvsNetworkRuleRedirectActionOptionConstructor;

	declare class VcDvsOperationBulkFaultFaultOnHost
	{
		fault: VcLocalizedMethodFault;
		host: VcHostSystem;

		constructor();
	}

	declare class VcDvsOutOfSyncHostArgument
	{
		configParamters: String[];
		outOfSyncHost: VcHostEventArgument;

		constructor();
	}

	declare class VcDVSOverlayClassConfigInfo
	{
		name: String;
		type: String;

		constructor();
	}

	declare class VcDVSOverlayInstanceConfigInfo
	{
		depth: Number;
		key: String;
		overlayClassName: String;

		constructor();
	}

	declare class VcDVSOverlayInstanceConfigSpec
	{
		depth: Number;
		key: String;
		operation: String;
		overlayClassName: String;

		constructor();
	}

	declare class VcDVSoverlayParameterPolicy
	{
		inherited: boolean;
		keyValue: VcDVPortOverlayParameter[];

		constructor();
	}

	declare class VcDVSPolicy
	{
		autoPreInstallAllowed: boolean;
		autoUpgradeAllowed: boolean;
		partialUpgradeAllowed: boolean;

		constructor();
	}

	declare class VcDvsPortBlockedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		statusDetail: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortConnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		connectee: VcDistributedVirtualSwitchPortConnectee;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVSPortDbClearSpec
	{
		entriesToRemove: VcDVSIPEntry[];

		constructor();
	}

	declare class VcDVSPortDbEntry
	{
		dhcpLeaseRemaining: Number;
		discoveryMethod: String;
		entry: VcDVSIPEntry;

		constructor();
	}

	declare class VcDVSPortDbQueryResults
	{
		dbEntries: VcDVSPortDbEntry[];

		constructor();
	}

	declare class VcDvsPortDeletedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortDisconnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		connectee: VcDistributedVirtualSwitchPortConnectee;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortEnteredPassthruEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortExitedPassthruEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortJoinPortgroupEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portgroupKey: String;
		portgroupName: String;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortLeavePortgroupEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portgroupKey: String;
		portgroupName: String;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortLinkDownEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortLinkUpEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortRuntimeChangeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortUnblockedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		runtimeInfo: VcDVPortStatus;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsPortVendorSpecificStateChangeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsProfile
	{
		enabled: boolean;
		key: String;
		name: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		uplink: VcPnicUplinkProfile[];

		constructor();
	}

	declare class VcDvsPuntNetworkRuleAction
	{

		constructor();
	}

	declare class VcDvsRateLimitNetworkRuleAction
	{
		packetsPerSecond: Number;

		constructor();
	}

	declare class VcDvsReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configSpec: VcDVSConfigSpec;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsResourceRuntimeInfo
	{
		allocatedResource: VcDvsVnicAllocatedResource[];
		available: Number;
		capacity: Number;
		usage: Number;
		vmVnicNetworkResourcePoolRuntime: VcDvsVmVnicNetworkResourcePoolRuntimeInfo[];

		constructor();
	}

	declare class VcDvsRestoreEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVSRollbackCapability
	{
		rollbackSupported: boolean;

		constructor();
	}

	declare class VcDVSRuntimeInfo
	{
		hostMemberRuntime: VcHostMemberRuntimeInfo[];
		resourceRuntimeInfo: VcDvsResourceRuntimeInfo;

		constructor();
	}

	declare class VcDVSSecurityPolicy
	{
		allowPromiscuous: VcBoolPolicy;
		forgedTransmits: VcBoolPolicy;
		inherited: boolean;
		macChanges: VcBoolPolicy;

		constructor();
	}

	declare class VcDVSSelection
	{
		dvsUuid: String;

		constructor();
	}

	declare class VcDvsServiceConsoleVNicProfile
	{
		enabled: boolean;
		ipConfig: VcIpAddressProfile;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcDvsSingleIpPort
	{
		negate: boolean;
		portNumber: Number;

		constructor();
	}

	declare class VcDvsStatefulFirewallFeatureCapability
	{
		rulesetSupported: boolean;

		constructor();
	}

	declare class VcDvsStatefulFirewallPolicy
	{
		inherited: boolean;
		masterSet: VcDvsTrafficRuleset;
		supplementSet: VcDvsTrafficRuleset[];

		constructor();
	}

	declare class VcDVSStaticIPArray
	{
		inherited: boolean;
		ipEntries: VcDVSIPEntry[];

		constructor();
	}

	declare class VcDVSSummary
	{
		contact: VcDVSContactInfo;
		description: String;
		host: VcHostSystem[];
		hostMember: VcHostSystem[];
		name: String;
		numHosts: Number;
		numPorts: Number;
		portgroupName: String[];
		productInfo: VcDistributedVirtualSwitchProductSpec;
		uuid: String;
		vm: VcVirtualMachine[];

		constructor();
	}

	declare class VcDVSSwitchSecurityConfig
	{
		bpduFilterEnabled: VcBoolPolicy;
		dhcpServerBlockEnabled: VcBoolPolicy;
		dynamicArpInspectionConfig: VcDVSDynamicArpInspectionConfig;
		inherited: boolean;
		ipDiscoveryConfig: VcDVSIPDiscoveryConfig;
		ipSrcGuardEnabled: VcBoolPolicy;

		constructor();
	}

	declare class VcDVSSwitchSecurityFeatureCapability
	{
		bpduFilterSupported: boolean;
		dhcpServerBlockSupported: boolean;
		dynamicArpInspectionSupported: boolean;
		ipDiscoverySupported: boolean;
		ipSrcGuardSupported: boolean;

		constructor();
	}

	declare class VcDvsSystemTrafficNetworkRuleQualifier
	{
		key: String;
		typeOfSystemTraffic: VcStringExpression;

		constructor();
	}

	declare class VcDvsTcpOptions
	{
		length: Number;
		negate: boolean;
		type: Number;
		value: String;

		constructor();
	}

	declare class VcDvsTrafficFilterConfig
	{
		agentName: String;
		inherited: boolean;
		key: String;
		onFailure: String;
		parameters: VcDvsFilterParameter;
		slotNumber: String;
		trafficRuleset: VcDvsTrafficRuleset;

		constructor();
	}

	declare class VcDvsTrafficFilterConfigSpec
	{
		agentName: String;
		inherited: boolean;
		key: String;
		onFailure: String;
		operation: String;
		parameters: VcDvsFilterParameter;
		slotNumber: String;
		trafficRuleset: VcDvsTrafficRuleset;

		constructor();
	}

	declare class VcDvsTrafficRule
	{
		action: VcDvsNetworkRuleAction;
		description: String;
		direction: String;
		key: String;
		qualifier: VcDvsNetworkRuleQualifier[];
		sequence: Number;

		constructor();
	}

	declare class VcDvsTrafficRuleset
	{
		enabled: boolean;
		key: String;
		precedence: Number;
		rules: VcDvsTrafficRule[];

		constructor();
	}

	declare class VcDVSTrafficShapingPolicy
	{
		averageBandwidth: VcLongPolicy;
		burstSize: VcLongPolicy;
		enabled: VcBoolPolicy;
		inherited: boolean;
		peakBandwidth: VcLongPolicy;

		constructor();
	}

	declare class VcDvsUpdateTagNetworkRuleAction
	{
		dscpTag: Number;
		qosTag: Number;

		constructor();
	}

	declare class VcDvsUpgradeAvailableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsUpgradedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsUpgradeInProgressEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDvsUpgradeRejectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcDVSUplinkPortPolicy
	{

		constructor();
	}

	declare class VcDVSVendorSpecificConfig
	{
		inherited: boolean;
		keyValue: VcDistributedVirtualSwitchKeyedOpaqueBlob[];

		constructor();
	}

	declare class VcDVSVmVnicNetworkResourcePool
	{
		allocationInfo: VcDvsVmVnicResourceAllocation;
		configVersion: String;
		description: String;
		key: String;
		name: String;

		constructor();
	}

	declare class VcDvsVmVnicNetworkResourcePoolRuntimeInfo
	{
		allocatedResource: VcDvsVnicAllocatedResource[];
		available: Number;
		capacity: Number;
		key: String;
		name: String;
		status: String;
		usage: Number;

		constructor();
	}

	declare class VcDvsVmVnicResourceAllocation
	{
		reservationQuota: Number;

		constructor();
	}

	declare class VcDvsVmVnicResourcePoolConfigSpec
	{
		allocationInfo: VcDvsVmVnicResourceAllocation;
		configVersion: String;
		description: String;
		key: String;
		name: String;
		operation: String;

		constructor();
	}

	declare class VcDvsVnicAllocatedResource
	{
		reservation: Number;
		vm: VcVirtualMachine;
		vnicKey: String;

		constructor();
	}

	declare class VcDvsVNicProfile
	{
		enabled: boolean;
		ipConfig: VcIpAddressProfile;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcDynamicArray
	{
		val: Object;
		val_FloatValue: Number;
		val_IntValue: Number;
		val_LongValue: Number;

		constructor();
	}

	declare class VcDynamicData
	{

		constructor();
	}

	declare class VcDynamicProperty
	{
		name: String;
		val: Object;
		val_FloatValue: Number;
		val_IntValue: Number;
		val_LongValue: Number;

		constructor();
	}

	declare class VcElementDescription
	{
		key: String;
		label: String;
		summary: String;

		constructor();
	}

	declare class VcEnteredMaintenanceModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcEnteredStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcEnteringMaintenanceModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcEnteringStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcEntityBackup
	{

		constructor();
	}

	declare class VcEntityBackupConfig
	{
		configBlob: base64Binary;
		configVersion: String;
		container: VcManagedEntity;
		entityType: String;
		key: String;
		name: String;

		constructor();
	}

	declare class VcEntityEventArgument
	{
		name: String;

		constructor();
	}

	interface VcEntityImportType
	{
		readonly _applyToEntitySpecified: String;
		readonly _createEntityWithNewIdentifier: String;
		readonly _createEntityWithOriginalIdentifier: String;
		readonly applyToEntitySpecified: VcEntityImportType;
		readonly createEntityWithNewIdentifier: VcEntityImportType;
		readonly createEntityWithOriginalIdentifier: VcEntityImportType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcEntityImportType;
	}

	interface VcEntityImportTypeConstructor {
		new(value?:any): VcEntityImportType;
		readonly prototype: VcEntityImportType;
	}

	declare const VcEntityImportType: VcEntityImportTypeConstructor;

	declare class VcEntityPrivilege
	{
		entity: VcManagedEntity;
		privAvailability: VcPrivilegeAvailability[];

		constructor();
	}

	interface VcEntityType
	{
		readonly _distributedVirtualPortgroup: String;
		readonly _distributedVirtualSwitch: String;
		readonly distributedVirtualPortgroup: VcEntityType;
		readonly distributedVirtualSwitch: VcEntityType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcEntityType;
	}

	interface VcEntityTypeConstructor {
		new(value?:any): VcEntityType;
		readonly prototype: VcEntityType;
	}

	declare const VcEntityType: VcEntityTypeConstructor;

	declare class VcEnumDescription
	{
		key: String;
		tags: VcElementDescription[];

		constructor();
	}

	interface VcEnvironmentBrowser
	{
		datastoreBrowser: VcHostDatastoreBrowser;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryConfigOption(key?: String, host?: VcHostSystem): VcVirtualMachineConfigOption;
		queryConfigOptionDescriptor(): VcVirtualMachineConfigOptionDescriptor[];
		queryConfigOptionEx(spec?: VcEnvironmentBrowserConfigOptionQuerySpec): VcVirtualMachineConfigOption;
		queryConfigTarget(host?: VcHostSystem): VcConfigTarget;
		queryTargetCapabilities(host?: VcHostSystem): VcHostCapability;
	}

	declare const VcEnvironmentBrowser: VcEnvironmentBrowser;

	declare class VcEnvironmentBrowserConfigOptionQuerySpec
	{
		guestId: String[];
		host: VcHostSystem;
		key: String;

		constructor();
	}

	declare class VcErrorUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcEvaluationLicenseSource
	{
		remainingHours: Number;

		constructor();
	}

	declare class VcEVCMode
	{
		featureCapability: VcHostFeatureCapability[];
		featureMask: VcHostFeatureMask[];
		featureRequirement: VcVirtualMachineFeatureRequirement[];
		guaranteedCPUFeatures: VcHostCpuIdInfo[];
		key: String;
		label: String;
		summary: String;
		track: String[];
		vendor: String;
		vendorTier: Number;

		constructor();
	}

	declare class VcEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcEventAlarmExpression
	{
		comparisons: VcEventAlarmExpressionComparison[];
		eventType: String;
		eventTypeId: String;
		objectType: String;
		status: VcManagedEntityStatus;

		constructor();
	}

	declare class VcEventAlarmExpressionComparison
	{
		attributeName: String;
		operator: String;
		value: String;

		constructor();
	}

	interface VcEventAlarmExpressionComparisonOperator
	{
		readonly _doesNotEndWith: String;
		readonly _doesNotStartWith: String;
		readonly _endsWith: String;
		readonly _equals: String;
		readonly _notEqualTo: String;
		readonly _startsWith: String;
		readonly doesNotEndWith: VcEventAlarmExpressionComparisonOperator;
		readonly doesNotStartWith: VcEventAlarmExpressionComparisonOperator;
		readonly endsWith: VcEventAlarmExpressionComparisonOperator;
		readonly equals: VcEventAlarmExpressionComparisonOperator;
		readonly id: String;
		readonly name: String;
		readonly notEqualTo: VcEventAlarmExpressionComparisonOperator;
		readonly startsWith: VcEventAlarmExpressionComparisonOperator;
		readonly value: String;

		fromString(value?: String): VcEventAlarmExpressionComparisonOperator;
	}

	interface VcEventAlarmExpressionComparisonOperatorConstructor {
		new(value?:any): VcEventAlarmExpressionComparisonOperator;
		readonly prototype: VcEventAlarmExpressionComparisonOperator;
	}

	declare const VcEventAlarmExpressionComparisonOperator: VcEventAlarmExpressionComparisonOperatorConstructor;

	declare class VcEventArgDesc
	{
		array: boolean;
		description: VcElementDescription;
		eventObject: boolean;
		name: String;
		type: String;

		constructor();
	}

	declare class VcEventArgument
	{

		constructor();
	}

	interface VcEventCategory
	{
		readonly _error: String;
		readonly _info: String;
		readonly _user: String;
		readonly _warning: String;
		readonly error: VcEventCategory;
		readonly id: String;
		readonly info: VcEventCategory;
		readonly name: String;
		readonly user: VcEventCategory;
		readonly value: String;
		readonly warning: VcEventCategory;

		fromString(value?: String): VcEventCategory;
	}

	interface VcEventCategoryConstructor {
		new(value?:any): VcEventCategory;
		readonly prototype: VcEventCategory;
	}

	declare const VcEventCategory: VcEventCategoryConstructor;

	declare class VcEventDescription
	{
		category: VcElementDescription[];
		enumeratedTypes: VcEnumDescription[];
		eventInfo: VcEventDescriptionEventDetail[];

		constructor();
	}

	declare class VcEventDescriptionEventDetail
	{
		category: String;
		description: String;
		formatOnComputeResource: String;
		formatOnDatacenter: String;
		formatOnHost: String;
		formatOnVm: String;
		fullFormat: String;
		key: String;
		longDescription: String;

		constructor();
	}

	interface VcEventEventSeverity
	{
		readonly _error: String;
		readonly _info: String;
		readonly _user: String;
		readonly _warning: String;
		readonly error: VcEventEventSeverity;
		readonly id: String;
		readonly info: VcEventEventSeverity;
		readonly name: String;
		readonly user: VcEventEventSeverity;
		readonly value: String;
		readonly warning: VcEventEventSeverity;

		fromString(value?: String): VcEventEventSeverity;
	}

	interface VcEventEventSeverityConstructor {
		new(value?:any): VcEventEventSeverity;
		readonly prototype: VcEventEventSeverity;
	}

	declare const VcEventEventSeverity: VcEventEventSeverityConstructor;

	declare class VcEventEx
	{
		arguments: VcKeyAnyValue[];
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		eventTypeId: String;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		objectId: String;
		objectName: String;
		objectType: String;
		severity: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcEventFilterSpec
	{
		alarm: VcAlarm;
		category: String[];
		disableFullMessage: boolean;
		entity: VcEventFilterSpecByEntity;
		eventChainId: Number;
		eventTypeId: String[];
		scheduledTask: VcScheduledTask;
		tag: String[];
		time: VcEventFilterSpecByTime;
		type: String[];
		userName: VcEventFilterSpecByUsername;

		constructor();
	}

	declare class VcEventFilterSpecByEntity
	{
		entity: VcManagedEntity;
		recursion: VcEventFilterSpecRecursionOption;

		constructor();
	}

	declare class VcEventFilterSpecByTime
	{
		beginTime: Date;
		endTime: Date;

		constructor();
	}

	declare class VcEventFilterSpecByUsername
	{
		systemUser: boolean;
		userList: String[];

		constructor();
	}

	interface VcEventFilterSpecRecursionOption
	{
		readonly _all: String;
		readonly _children: String;
		readonly _self: String;
		readonly all: VcEventFilterSpecRecursionOption;
		readonly children: VcEventFilterSpecRecursionOption;
		readonly id: String;
		readonly name: String;
		readonly self: VcEventFilterSpecRecursionOption;
		readonly value: String;

		fromString(value?: String): VcEventFilterSpecRecursionOption;
	}

	interface VcEventFilterSpecRecursionOptionConstructor {
		new(value?:any): VcEventFilterSpecRecursionOption;
		readonly prototype: VcEventFilterSpecRecursionOption;
	}

	declare const VcEventFilterSpecRecursionOption: VcEventFilterSpecRecursionOptionConstructor;

	interface VcEventHistoryCollector
	{
		filter: Object;
		readonly id: String;
		latestPage: VcEvent[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyCollector(): void;
		readNextEvents(maxCount?: Number): VcEvent[];
		readPreviousEvents(maxCount?: Number): VcEvent[];
		resetCollector(): void;
		rewindCollector(): void;
		setCollectorPageSize(maxCount?: Number): void;
	}

	declare const VcEventHistoryCollector: VcEventHistoryCollector;

	interface VcEventManager
	{
		description: VcEventDescription;
		readonly id: String;
		latestEvent: VcEvent;
		maxCollector: Number;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createCollectorForEvents(filter?: VcEventFilterSpec): VcEventHistoryCollector;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		logUserEvent(entity?: VcManagedEntity, msg?: String): void;
		postEvent(eventToPost?: VcEvent, taskInfo?: VcTaskInfo): void;
		queryEvents(filter?: VcEventFilterSpec): VcEvent[];
		retrieveArgumentDescription(eventTypeId?: String): VcEventArgDesc[];
	}

	declare const VcEventManager: VcEventManager;

	declare class VcExitedStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcExitingStandbyModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcExitMaintenanceModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcExitStandbyModeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcExtendedDescription
	{
		label: String;
		messageArg: VcKeyAnyValue[];
		messageCatalogKeyPrefix: String;
		summary: String;

		constructor();
	}

	declare class VcExtendedElementDescription
	{
		key: String;
		label: String;
		messageArg: VcKeyAnyValue[];
		messageCatalogKeyPrefix: String;
		summary: String;

		constructor();
	}

	declare class VcExtendedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		data: VcExtendedEventPair[];
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		eventTypeId: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		managedObject: VcManagedObjectReference;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcExtendedEventPair
	{
		key: String;
		value: String;

		constructor();
	}

	declare class VcExtension
	{
		client: VcExtensionClientInfo[];
		company: String;
		description: VcDescription;
		eventList: VcExtensionEventTypeInfo[];
		extendedProductInfo: VcExtExtendedProductInfo;
		faultList: VcExtensionFaultTypeInfo[];
		healthInfo: VcExtensionHealthInfo;
		key: String;
		lastHeartbeatTime: Date;
		managedEntityInfo: VcExtManagedEntityInfo[];
		ovfConsumerInfo: VcExtensionOvfConsumerInfo;
		privilegeList: VcExtensionPrivilegeInfo[];
		resourceList: VcExtensionResourceInfo[];
		server: VcExtensionServerInfo[];
		shownInSolutionManager: boolean;
		solutionManagerInfo: VcExtSolutionManagerInfo;
		subjectName: String;
		taskList: VcExtensionTaskTypeInfo[];
		type: String;
		version: String;

		constructor();
	}

	declare class VcExtensionClientInfo
	{
		company: String;
		description: VcDescription;
		type: String;
		url: String;
		version: String;

		constructor();
	}

	declare class VcExtensionEventTypeInfo
	{
		eventID: String;
		eventTypeSchema: String;

		constructor();
	}

	declare class VcExtensionFaultTypeInfo
	{
		faultID: String;

		constructor();
	}

	declare class VcExtensionHealthInfo
	{
		url: String;

		constructor();
	}

	interface VcExtensionManager
	{
		extensionList: VcExtension[];
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		findExtension(extensionKey?: String): VcExtension;
		getPublicKey(): String;
		queryExtensionIpAllocationUsage(extensionKeys?: String[]): VcExtensionManagerIpAllocationUsage[];
		queryManagedBy(extensionKey?: String): VcManagedEntity[];
		registerExtension(extension?: VcExtension): void;
		setExtensionCertificate(extensionKey?: String, certificatePem?: String): void;
		setPublicKey(extensionKey?: String, publicKey?: String): void;
		unregisterExtension(extensionKey?: String): void;
		updateExtension(extension?: VcExtension): void;
	}

	declare const VcExtensionManager: VcExtensionManager;

	declare class VcExtensionManagerIpAllocationUsage
	{
		extensionKey: String;
		numAddresses: Number;

		constructor();
	}

	declare class VcExtensionOvfConsumerInfo
	{
		callbackUrl: String;
		sectionType: String[];

		constructor();
	}

	declare class VcExtensionPrivilegeInfo
	{
		privGroupName: String;
		privID: String;

		constructor();
	}

	declare class VcExtensionResourceInfo
	{
		data: VcKeyValue[];
		locale: String;
		module: String;

		constructor();
	}

	declare class VcExtensionServerInfo
	{
		adminEmail: String[];
		company: String;
		description: VcDescription;
		serverThumbprint: String;
		type: String;
		url: String;

		constructor();
	}

	declare class VcExtensionTaskTypeInfo
	{
		taskID: String;

		constructor();
	}

	declare class VcExtExtendedProductInfo
	{
		companyUrl: String;
		managementUrl: String;
		productUrl: String;
		self: VcManagedEntity;

		constructor();
	}

	declare class VcExtManagedEntityInfo
	{
		description: String;
		iconUrl: String;
		smallIconUrl: String;
		type: String;

		constructor();
	}

	declare class VcExtSolutionManagerInfo
	{
		smallIconUrl: String;
		tab: VcExtSolutionManagerInfoTabInfo[];

		constructor();
	}

	declare class VcExtSolutionManagerInfoTabInfo
	{
		label: String;
		url: String;

		constructor();
	}

	declare class VcFailoverLevelRestored
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcFaultToleranceConfigInfo
	{
		configPaths: String[];
		instanceUuids: String[];
		orphaned: boolean;
		role: Number;

		constructor();
	}

	declare class VcFaultToleranceConfigSpec
	{
		metaDataPath: VcFaultToleranceMetaSpec;
		secondaryVmSpec: VcFaultToleranceVMConfigSpec;

		constructor();
	}

	declare class VcFaultToleranceDiskSpec
	{
		datastore: VcDatastore;
		disk: VcVirtualDevice;

		constructor();
	}

	declare class VcFaultToleranceMetaSpec
	{
		metaDataDatastore: VcDatastore;

		constructor();
	}

	declare class VcFaultTolerancePrimaryConfigInfo
	{
		configPaths: String[];
		instanceUuids: String[];
		orphaned: boolean;
		role: Number;
		secondaries: VcVirtualMachine[];

		constructor();
	}

	declare class VcFaultToleranceSecondaryConfigInfo
	{
		configPaths: String[];
		instanceUuids: String[];
		orphaned: boolean;
		primaryVM: VcVirtualMachine;
		role: Number;

		constructor();
	}

	declare class VcFaultToleranceSecondaryOpResult
	{
		powerOnAttempted: boolean;
		powerOnResult: VcClusterPowerOnVmResult;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcFaultToleranceVMConfigSpec
	{
		disks: VcFaultToleranceDiskSpec[];
		vmConfig: VcDatastore;

		constructor();
	}

	declare class VcFcoeConfig
	{
		capabilities: VcFcoeConfigFcoeCapabilities;
		fcoeActive: boolean;
		priorityClass: Number;
		sourceMac: String;
		vlanRange: VcFcoeConfigVlanRange[];

		constructor();
	}

	declare class VcFcoeConfigFcoeCapabilities
	{
		priorityClass: boolean;
		sourceMacAddress: boolean;
		vlanRange: boolean;

		constructor();
	}

	declare class VcFcoeConfigFcoeSpecification
	{
		priorityClass: Number;
		sourceMac: String;
		underlyingPnic: String;
		vlanRange: VcFcoeConfigVlanRange[];

		constructor();
	}

	declare class VcFcoeConfigVlanRange
	{
		vlanHigh: Number;
		vlanLow: Number;

		constructor();
	}

	interface VcFibreChannelPortType
	{
		readonly _fabric: String;
		readonly _loop: String;
		readonly _pointToPoint: String;
		readonly _unknown: String;
		readonly fabric: VcFibreChannelPortType;
		readonly id: String;
		readonly loop: VcFibreChannelPortType;
		readonly name: String;
		readonly pointToPoint: VcFibreChannelPortType;
		readonly unknown: VcFibreChannelPortType;
		readonly value: String;

		fromString(value?: String): VcFibreChannelPortType;
	}

	interface VcFibreChannelPortTypeConstructor {
		new(value?:any): VcFibreChannelPortType;
		readonly prototype: VcFibreChannelPortType;
	}

	declare const VcFibreChannelPortType: VcFibreChannelPortTypeConstructor;

	declare class VcFileBackedVirtualDiskSpec
	{
		adapterType: String;
		capacityKb: Number;
		diskType: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
	}

	declare class VcFileInfo
	{
		fileSize: Number;
		modification: Date;
		owner: String;
		path: String;

		constructor();
	}

	interface VcFileManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		changeOwner(name?: String, datacenter?: VcDatacenter, owner?: String): void;
		copyDatastoreFile_Task(sourceName?: String, sourceDatacenter?: VcDatacenter, destinationName?: String, destinationDatacenter?: VcDatacenter, force?: boolean): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteDatastoreFile_Task(name?: String, datacenter?: VcDatacenter): VcTask;
		makeDirectory(name?: String, datacenter?: VcDatacenter, createParentDirectories?: boolean): void;
		moveDatastoreFile_Task(sourceName?: String, sourceDatacenter?: VcDatacenter, destinationName?: String, destinationDatacenter?: VcDatacenter, force?: boolean): VcTask;
		uploadFileToDatastore(datacenter?: VcDatacenter, datastore?: VcDatastore, srcFilePath?: String, destFilePath?: String): boolean;
	}

	declare const VcFileManager: VcFileManager;

	declare class VcFileQuery
	{

		constructor();
	}

	declare class VcFileQueryFlags
	{
		fileOwner: boolean;
		fileSize: boolean;
		fileType: boolean;
		modification: boolean;

		constructor();
	}

	interface VcFileSystemMountInfoVStorageSupportStatus
	{
		readonly _vStorageSupported: String;
		readonly _vStorageUnknown: String;
		readonly _vStorageUnsupported: String;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vStorageSupported: VcFileSystemMountInfoVStorageSupportStatus;
		readonly vStorageUnknown: VcFileSystemMountInfoVStorageSupportStatus;
		readonly vStorageUnsupported: VcFileSystemMountInfoVStorageSupportStatus;

		fromString(value?: String): VcFileSystemMountInfoVStorageSupportStatus;
	}

	interface VcFileSystemMountInfoVStorageSupportStatusConstructor {
		new(value?:any): VcFileSystemMountInfoVStorageSupportStatus;
		readonly prototype: VcFileSystemMountInfoVStorageSupportStatus;
	}

	declare const VcFileSystemMountInfoVStorageSupportStatus: VcFileSystemMountInfoVStorageSupportStatusConstructor;

	declare class VcFileTransferInformation
	{
		attributes: VcGuestFileAttributes;
		size: Number;
		url: String;

		constructor();
	}

	declare class VcFirewallProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		ruleset: VcFirewallProfileRulesetProfile[];

		constructor();
	}

	declare class VcFirewallProfileRulesetProfile
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcFloatOption
	{
		defaultValue: Number;
		max: Number;
		min: Number;
		valueIsReadonly: boolean;

		constructor();
	}

	declare class VcFloppyImageFileInfo
	{
		fileSize: Number;
		modification: Date;
		owner: String;
		path: String;

		constructor();
	}

	declare class VcFloppyImageFileQuery
	{

		constructor();
	}

	interface VcFolder
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		childEntity: VcManagedEntity[];
		childType: String[];
		readonly clusterComputeResource: ClusterComputeResource[];
		readonly computeResource: ComputeResource[];
		readonly computeResource_ClusterComputeResource: ClusterComputeResource[];
		readonly computeResource_ComputeResource: ComputeResource[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		readonly distributedVirtualSwitch_DistributedVirtualSwitch: DistributedVirtualSwitch[];
		readonly distributedVirtualSwitch_VmwareDistributedVirtualSwitch: VmwareDistributedVirtualSwitch[];
		effectiveRole: Number[];
		readonly id: String;
		name: String;
		readonly network_DistributedVirtualPortgroup: DistributedVirtualPortgroup[];
		readonly network_Network: Network[];
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		readonly resourcePool_VirtualApp: VirtualApp[];
		readonly sdkConnection: VcSdkConnection;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addStandaloneHost_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		createCluster(name?: String, spec?: VcClusterConfigSpec): VcClusterComputeResource;
		createClusterEx(name?: String, spec?: VcClusterConfigSpecEx): VcClusterComputeResource;
		createDatacenter(name?: String): VcDatacenter;
		createDVS_Task(spec?: VcDVSCreateSpec): VcTask;
		createFolder(name?: String): VcFolder;
		createStoragePod(name?: String): VcStoragePod;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVM_Task(config?: VcVirtualMachineConfigSpec, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		destroy_Task(): VcTask;
		moveIntoFolder_Task(list?: VcManagedEntity[]): VcTask;
		registerVM_Task(path?: String, name?: String, asTemplate?: boolean, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
		unregisterAndDestroy_Task(): VcTask;
	}

	declare const VcFolder: VcFolder;

	declare class VcFolderEventArgument
	{
		folder: VcFolder;
		name: String;

		constructor();
	}

	declare class VcFolderFileInfo
	{
		fileSize: Number;
		modification: Date;
		owner: String;
		path: String;

		constructor();
	}

	declare class VcFolderFileQuery
	{

		constructor();
	}

	interface VcFtIssuesOnHostHostSelectionType
	{
		readonly _drs: String;
		readonly _user: String;
		readonly _vc: String;
		readonly drs: VcFtIssuesOnHostHostSelectionType;
		readonly id: String;
		readonly name: String;
		readonly user: VcFtIssuesOnHostHostSelectionType;
		readonly value: String;
		readonly vc: VcFtIssuesOnHostHostSelectionType;

		fromString(value?: String): VcFtIssuesOnHostHostSelectionType;
	}

	interface VcFtIssuesOnHostHostSelectionTypeConstructor {
		new(value?:any): VcFtIssuesOnHostHostSelectionType;
		readonly prototype: VcFtIssuesOnHostHostSelectionType;
	}

	declare const VcFtIssuesOnHostHostSelectionType: VcFtIssuesOnHostHostSelectionTypeConstructor;

	declare class VcGeneralEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGeneralHostErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGeneralHostInfoEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGeneralHostWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGeneralUserEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGeneralVmErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGeneralVmInfoEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGeneralVmWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGhostDvsProxySwitchDetectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGhostDvsProxySwitchRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGlobalMessageChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcGroupAlarmAction
	{
		action: VcAlarmAction[];

		constructor();
	}

	declare class VcGuestAliases
	{
		aliases: VcGuestAuthAliasInfo[];
		base64Cert: String;

		constructor();
	}

	interface VcGuestAliasManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addGuestAlias(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, username?: String, mapCert?: boolean, base64Cert?: String, aliasInfo?: VcGuestAuthAliasInfo): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		listGuestAliases(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, username?: String): VcGuestAliases[];
		listGuestMappedAliases(vm?: VcVirtualMachine, auth?: VcGuestAuthentication): VcGuestMappedAliases[];
		removeGuestAlias(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, username?: String, base64Cert?: String, subject?: VcGuestAuthSubject): void;
		removeGuestAliasByCert(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, username?: String, base64Cert?: String): void;
	}

	declare const VcGuestAliasManager: VcGuestAliasManager;

	declare class VcGuestAuthAliasInfo
	{
		comment: String;
		subject: VcGuestAuthSubject;

		constructor();
	}

	declare class VcGuestAuthAnySubject
	{

		constructor();
	}

	declare class VcGuestAuthentication
	{
		interactiveSession: boolean;

		constructor();
	}

	interface VcGuestAuthManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		acquireCredentialsInGuest(vm?: VcVirtualMachine, requestedAuth?: VcGuestAuthentication, sessionID?: Number): VcGuestAuthentication;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		releaseCredentialsInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication): void;
		validateCredentialsInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication): void;
	}

	declare const VcGuestAuthManager: VcGuestAuthManager;

	declare class VcGuestAuthNamedSubject
	{
		name: String;

		constructor();
	}

	declare class VcGuestAuthSubject
	{

		constructor();
	}

	declare class VcGuestDiskInfo
	{
		capacity: Number;
		diskPath: String;
		freeSpace: Number;

		constructor();
	}

	declare class VcGuestFileAttributes
	{
		accessTime: Date;
		modificationTime: Date;
		symlinkTarget: String;

		constructor();
	}

	declare class VcGuestFileInfo
	{
		attributes: VcGuestFileAttributes;
		path: String;
		size: Number;
		type: String;

		constructor();
	}

	interface VcGuestFileManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		changeFileAttributesInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, guestFilePath?: String, fileAttributes?: VcGuestFileAttributes): void;
		createTemporaryDirectoryInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, prefix?: String, suffix?: String, directoryPath?: String): String;
		createTemporaryFileInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, prefix?: String, suffix?: String, directoryPath?: String): String;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteDirectoryInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, directoryPath?: String, recursive?: boolean): void;
		deleteFileInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, filePath?: String): void;
		downloadFile(vcoPath?: String, ftInfo?: VcFileTransferInformation): boolean;
		initiateFileTransferFromGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, guestFilePath?: String): VcFileTransferInformation;
		initiateFileTransferToGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, guestFilePath?: String, fileAttributes?: VcGuestFileAttributes, fileSize?: Number, overwrite?: boolean): String;
		listFilesInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, filePath?: String, index?: Number, maxResults?: Number, matchPattern?: String): VcGuestListFileInfo;
		makeDirectoryInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, directoryPath?: String, createParentDirectories?: boolean): void;
		moveDirectoryInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, srcDirectoryPath?: String, dstDirectoryPath?: String): void;
		moveFileInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, srcFilePath?: String, dstFilePath?: String, overwrite?: boolean): void;
		putFile(vcoPath?: String, uri?: String): boolean;
	}

	declare const VcGuestFileManager: VcGuestFileManager;

	interface VcGuestFileType
	{
		readonly _directory: String;
		readonly _file: String;
		readonly _symlink: String;
		readonly directory: VcGuestFileType;
		readonly file: VcGuestFileType;
		readonly id: String;
		readonly name: String;
		readonly symlink: VcGuestFileType;
		readonly value: String;

		fromString(value?: String): VcGuestFileType;
	}

	interface VcGuestFileTypeConstructor {
		new(value?:any): VcGuestFileType;
		readonly prototype: VcGuestFileType;
	}

	declare const VcGuestFileType: VcGuestFileTypeConstructor;

	declare class VcGuestInfo
	{
		appHeartbeatStatus: String;
		appState: String;
		disk: VcGuestDiskInfo[];
		generationInfo: VcGuestInfoNamespaceGenerationInfo[];
		guestFamily: String;
		guestFullName: String;
		guestId: String;
		guestKernelCrashed: boolean;
		guestOperationsReady: boolean;
		guestState: String;
		guestStateChangeSupported: boolean;
		hostName: String;
		interactiveGuestOperationsReady: boolean;
		ipAddress: String;
		ipStack: VcGuestStackInfo[];
		net: VcGuestNicInfo[];
		powerPolicy: VcVirtualMachinePowerPolicy;
		screen: VcGuestScreenInfo;
		toolsRunningStatus: String;
		toolsStatus: VcVirtualMachineToolsStatus;
		toolsUpdateStatus: VcVirtualMachineToolsUpdateStatus;
		toolsVersion: String;
		toolsVersionStatus: String;
		toolsVersionStatus2: String;

		constructor();
	}

	interface VcGuestInfoAppStateType
	{
		readonly _appStateNeedReset: String;
		readonly _appStateOk: String;
		readonly _none: String;
		readonly appStateNeedReset: VcGuestInfoAppStateType;
		readonly appStateOk: VcGuestInfoAppStateType;
		readonly id: String;
		readonly name: String;
		readonly none: VcGuestInfoAppStateType;
		readonly value: String;

		fromString(value?: String): VcGuestInfoAppStateType;
	}

	interface VcGuestInfoAppStateTypeConstructor {
		new(value?:any): VcGuestInfoAppStateType;
		readonly prototype: VcGuestInfoAppStateType;
	}

	declare const VcGuestInfoAppStateType: VcGuestInfoAppStateTypeConstructor;

	declare class VcGuestInfoNamespaceGenerationInfo
	{
		generationNo: Number;
		key: String;

		constructor();
	}

	declare class VcGuestListFileInfo
	{
		files: VcGuestFileInfo[];
		remaining: Number;

		constructor();
	}

	declare class VcGuestMappedAliases
	{
		base64Cert: String;
		subjects: VcGuestAuthSubject[];
		username: String;

		constructor();
	}

	declare class VcGuestNicInfo
	{
		connected: boolean;
		deviceConfigId: Number;
		dnsConfig: VcNetDnsConfigInfo;
		ipAddress: String[];
		ipConfig: VcNetIpConfigInfo;
		macAddress: String;
		netBIOSConfig: VcNetBIOSConfigInfo;
		network: String;

		constructor();
	}

	interface VcGuestOperationsManager
	{
		aliasManager: VcGuestAliasManager;
		authManager: VcGuestAuthManager;
		fileManager: VcGuestFileManager;
		guestWindowsRegistryManager: VcGuestWindowsRegistryManager;
		readonly id: String;
		processManager: VcGuestProcessManager;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryGuestOperationsDisabledMethods(vm?: VcVirtualMachine): String[];
	}

	declare const VcGuestOperationsManager: VcGuestOperationsManager;

	declare class VcGuestOsDescriptor
	{
		cpuFeatureMask: VcHostCpuIdInfo[];
		diskUuidEnabled: boolean;
		family: String;
		fullName: String;
		ich7mRecommended: boolean;
		id: String;
		numSupportedCoresPerSocket: Number;
		numSupportedFloppyDevices: Number;
		numSupportedPhysicalSockets: Number;
		recommended3D: boolean;
		recommendedCdromController: String;
		recommendedColorDepth: Number;
		recommendedDiskController: String;
		recommendedDiskSizeMB: Number;
		recommendedEthernetCard: String;
		recommendedFirmware: String;
		recommendedMemMB: Number;
		recommendedSCSIController: String;
		recommendedUSBController: String;
		smcRecommended: boolean;
		smcRequired: boolean;
		supportedDiskControllerList: String[];
		supportedEthernetCard: String[];
		supportedFirmware: String[];
		supportedForCreate: boolean;
		supportedMaxCPUs: Number;
		supportedMaxMemMB: Number;
		supportedMinMemMB: Number;
		supportedNumDisks: Number;
		supportedUSBControllerList: String[];
		supportLevel: String;
		supports3D: boolean;
		supportsCpuHotAdd: boolean;
		supportsCpuHotRemove: boolean;
		supportsHotPlugPCI: boolean;
		supportsMemoryHotAdd: boolean;
		supportsPvscsiControllerForBoot: boolean;
		supportsSlaveDisk: boolean;
		supportsVMI: boolean;
		supportsWakeOnLan: boolean;
		usbRecommended: boolean;
		vRAMSizeInKB: VcIntOption;
		wakeOnLanEthernetCard: String[];

		constructor();
	}

	interface VcGuestOsDescriptorFirmwareType
	{
		readonly _bios: String;
		readonly _csm: String;
		readonly _efi: String;
		readonly bios: VcGuestOsDescriptorFirmwareType;
		readonly csm: VcGuestOsDescriptorFirmwareType;
		readonly efi: VcGuestOsDescriptorFirmwareType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcGuestOsDescriptorFirmwareType;
	}

	interface VcGuestOsDescriptorFirmwareTypeConstructor {
		new(value?:any): VcGuestOsDescriptorFirmwareType;
		readonly prototype: VcGuestOsDescriptorFirmwareType;
	}

	declare const VcGuestOsDescriptorFirmwareType: VcGuestOsDescriptorFirmwareTypeConstructor;

	interface VcGuestOsDescriptorSupportLevel
	{
		readonly _deprecated: String;
		readonly _experimental: String;
		readonly _legacy: String;
		readonly _supported: String;
		readonly _techPreview: String;
		readonly _terminated: String;
		readonly _unsupported: String;
		readonly deprecated: VcGuestOsDescriptorSupportLevel;
		readonly experimental: VcGuestOsDescriptorSupportLevel;
		readonly id: String;
		readonly legacy: VcGuestOsDescriptorSupportLevel;
		readonly name: String;
		readonly supported: VcGuestOsDescriptorSupportLevel;
		readonly techPreview: VcGuestOsDescriptorSupportLevel;
		readonly terminated: VcGuestOsDescriptorSupportLevel;
		readonly unsupported: VcGuestOsDescriptorSupportLevel;
		readonly value: String;

		fromString(value?: String): VcGuestOsDescriptorSupportLevel;
	}

	interface VcGuestOsDescriptorSupportLevelConstructor {
		new(value?:any): VcGuestOsDescriptorSupportLevel;
		readonly prototype: VcGuestOsDescriptorSupportLevel;
	}

	declare const VcGuestOsDescriptorSupportLevel: VcGuestOsDescriptorSupportLevelConstructor;

	declare class VcGuestPosixFileAttributes
	{
		accessTime: Date;
		groupId: Number;
		modificationTime: Date;
		ownerId: Number;
		permissions: Number;
		symlinkTarget: String;

		constructor();
	}

	declare class VcGuestProcessInfo
	{
		cmdLine: String;
		endTime: Date;
		exitCode: Number;
		name: String;
		owner: String;
		pid: Number;
		startTime: Date;

		constructor();
	}

	interface VcGuestProcessManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		listProcessesInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, pids?: Number[]): VcGuestProcessInfo[];
		readEnvironmentVariableInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, names?: String[]): String[];
		startProgramInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, spec?: VcGuestProgramSpec): Number;
		terminateProcessInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, pid?: Number): void;
	}

	declare const VcGuestProcessManager: VcGuestProcessManager;

	declare class VcGuestProgramSpec
	{
		arguments: String;
		envVariables: String[];
		programPath: String;
		workingDirectory: String;

		constructor();
	}

	declare class VcGuestRegKeyNameSpec
	{
		registryPath: String;
		wowBitness: String;

		constructor();
	}

	declare class VcGuestRegKeyRecordSpec
	{
		fault: VcLocalizedMethodFault;
		key: VcGuestRegKeySpec;

		constructor();
	}

	declare class VcGuestRegKeySpec
	{
		classType: String;
		keyName: VcGuestRegKeyNameSpec;
		lastWritten: Date;

		constructor();
	}

	interface VcGuestRegKeyWowSpec
	{
		readonly _WOW32: String;
		readonly _WOW64: String;
		readonly _WOWNative: String;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly WOW32: VcGuestRegKeyWowSpec;
		readonly WOW64: VcGuestRegKeyWowSpec;
		readonly WOWNative: VcGuestRegKeyWowSpec;

		fromString(value?: String): VcGuestRegKeyWowSpec;
	}

	interface VcGuestRegKeyWowSpecConstructor {
		new(value?:any): VcGuestRegKeyWowSpec;
		readonly prototype: VcGuestRegKeyWowSpec;
	}

	declare const VcGuestRegKeyWowSpec: VcGuestRegKeyWowSpecConstructor;

	declare class VcGuestRegValueBinarySpec
	{
		value: base64Binary;

		constructor();
	}

	declare class VcGuestRegValueDataSpec
	{

		constructor();
	}

	declare class VcGuestRegValueDwordSpec
	{
		value: Number;

		constructor();
	}

	declare class VcGuestRegValueExpandStringSpec
	{
		value: String;

		constructor();
	}

	declare class VcGuestRegValueMultiStringSpec
	{
		value: String[];

		constructor();
	}

	declare class VcGuestRegValueNameSpec
	{
		keyName: VcGuestRegKeyNameSpec;
		name: String;

		constructor();
	}

	declare class VcGuestRegValueQwordSpec
	{
		value: Number;

		constructor();
	}

	declare class VcGuestRegValueSpec
	{
		data: VcGuestRegValueDataSpec;
		name: VcGuestRegValueNameSpec;

		constructor();
	}

	declare class VcGuestRegValueStringSpec
	{
		value: String;

		constructor();
	}

	declare class VcGuestScreenInfo
	{
		height: Number;
		width: Number;

		constructor();
	}

	declare class VcGuestStackInfo
	{
		dhcpConfig: VcNetDhcpConfigInfo;
		dnsConfig: VcNetDnsConfigInfo;
		ipRouteConfig: VcNetIpRouteConfigInfo;
		ipStackConfig: VcKeyValue[];

		constructor();
	}

	declare class VcGuestWindowsFileAttributes
	{
		accessTime: Date;
		createTime: Date;
		hidden: boolean;
		modificationTime: Date;
		readOnly: boolean;
		symlinkTarget: String;

		constructor();
	}

	declare class VcGuestWindowsProgramSpec
	{
		arguments: String;
		envVariables: String[];
		programPath: String;
		startMinimized: boolean;
		workingDirectory: String;

		constructor();
	}

	interface VcGuestWindowsRegistryManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createRegistryKeyInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, keyName?: VcGuestRegKeyNameSpec, isVolatile?: boolean, classType?: String): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteRegistryKeyInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, keyName?: VcGuestRegKeyNameSpec, recursive?: boolean): void;
		deleteRegistryValueInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, valueName?: VcGuestRegValueNameSpec): void;
		listRegistryKeysInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, keyName?: VcGuestRegKeyNameSpec, recursive?: boolean, matchPattern?: String): VcGuestRegKeyRecordSpec[];
		listRegistryValuesInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, keyName?: VcGuestRegKeyNameSpec, expandStrings?: boolean, matchPattern?: String): VcGuestRegValueSpec[];
		setRegistryValueInGuest(vm?: VcVirtualMachine, auth?: VcGuestAuthentication, value?: VcGuestRegValueSpec): void;
	}

	declare const VcGuestWindowsRegistryManager: VcGuestWindowsRegistryManager;

	declare class VcHbrDiskMigrationAction
	{
		collectionId: String;
		collectionName: String;
		destination: VcDatastore;
		diskIds: String[];
		ioLatencyDstBefore: Number;
		ioLatencySrcBefore: Number;
		sizeTransferred: Number;
		source: VcDatastore;
		spaceUtilDstAfter: Number;
		spaceUtilDstBefore: Number;
		spaceUtilSrcAfter: Number;
		spaceUtilSrcBefore: Number;
		target: VcManagedObjectReference;
		type: String;

		constructor();
	}

	declare class VcHbrManagerReplicationVmInfo
	{
		imageId: String;
		lastError: VcLocalizedMethodFault;
		progressInfo: VcReplicationVmProgressInfo;
		state: String;

		constructor();
	}

	declare class VcHbrManagerVmReplicationCapability
	{
		compressionSupported: boolean;
		fault: VcLocalizedMethodFault;
		maxSupportedSourceDiskCapacity: Number;
		minRpo: Number;
		supportedQuiesceMode: String;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcHealthStatusChangedEvent
	{
		chainId: Number;
		changeTag: String;
		componentId: String;
		componentName: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newStatus: String;
		oldStatus: String;
		serviceId: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHealthSystemRuntime
	{
		hardwareStatusInfo: VcHostHardwareStatusInfo;
		systemHealthInfo: VcHostSystemHealthInfo;

		constructor();
	}

	interface VcHistoryCollector
	{
		filter: Object;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyCollector(): void;
		resetCollector(): void;
		rewindCollector(): void;
		setCollectorPageSize(maxCount?: Number): void;
	}

	declare const VcHistoryCollector: VcHistoryCollector;

	interface VcHookManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		acquireMethodHookForExtension(extensionKey?: String, vmodlMethod?: String, redHealthPolicy?: VcHookManagerExtensionHealthRedAction, asyncPreCallback?: boolean, postCallbackPolicy?: VcHookManagerPostCallbackPolicy, defaultPreCallbackResult?: VcPreCallbackResult, leaseTimeMilliseconds?: Number): VcHookManagerMethodHookAcquisitionResult;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		declareExtensionAsHookingService(extensionKey?: String, serviceIp?: String, servicePort?: Number, servicePath?: String, UpdateExistingDeclaration?: boolean): VcHookManagerExtensionHookDeclResult;
		releaseMethodHookForExtension(extensionKey?: String, vmodlMethod?: String): VcHookManagerMethodHookReleaseResult;
		removeExtensionAsHookingService(extensionKey?: String): VcHookManagerExtensionHookRemovalResult;
		updatePreCallbackResult(extensionKey?: String, resultToUpdate?: VcPreCallbackResult): void;
	}

	declare const VcHookManager: VcHookManager;

	interface VcHookManagerExtensionHealthRedAction
	{
		readonly _PersistHook: String;
		readonly _RemoveHook: String;
		readonly id: String;
		readonly name: String;
		readonly PersistHook: VcHookManagerExtensionHealthRedAction;
		readonly RemoveHook: VcHookManagerExtensionHealthRedAction;
		readonly value: String;

		fromString(value?: String): VcHookManagerExtensionHealthRedAction;
	}

	interface VcHookManagerExtensionHealthRedActionConstructor {
		new(value?:any): VcHookManagerExtensionHealthRedAction;
		readonly prototype: VcHookManagerExtensionHealthRedAction;
	}

	declare const VcHookManagerExtensionHealthRedAction: VcHookManagerExtensionHealthRedActionConstructor;

	interface VcHookManagerExtensionHookDeclResult
	{
		readonly _CannotDeclareInvalidExtensionKey: String;
		readonly _DeclarationPersistenceFailure: String;
		readonly _DeclarationSuccess: String;
		readonly _DuplicateExtension: String;
		readonly _IncompatibleVmodlVersion: String;
		readonly CannotDeclareInvalidExtensionKey: VcHookManagerExtensionHookDeclResult;
		readonly DeclarationPersistenceFailure: VcHookManagerExtensionHookDeclResult;
		readonly DeclarationSuccess: VcHookManagerExtensionHookDeclResult;
		readonly DuplicateExtension: VcHookManagerExtensionHookDeclResult;
		readonly id: String;
		readonly IncompatibleVmodlVersion: VcHookManagerExtensionHookDeclResult;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHookManagerExtensionHookDeclResult;
	}

	interface VcHookManagerExtensionHookDeclResultConstructor {
		new(value?:any): VcHookManagerExtensionHookDeclResult;
		readonly prototype: VcHookManagerExtensionHookDeclResult;
	}

	declare const VcHookManagerExtensionHookDeclResult: VcHookManagerExtensionHookDeclResultConstructor;

	interface VcHookManagerExtensionHookRemovalResult
	{
		readonly _CannotRemoveInvalidExtensionKey: String;
		readonly _RemovalPersistenceFailure: String;
		readonly _RemovalSuccess: String;
		readonly CannotRemoveInvalidExtensionKey: VcHookManagerExtensionHookRemovalResult;
		readonly id: String;
		readonly name: String;
		readonly RemovalPersistenceFailure: VcHookManagerExtensionHookRemovalResult;
		readonly RemovalSuccess: VcHookManagerExtensionHookRemovalResult;
		readonly value: String;

		fromString(value?: String): VcHookManagerExtensionHookRemovalResult;
	}

	interface VcHookManagerExtensionHookRemovalResultConstructor {
		new(value?:any): VcHookManagerExtensionHookRemovalResult;
		readonly prototype: VcHookManagerExtensionHookRemovalResult;
	}

	declare const VcHookManagerExtensionHookRemovalResult: VcHookManagerExtensionHookRemovalResultConstructor;

	interface VcHookManagerMethodHookAcquisitionResult
	{
		readonly _AcquisitionPersistenceFailure: String;
		readonly _AcquisitionSuccess: String;
		readonly _CannotAcquireInvalidExtensionKey: String;
		readonly _CannotAcquireInvalidMethod: String;
		readonly _MethodHookAlreadyAcquired: String;
		readonly AcquisitionPersistenceFailure: VcHookManagerMethodHookAcquisitionResult;
		readonly AcquisitionSuccess: VcHookManagerMethodHookAcquisitionResult;
		readonly CannotAcquireInvalidExtensionKey: VcHookManagerMethodHookAcquisitionResult;
		readonly CannotAcquireInvalidMethod: VcHookManagerMethodHookAcquisitionResult;
		readonly id: String;
		readonly MethodHookAlreadyAcquired: VcHookManagerMethodHookAcquisitionResult;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHookManagerMethodHookAcquisitionResult;
	}

	interface VcHookManagerMethodHookAcquisitionResultConstructor {
		new(value?:any): VcHookManagerMethodHookAcquisitionResult;
		readonly prototype: VcHookManagerMethodHookAcquisitionResult;
	}

	declare const VcHookManagerMethodHookAcquisitionResult: VcHookManagerMethodHookAcquisitionResultConstructor;

	interface VcHookManagerMethodHookReleaseResult
	{
		readonly _CannotReleaseInvalidExtensionKey: String;
		readonly _CannotReleaseInvalidMethod: String;
		readonly _MethodNotHooked: String;
		readonly _ReleasePersistenceFailure: String;
		readonly _ReleaseSuccess: String;
		readonly CannotReleaseInvalidExtensionKey: VcHookManagerMethodHookReleaseResult;
		readonly CannotReleaseInvalidMethod: VcHookManagerMethodHookReleaseResult;
		readonly id: String;
		readonly MethodNotHooked: VcHookManagerMethodHookReleaseResult;
		readonly name: String;
		readonly ReleasePersistenceFailure: VcHookManagerMethodHookReleaseResult;
		readonly ReleaseSuccess: VcHookManagerMethodHookReleaseResult;
		readonly value: String;

		fromString(value?: String): VcHookManagerMethodHookReleaseResult;
	}

	interface VcHookManagerMethodHookReleaseResultConstructor {
		new(value?:any): VcHookManagerMethodHookReleaseResult;
		readonly prototype: VcHookManagerMethodHookReleaseResult;
	}

	declare const VcHookManagerMethodHookReleaseResult: VcHookManagerMethodHookReleaseResultConstructor;

	interface VcHookManagerPostCallbackPolicy
	{
		readonly _AlwaysSyncPostCallback: String;
		readonly _AsyncPostCallbackOnFail: String;
		readonly _AsyncPostCallbackOnSuccess: String;
		readonly AlwaysSyncPostCallback: VcHookManagerPostCallbackPolicy;
		readonly AsyncPostCallbackOnFail: VcHookManagerPostCallbackPolicy;
		readonly AsyncPostCallbackOnSuccess: VcHookManagerPostCallbackPolicy;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHookManagerPostCallbackPolicy;
	}

	interface VcHookManagerPostCallbackPolicyConstructor {
		new(value?:any): VcHookManagerPostCallbackPolicy;
		readonly prototype: VcHookManagerPostCallbackPolicy;
	}

	declare const VcHookManagerPostCallbackPolicy: VcHookManagerPostCallbackPolicyConstructor;

	declare class VcHostAccessControlEntry
	{
		accessMode: VcHostAccessMode;
		group: boolean;
		principal: String;

		constructor();
	}

	interface VcHostAccessManager
	{
		readonly id: String;
		lockdownMode: VcHostLockdownMode;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		changeAccessMode(principal?: String, isGroup?: boolean, accessMode?: VcHostAccessMode): void;
		changeLockdownMode(mode?: VcHostLockdownMode): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryDcuiAccess(): String[];
		queryLockdownExceptions(): String[];
		querySystemUsers(): String[];
		retrieveHostAccessControlEntries(): VcHostAccessControlEntry[];
		updateDcuiAccess(users?: String[]): void;
		updateLockdownExceptions(users?: String[]): void;
		updateSystemUsers(users?: String[]): void;
	}

	declare const VcHostAccessManager: VcHostAccessManager;

	interface VcHostAccessMode
	{
		readonly _accessAdmin: String;
		readonly _accessNoAccess: String;
		readonly _accessNone: String;
		readonly _accessOther: String;
		readonly _accessReadOnly: String;
		readonly accessAdmin: VcHostAccessMode;
		readonly accessNoAccess: VcHostAccessMode;
		readonly accessNone: VcHostAccessMode;
		readonly accessOther: VcHostAccessMode;
		readonly accessReadOnly: VcHostAccessMode;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostAccessMode;
	}

	interface VcHostAccessModeConstructor {
		new(value?:any): VcHostAccessMode;
		readonly prototype: VcHostAccessMode;
	}

	declare const VcHostAccessMode: VcHostAccessModeConstructor;

	declare class VcHostAccountSpec
	{
		description: String;
		id: String;
		password: String;

		constructor();
	}

	declare class VcHostActiveDirectory
	{
		changeOperation: String;
		spec: VcHostActiveDirectorySpec;

		constructor();
	}

	interface VcHostActiveDirectoryAuthentication
	{
		readonly id: String;
		info: VcHostAuthenticationStoreInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		disableSmartCardAuthentication(): void;
		enableSmartCardAuthentication(): void;
		importCertificateForCAM_Task(certPath?: String, camServer?: String): VcTask;
		installSmartCardTrustAnchor(cert?: String): void;
		joinDomain_Task(domainName?: String, userName?: String, password?: String): VcTask;
		joinDomainWithCAM_Task(domainName?: String, camServer?: String): VcTask;
		leaveCurrentDomain_Task(force?: boolean): VcTask;
		listSmartCardTrustAnchors(): String[];
		removeSmartCardTrustAnchor(issuer?: String, serial?: String): void;
		removeSmartCardTrustAnchorByFingerprint(fingerprint?: String, digest?: String): void;
		replaceSmartCardTrustAnchors(certs?: String[]): void;
	}

	declare const VcHostActiveDirectoryAuthentication: VcHostActiveDirectoryAuthentication;

	interface VcHostActiveDirectoryAuthenticationCertificateDigest
	{
		readonly _SHA1: String;
		readonly id: String;
		readonly name: String;
		readonly SHA1: VcHostActiveDirectoryAuthenticationCertificateDigest;
		readonly value: String;

		fromString(value?: String): VcHostActiveDirectoryAuthenticationCertificateDigest;
	}

	interface VcHostActiveDirectoryAuthenticationCertificateDigestConstructor {
		new(value?:any): VcHostActiveDirectoryAuthenticationCertificateDigest;
		readonly prototype: VcHostActiveDirectoryAuthenticationCertificateDigest;
	}

	declare const VcHostActiveDirectoryAuthenticationCertificateDigest: VcHostActiveDirectoryAuthenticationCertificateDigestConstructor;

	declare class VcHostActiveDirectoryInfo
	{
		domainMembershipStatus: String;
		enabled: boolean;
		joinedDomain: String;
		smartCardAuthenticationEnabled: boolean;
		trustedDomain: String[];

		constructor();
	}

	interface VcHostActiveDirectoryInfoDomainMembershipStatus
	{
		readonly _clientTrustBroken: String;
		readonly _inconsistentTrust: String;
		readonly _noServers: String;
		readonly _ok: String;
		readonly _otherProblem: String;
		readonly _serverTrustBroken: String;
		readonly _unknown: String;
		readonly clientTrustBroken: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly id: String;
		readonly inconsistentTrust: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly name: String;
		readonly noServers: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly ok: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly otherProblem: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly serverTrustBroken: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly unknown: VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly value: String;

		fromString(value?: String): VcHostActiveDirectoryInfoDomainMembershipStatus;
	}

	interface VcHostActiveDirectoryInfoDomainMembershipStatusConstructor {
		new(value?:any): VcHostActiveDirectoryInfoDomainMembershipStatus;
		readonly prototype: VcHostActiveDirectoryInfoDomainMembershipStatus;
	}

	declare const VcHostActiveDirectoryInfoDomainMembershipStatus: VcHostActiveDirectoryInfoDomainMembershipStatusConstructor;

	declare class VcHostActiveDirectorySpec
	{
		camServer: String;
		domainName: String;
		password: String;
		smartCardAuthenticationEnabled: boolean;
		smartCardTrustAnchors: String[];
		thumbprint: String;
		userName: String;

		constructor();
	}

	declare class VcHostAddedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostAddFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostname: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostAdminDisableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostAdminEnableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostApplyProfile
	{
		authentication: VcAuthenticationProfile;
		datetime: VcDateTimeProfile;
		enabled: boolean;
		firewall: VcFirewallProfile;
		memory: VcHostMemoryProfile;
		network: VcNetworkProfile;
		option: VcOptionProfile[];
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		security: VcSecurityProfile;
		service: VcServiceProfile[];
		storage: VcStorageProfile;
		userAccount: VcUserProfile[];
		usergroupAccount: VcUserGroupProfile[];

		constructor();
	}

	interface VcHostAuthenticationManager
	{
		readonly id: String;
		info: VcHostAuthenticationManagerInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		supportedStore: VcHostAuthenticationStore[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostAuthenticationManager: VcHostAuthenticationManager;

	declare class VcHostAuthenticationManagerInfo
	{
		authConfig: VcHostAuthenticationStoreInfo[];

		constructor();
	}

	interface VcHostAuthenticationStore
	{
		readonly id: String;
		info: VcHostAuthenticationStoreInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostAuthenticationStore: VcHostAuthenticationStore;

	declare class VcHostAuthenticationStoreInfo
	{
		enabled: boolean;

		constructor();
	}

	interface VcHostAutoStartManager
	{
		config: VcHostAutoStartManagerConfig;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		autoStartPowerOff(): void;
		autoStartPowerOn(): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureAutostart(spec?: VcHostAutoStartManagerConfig): void;
	}

	declare const VcHostAutoStartManager: VcHostAutoStartManager;

	declare class VcHostAutoStartManagerConfig
	{
		defaults: VcAutoStartDefaults;
		powerInfo: VcAutoStartPowerInfo[];

		constructor();
	}

	declare class VcHostBIOSInfo
	{
		biosVersion: String;
		releaseDate: Date;

		constructor();
	}

	declare class VcHostBlockAdapterTargetTransport
	{

		constructor();
	}

	declare class VcHostBlockHba
	{
		bus: Number;
		device: String;
		driver: String;
		key: String;
		model: String;
		pci: String;
		status: String;

		constructor();
	}

	declare class VcHostBootDevice
	{
		description: String;
		key: String;

		constructor();
	}

	declare class VcHostBootDeviceInfo
	{
		bootDevices: VcHostBootDevice[];
		currentBootDeviceKey: String;

		constructor();
	}

	interface VcHostBootDeviceSystem
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryBootDevices(): VcHostBootDeviceInfo;
		updateBootDevice(key?: String): void;
	}

	declare const VcHostBootDeviceSystem: VcHostBootDeviceSystem;

	declare class VcHostCacheConfigurationInfo
	{
		key: VcDatastore;
		swapSize: Number;

		constructor();
	}

	interface VcHostCacheConfigurationManager
	{
		cacheConfigurationInfo: VcHostCacheConfigurationInfo[];
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		configureHostCache_Task(spec?: VcHostCacheConfigurationSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostCacheConfigurationManager: VcHostCacheConfigurationManager;

	declare class VcHostCacheConfigurationSpec
	{
		datastore: VcDatastore;
		swapSize: Number;

		constructor();
	}

	declare class VcHostCapability
	{
		accel3dSupported: boolean;
		advancedSystemResourcesSupported: boolean;
		backgroundSnapshotsSupported: boolean;
		checkpointFtCompatibilityIssues: String[];
		checkpointFtSupported: boolean;
		cloneFromSnapshotSupported: boolean;
		cpuMemoryResourceConfigurationSupported: boolean;
		datastorePrincipalSupported: boolean;
		deltaDiskBackingsSupported: boolean;
		eightPlusHostVmfsSharedAccessSupported: boolean;
		featureCapabilitiesSupported: boolean;
		firewallIpRulesSupported: boolean;
		ftCompatibilityIssues: String[];
		ftSupported: boolean;
		hbrNicSelectionSupported: boolean;
		highGuestMemSupported: boolean;
		hostAccessManagerSupported: boolean;
		interVMCommunicationThroughVMCISupported: boolean;
		ipmiSupported: boolean;
		iscsiSupported: boolean;
		latencySensitivitySupported: boolean;
		localSwapDatastoreSupported: boolean;
		loginBySSLThumbprintSupported: boolean;
		maintenanceModeSupported: boolean;
		markAsLocalSupported: boolean;
		markAsSsdSupported: boolean;
		maxHostRunningVms: Number;
		maxHostSupportedVcpus: Number;
		maxNumDisksSVMotion: Number;
		maxRegisteredVMs: Number;
		maxRunningVMs: Number;
		maxSupportedVcpus: Number;
		maxSupportedVMs: Number;
		maxVcpusPerFtVm: Number;
		messageBusProxySupported: boolean;
		multipleNetworkStackInstanceSupported: boolean;
		nestedHVSupported: boolean;
		nfs41Supported: boolean;
		nfsSupported: boolean;
		nicTeamingSupported: boolean;
		perVMNetworkTrafficShapingSupported: boolean;
		perVmSwapFiles: boolean;
		preAssignedPCIUnitNumbersSupported: boolean;
		provisioningNicSelectionSupported: boolean;
		rebootSupported: boolean;
		recordReplaySupported: boolean;
		recursiveResourcePoolsSupported: boolean;
		reliableMemoryAware: boolean;
		replayCompatibilityIssues: String[];
		replayUnsupportedReason: String;
		restrictedSnapshotRelocateSupported: boolean;
		sanSupported: boolean;
		scaledScreenshotSupported: boolean;
		scheduledHardwareUpgradeSupported: boolean;
		screenshotSupported: boolean;
		servicePackageInfoSupported: boolean;
		shutdownSupported: boolean;
		smartCardAuthenticationSupported: boolean;
		smpFtCompatibilityIssues: String[];
		smpFtSupported: boolean;
		snapshotRelayoutSupported: boolean;
		standbySupported: boolean;
		storageIORMSupported: boolean;
		storagePolicySupported: boolean;
		storageVMotionSupported: boolean;
		supportedCpuFeature: VcHostCpuIdInfo[];
		supportedVmfsMajorVersion: Number[];
		suspendedRelocateSupported: boolean;
		tpmSupported: boolean;
		turnDiskLocatorLedSupported: boolean;
		unsharedSwapVMotionSupported: boolean;
		vFlashSupported: boolean;
		virtualExecUsageSupported: boolean;
		virtualVolumeDatastoreSupported: boolean;
		vlanTaggingSupported: boolean;
		vmDirectPathGen2Supported: boolean;
		vmDirectPathGen2UnsupportedReason: String[];
		vmDirectPathGen2UnsupportedReasonExtended: String;
		vmfsDatastoreMountCapable: boolean;
		vmotionAcrossNetworkSupported: boolean;
		vmotionEncryptionSupported: boolean;
		vmotionSupported: boolean;
		vmotionWithStorageVMotionSupported: boolean;
		vPMCSupported: boolean;
		vrNfcNicSelectionSupported: boolean;
		vsanSupported: boolean;
		vStorageCapable: boolean;

		constructor();
	}

	interface VcHostCapabilityFtUnsupportedReason
	{
		readonly _cpuHvDisabled: String;
		readonly _cpuHvUnsupported: String;
		readonly _cpuHwmmuUnsupported: String;
		readonly _ftNotLicensed: String;
		readonly _haAgentIssue: String;
		readonly _missingFTLoggingNic: String;
		readonly _missingVMotionNic: String;
		readonly _unsupportedProduct: String;
		readonly _vMotionNotLicensed: String;
		readonly cpuHvDisabled: VcHostCapabilityFtUnsupportedReason;
		readonly cpuHvUnsupported: VcHostCapabilityFtUnsupportedReason;
		readonly cpuHwmmuUnsupported: VcHostCapabilityFtUnsupportedReason;
		readonly ftNotLicensed: VcHostCapabilityFtUnsupportedReason;
		readonly haAgentIssue: VcHostCapabilityFtUnsupportedReason;
		readonly id: String;
		readonly missingFTLoggingNic: VcHostCapabilityFtUnsupportedReason;
		readonly missingVMotionNic: VcHostCapabilityFtUnsupportedReason;
		readonly name: String;
		readonly unsupportedProduct: VcHostCapabilityFtUnsupportedReason;
		readonly value: String;
		readonly vMotionNotLicensed: VcHostCapabilityFtUnsupportedReason;

		fromString(value?: String): VcHostCapabilityFtUnsupportedReason;
	}

	interface VcHostCapabilityFtUnsupportedReasonConstructor {
		new(value?:any): VcHostCapabilityFtUnsupportedReason;
		readonly prototype: VcHostCapabilityFtUnsupportedReason;
	}

	declare const VcHostCapabilityFtUnsupportedReason: VcHostCapabilityFtUnsupportedReasonConstructor;

	interface VcHostCapabilityVmDirectPathGen2UnsupportedReason
	{
		readonly _hostNptDisabled: String;
		readonly _hostNptIncompatibleHardware: String;
		readonly _hostNptIncompatibleProduct: String;
		readonly hostNptDisabled: VcHostCapabilityVmDirectPathGen2UnsupportedReason;
		readonly hostNptIncompatibleHardware: VcHostCapabilityVmDirectPathGen2UnsupportedReason;
		readonly hostNptIncompatibleProduct: VcHostCapabilityVmDirectPathGen2UnsupportedReason;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostCapabilityVmDirectPathGen2UnsupportedReason;
	}

	interface VcHostCapabilityVmDirectPathGen2UnsupportedReasonConstructor {
		new(value?:any): VcHostCapabilityVmDirectPathGen2UnsupportedReason;
		readonly prototype: VcHostCapabilityVmDirectPathGen2UnsupportedReason;
	}

	declare const VcHostCapabilityVmDirectPathGen2UnsupportedReason: VcHostCapabilityVmDirectPathGen2UnsupportedReasonConstructor;

	interface VcHostCertificateManager
	{
		certificateInfo: VcHostCertificateManagerCertificateInfo;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		generateCertificateSigningRequest(useIpAddressAsCommonName?: boolean): String;
		generateCertificateSigningRequestByDn(distinguishedName?: String): String;
		installServerCertificate(cert?: String): void;
		listCACertificateRevocationLists(): String[];
		listCACertificates(): String[];
		replaceCACertificatesAndCRLs(caCert?: String[], caCrl?: String[]): void;
	}

	declare const VcHostCertificateManager: VcHostCertificateManager;

	declare class VcHostCertificateManagerCertificateInfo
	{
		issuer: String;
		notAfter: Date;
		notBefore: Date;
		status: String;
		subject: String;

		constructor();
	}

	interface VcHostCertificateManagerCertificateInfoCertificateStatus
	{
		readonly _expirationImminent: String;
		readonly _expired: String;
		readonly _expiring: String;
		readonly _expiringShortly: String;
		readonly _good: String;
		readonly _revoked: String;
		readonly _unknown: String;
		readonly expirationImminent: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly expired: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly expiring: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly expiringShortly: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly good: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly id: String;
		readonly name: String;
		readonly revoked: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly unknown: VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly value: String;

		fromString(value?: String): VcHostCertificateManagerCertificateInfoCertificateStatus;
	}

	interface VcHostCertificateManagerCertificateInfoCertificateStatusConstructor {
		new(value?:any): VcHostCertificateManagerCertificateInfoCertificateStatus;
		readonly prototype: VcHostCertificateManagerCertificateInfoCertificateStatus;
	}

	declare const VcHostCertificateManagerCertificateInfoCertificateStatus: VcHostCertificateManagerCertificateInfoCertificateStatusConstructor;

	declare class VcHostCnxFailedAccountFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedAlreadyManagedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		serverName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedBadCcagentEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedBadUsernameEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedBadVersionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedCcagentUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedNetworkErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedNoAccessEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedNoConnectionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedNoLicenseEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedNotFoundEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCnxFailedTimeoutEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostComplianceCheckedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostCompliantEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostConfigAppliedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostConfigChange
	{

		constructor();
	}

	interface VcHostConfigChangeMode
	{
		readonly _modify: String;
		readonly _replace: String;
		readonly id: String;
		readonly modify: VcHostConfigChangeMode;
		readonly name: String;
		readonly replace: VcHostConfigChangeMode;
		readonly value: String;

		fromString(value?: String): VcHostConfigChangeMode;
	}

	interface VcHostConfigChangeModeConstructor {
		new(value?:any): VcHostConfigChangeMode;
		readonly prototype: VcHostConfigChangeMode;
	}

	declare const VcHostConfigChangeMode: VcHostConfigChangeModeConstructor;

	interface VcHostConfigChangeOperation
	{
		readonly _add: String;
		readonly _edit: String;
		readonly _remove: String;
		readonly add: VcHostConfigChangeOperation;
		readonly edit: VcHostConfigChangeOperation;
		readonly id: String;
		readonly name: String;
		readonly remove: VcHostConfigChangeOperation;
		readonly value: String;

		fromString(value?: String): VcHostConfigChangeOperation;
	}

	interface VcHostConfigChangeOperationConstructor {
		new(value?:any): VcHostConfigChangeOperation;
		readonly prototype: VcHostConfigChangeOperation;
	}

	declare const VcHostConfigChangeOperation: VcHostConfigChangeOperationConstructor;

	declare class VcHostConfigInfo
	{
		activeDiagnosticPartition: VcHostDiagnosticPartition;
		adminDisabled: boolean;
		authenticationManagerInfo: VcHostAuthenticationManagerInfo;
		autoStart: VcHostAutoStartManagerConfig;
		cacheConfigurationInfo: VcHostCacheConfigurationInfo[];
		capabilities: VcHostNetCapabilities;
		certificate: Number[];
		consoleReservation: VcServiceConsoleReservationInfo;
		datastoreCapabilities: VcHostDatastoreSystemCapabilities;
		datastorePrincipal: String;
		dateTimeInfo: VcHostDateTimeInfo;
		domainList: String[];
		featureCapability: VcHostFeatureCapability[];
		featureVersion: VcHostFeatureVersionInfo[];
		fileSystemVolume: VcHostFileSystemVolumeInfo;
		firewall: VcHostFirewallInfo;
		flags: VcHostFlagInfo;
		graphicsInfo: VcHostGraphicsInfo[];
		host: VcHostSystem;
		hostConfigCheckSum: base64Binary;
		hyperThread: VcHostHyperThreadScheduleInfo;
		ioFilterInfo: VcHostIoFilterInfo[];
		ipmi: VcHostIpmiInfo;
		localSwapDatastore: VcDatastore;
		lockdownMode: VcHostLockdownMode;
		maskedFeatureCapability: VcHostFeatureCapability[];
		multipathState: VcHostMultipathStateInfo;
		network: VcHostNetworkInfo;
		offloadCapabilities: VcHostNetOffloadCapabilities;
		option: VcOptionValue[];
		optionDef: VcOptionDef[];
		pciPassthruInfo: VcHostPciPassthruInfo[];
		powerSystemCapability: VcPowerSystemCapability;
		powerSystemInfo: VcPowerSystemInfo;
		product: VcAboutInfo;
		scriptCheckSum: base64Binary;
		service: VcHostServiceInfo;
		sharedPassthruGpuTypes: String[];
		sslThumbprintData: VcHostSslThumbprintInfo[];
		sslThumbprintInfo: VcHostSslThumbprintInfo;
		storageDevice: VcHostStorageDeviceInfo;
		systemFile: String[];
		systemResources: VcHostSystemResourceInfo;
		systemSwapConfiguration: VcHostSystemSwapConfiguration;
		vFlashConfigInfo: VcHostVFlashManagerVFlashConfigInfo;
		virtualMachineReservation: VcVirtualMachineMemoryReservationInfo;
		virtualNicManagerInfo: VcHostVirtualNicManagerInfo;
		vmotion: VcHostVMotionInfo;
		vsanHostConfig: VcVsanHostConfigInfo;
		wakeOnLanCapable: boolean;

		constructor();
	}

	declare class VcHostConfigManager
	{
		accountManager: VcHostLocalAccountManager;
		advancedOption: VcOptionManager;
		authenticationManager: VcHostAuthenticationManager;
		autoStartManager: VcHostAutoStartManager;
		bootDeviceSystem: VcHostBootDeviceSystem;
		cacheConfigurationManager: VcHostCacheConfigurationManager;
		certificateManager: VcHostCertificateManager;
		cpuScheduler: VcHostCpuSchedulerSystem;
		datastoreSystem: VcHostDatastoreSystem;
		dateTimeSystem: VcHostDateTimeSystem;
		diagnosticSystem: VcHostDiagnosticSystem;
		esxAgentHostManager: VcHostEsxAgentHostManager;
		firewallSystem: VcHostFirewallSystem;
		firmwareSystem: VcHostFirmwareSystem;
		graphicsManager: VcHostGraphicsManager;
		healthStatusSystem: VcHostHealthStatusSystem;
		hostAccessManager: VcHostAccessManager;
		hostUpdateProxyManager: VcHostHostUpdateProxyManager;
		imageConfigManager: VcHostImageConfigManager;
		iscsiManager: VcIscsiManager;
		kernelModuleSystem: VcHostKernelModuleSystem;
		licenseManager: VcLicenseManager;
		memoryManager: VcHostMemorySystem;
		messageBusProxy: VcMessageBusProxy;
		networkSystem: VcHostNetworkSystem;
		patchManager: VcHostPatchManager;
		pciPassthruSystem: VcHostPciPassthruSystem;
		powerSystem: VcHostPowerSystem;
		serviceSystem: VcHostServiceSystem;
		snmpSystem: VcHostSnmpSystem;
		storageSystem: VcHostStorageSystem;
		userDirectory: VcUserDirectory;
		vFlashManager: VcHostVFlashManager;
		virtualNicManager: VcHostVirtualNicManager;
		vmotionSystem: VcHostVMotionSystem;
		vsanInternalSystem: VcHostVsanInternalSystem;
		vsanSystem: VcHostVsanSystem;

		constructor();
	}

	declare class VcHostConfigSpec
	{
		activeDirectory: VcHostActiveDirectory[];
		datastorePrincipal: String;
		datastorePrincipalPasswd: String;
		datetime: VcHostDateTimeConfig;
		firewall: VcHostFirewallConfig;
		genericConfig: VcKeyAnyValue[];
		license: VcHostLicenseSpec;
		memory: VcHostMemorySpec;
		nasDatastore: VcHostNasVolumeConfig[];
		network: VcHostNetworkConfig;
		nicTypeSelection: VcHostVirtualNicManagerNicTypeSelection[];
		option: VcOptionValue[];
		security: VcHostSecuritySpec;
		service: VcHostServiceConfig[];
		storageDevice: VcHostStorageDeviceInfo;
		userAccount: VcHostAccountSpec[];
		usergroupAccount: VcHostAccountSpec[];

		constructor();
	}

	declare class VcHostConfigSummary
	{
		agentVmDatastore: VcDatastore;
		agentVmNetwork: VcNetwork;
		faultToleranceEnabled: boolean;
		featureVersion: VcHostFeatureVersionInfo[];
		name: String;
		port: Number;
		product: VcAboutInfo;
		sslThumbprint: String;
		vmotionEnabled: boolean;

		constructor();
	}

	declare class VcHostConnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostConnectInfo
	{
		capability: VcHostCapability;
		clusterSupported: boolean;
		datastore: VcHostDatastoreConnectInfo[];
		host: VcHostListSummary;
		inDasCluster: boolean;
		license: VcHostLicenseConnectInfo;
		network: VcHostConnectInfoNetworkInfo[];
		serverIp: String;
		vimAccountNameRequired: boolean;
		vm: VcVirtualMachineSummary[];

		constructor();
	}

	declare class VcHostConnectInfoNetworkInfo
	{
		summary: VcNetworkSummary;

		constructor();
	}

	declare class VcHostConnectionLostEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostConnectSpec
	{
		force: boolean;
		hostGateway: VcHostGatewaySpec;
		hostName: String;
		lockdownMode: VcHostLockdownMode;
		managementIp: String;
		password: String;
		port: Number;
		sslThumbprint: String;
		userName: String;
		vimAccountName: String;
		vimAccountPassword: String;
		vmFolder: VcFolder;

		constructor();
	}

	declare class VcHostCpuIdInfo
	{
		eax: String;
		ebx: String;
		ecx: String;
		edx: String;
		level: Number;
		vendor: String;

		constructor();
	}

	declare class VcHostCpuInfo
	{
		hz: Number;
		numCpuCores: Number;
		numCpuPackages: Number;
		numCpuThreads: Number;

		constructor();
	}

	declare class VcHostCpuPackage
	{
		busHz: Number;
		cpuFeature: VcHostCpuIdInfo[];
		description: String;
		hz: Number;
		index: Number;
		threadId: Number[];
		vendor: String;

		constructor();
	}

	interface VcHostCpuPackageVendor
	{
		readonly _amd: String;
		readonly _intel: String;
		readonly _unknown: String;
		readonly amd: VcHostCpuPackageVendor;
		readonly id: String;
		readonly intel: VcHostCpuPackageVendor;
		readonly name: String;
		readonly unknown: VcHostCpuPackageVendor;
		readonly value: String;

		fromString(value?: String): VcHostCpuPackageVendor;
	}

	interface VcHostCpuPackageVendorConstructor {
		new(value?:any): VcHostCpuPackageVendor;
		readonly prototype: VcHostCpuPackageVendor;
	}

	declare const VcHostCpuPackageVendor: VcHostCpuPackageVendorConstructor;

	declare class VcHostCpuPowerManagementInfo
	{
		currentPolicy: String;
		hardwareSupport: String;

		constructor();
	}

	interface VcHostCpuPowerManagementInfoPolicyType
	{
		readonly _dynamicPolicy: String;
		readonly _off: String;
		readonly _staticPolicy: String;
		readonly dynamicPolicy: VcHostCpuPowerManagementInfoPolicyType;
		readonly id: String;
		readonly name: String;
		readonly off: VcHostCpuPowerManagementInfoPolicyType;
		readonly staticPolicy: VcHostCpuPowerManagementInfoPolicyType;
		readonly value: String;

		fromString(value?: String): VcHostCpuPowerManagementInfoPolicyType;
	}

	interface VcHostCpuPowerManagementInfoPolicyTypeConstructor {
		new(value?:any): VcHostCpuPowerManagementInfoPolicyType;
		readonly prototype: VcHostCpuPowerManagementInfoPolicyType;
	}

	declare const VcHostCpuPowerManagementInfoPolicyType: VcHostCpuPowerManagementInfoPolicyTypeConstructor;

	interface VcHostCpuSchedulerSystem
	{
		availableField: VcCustomFieldDef[];
		hyperthreadInfo: VcHostHyperThreadScheduleInfo;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		disableHyperThreading(): void;
		enableHyperThreading(): void;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcHostCpuSchedulerSystem: VcHostCpuSchedulerSystem;

	declare class VcHostDasDisabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostDasDisablingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostDasEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostDasEnablingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostDasErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		reason: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostDasErrorEventHostDasErrorReason
	{
		readonly _agentFailed: String;
		readonly _agentShutdown: String;
		readonly _communicationInitFailed: String;
		readonly _configFailed: String;
		readonly _healthCheckScriptFailed: String;
		readonly _isolationAddressUnpingable: String;
		readonly _other: String;
		readonly _timeout: String;
		readonly agentFailed: VcHostDasErrorEventHostDasErrorReason;
		readonly agentShutdown: VcHostDasErrorEventHostDasErrorReason;
		readonly communicationInitFailed: VcHostDasErrorEventHostDasErrorReason;
		readonly configFailed: VcHostDasErrorEventHostDasErrorReason;
		readonly healthCheckScriptFailed: VcHostDasErrorEventHostDasErrorReason;
		readonly id: String;
		readonly isolationAddressUnpingable: VcHostDasErrorEventHostDasErrorReason;
		readonly name: String;
		readonly other: VcHostDasErrorEventHostDasErrorReason;
		readonly timeout: VcHostDasErrorEventHostDasErrorReason;
		readonly value: String;

		fromString(value?: String): VcHostDasErrorEventHostDasErrorReason;
	}

	interface VcHostDasErrorEventHostDasErrorReasonConstructor {
		new(value?:any): VcHostDasErrorEventHostDasErrorReason;
		readonly prototype: VcHostDasErrorEventHostDasErrorReason;
	}

	declare const VcHostDasErrorEventHostDasErrorReason: VcHostDasErrorEventHostDasErrorReasonConstructor;

	declare class VcHostDasEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostDasOkEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostDatastoreBrowser
	{
		datastore: VcDatastore[];
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		supportedType: VcFileQuery[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteFile(datastorePath?: String): void;
		searchDatastore_Task(datastorePath?: String, searchSpec?: VcHostDatastoreBrowserSearchSpec): VcTask;
		searchDatastoreSubFolders_Task(datastorePath?: String, searchSpec?: VcHostDatastoreBrowserSearchSpec): VcTask;
	}

	declare const VcHostDatastoreBrowser: VcHostDatastoreBrowser;

	declare class VcHostDatastoreBrowserSearchResults
	{
		datastore: VcDatastore;
		file: VcFileInfo[];
		folderPath: String;

		constructor();
	}

	declare class VcHostDatastoreBrowserSearchSpec
	{
		details: VcFileQueryFlags;
		matchPattern: String[];
		query: VcFileQuery[];
		searchCaseInsensitive: boolean;
		sortFoldersFirst: boolean;

		constructor();
	}

	declare class VcHostDatastoreConnectInfo
	{
		summary: VcDatastoreSummary;

		constructor();
	}

	declare class VcHostDatastoreExistsConnectInfo
	{
		newDatastoreName: String;
		summary: VcDatastoreSummary;

		constructor();
	}

	declare class VcHostDatastoreNameConflictConnectInfo
	{
		newDatastoreName: String;
		summary: VcDatastoreSummary;

		constructor();
	}

	interface VcHostDatastoreSystem
	{
		capabilities: VcHostDatastoreSystemCapabilities;
		datastore: VcDatastore[];
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		configureDatastorePrincipal(userName?: String, password?: String): void;
		createLocalDatastore(name?: String, path?: String): VcDatastore;
		createNasDatastore(spec?: VcHostNasVolumeSpec): VcDatastore;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVmfsDatastore(spec?: VcVmfsDatastoreCreateSpec): VcDatastore;
		createVvolDatastore(spec?: VcHostDatastoreSystemVvolDatastoreSpec): VcDatastore;
		expandVmfsDatastore(datastore?: VcDatastore, spec?: VcVmfsDatastoreExpandSpec): VcDatastore;
		extendVmfsDatastore(datastore?: VcDatastore, spec?: VcVmfsDatastoreExtendSpec): VcDatastore;
		queryAvailableDisksForVmfs(datastore?: VcDatastore): VcHostScsiDisk[];
		queryUnresolvedVmfsVolumes(): VcHostUnresolvedVmfsVolume[];
		queryVmfsDatastoreCreateOptions(devicePath?: String, vmfsMajorVersion?: Number): VcVmfsDatastoreOption[];
		queryVmfsDatastoreExpandOptions(datastore?: VcDatastore): VcVmfsDatastoreOption[];
		queryVmfsDatastoreExtendOptions(datastore?: VcDatastore, devicePath?: String, suppressExpandCandidates?: boolean): VcVmfsDatastoreOption[];
		removeDatastore(datastore?: VcDatastore): void;
		removeDatastoreEx_Task(datastore?: VcDatastore[]): VcTask;
		resignatureUnresolvedVmfsVolume_Task(resolutionSpec?: VcHostUnresolvedVmfsResignatureSpec): VcTask;
		updateLocalSwapDatastore(datastore?: VcDatastore): void;
	}

	declare const VcHostDatastoreSystem: VcHostDatastoreSystem;

	declare class VcHostDatastoreSystemCapabilities
	{
		localDatastoreSupported: boolean;
		nfsMountCreationRequired: boolean;
		nfsMountCreationSupported: boolean;
		vmfsExtentExpansionSupported: boolean;

		constructor();
	}

	declare class VcHostDatastoreSystemDatastoreResult
	{
		fault: VcLocalizedMethodFault;
		key: VcDatastore;

		constructor();
	}

	declare class VcHostDatastoreSystemVvolDatastoreSpec
	{
		name: String;
		scId: String;

		constructor();
	}

	declare class VcHostDateTimeConfig
	{
		ntpConfig: VcHostNtpConfig;
		timeZone: String;

		constructor();
	}

	declare class VcHostDateTimeInfo
	{
		ntpConfig: VcHostNtpConfig;
		timeZone: VcHostDateTimeSystemTimeZone;

		constructor();
	}

	interface VcHostDateTimeSystem
	{
		dateTimeInfo: VcHostDateTimeInfo;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryAvailableTimeZones(): VcHostDateTimeSystemTimeZone[];
		queryDateTime(): Date;
		refreshDateTimeSystem(): void;
		updateDateTime(dateTime?: Date): void;
		updateDateTimeConfig(config?: VcHostDateTimeConfig): void;
	}

	declare const VcHostDateTimeSystem: VcHostDateTimeSystem;

	declare class VcHostDateTimeSystemTimeZone
	{
		description: String;
		gmtOffset: Number;
		key: String;
		name: String;

		constructor();
	}

	declare class VcHostDevice
	{
		deviceName: String;
		deviceType: String;

		constructor();
	}

	declare class VcHostDhcpService
	{
		key: String;
		spec: VcHostDhcpServiceSpec;

		constructor();
	}

	declare class VcHostDhcpServiceConfig
	{
		changeOperation: String;
		key: String;
		spec: VcHostDhcpServiceSpec;

		constructor();
	}

	declare class VcHostDhcpServiceSpec
	{
		defaultLeaseDuration: Number;
		ipSubnetAddr: String;
		ipSubnetMask: String;
		leaseBeginIp: String;
		leaseEndIp: String;
		maxLeaseDuration: Number;
		unlimitedLease: boolean;
		virtualSwitch: String;

		constructor();
	}

	declare class VcHostDiagnosticPartition
	{
		diagnosticType: String;
		id: VcHostScsiDiskPartition;
		slots: Number;
		storageType: String;

		constructor();
	}

	declare class VcHostDiagnosticPartitionCreateDescription
	{
		diskUuid: String;
		layout: VcHostDiskPartitionLayout;
		spec: VcHostDiagnosticPartitionCreateSpec;

		constructor();
	}

	declare class VcHostDiagnosticPartitionCreateOption
	{
		diagnosticType: String;
		disk: VcHostScsiDisk;
		storageType: String;

		constructor();
	}

	declare class VcHostDiagnosticPartitionCreateSpec
	{
		active: boolean;
		diagnosticType: String;
		id: VcHostScsiDiskPartition;
		partition: VcHostDiskPartitionSpec;
		storageType: String;

		constructor();
	}

	interface VcHostDiagnosticSystem
	{
		activePartition: VcHostDiagnosticPartition;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createDiagnosticPartition(spec?: VcHostDiagnosticPartitionCreateSpec): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryAvailablePartition(): VcHostDiagnosticPartition[];
		queryPartitionCreateDesc(diskUuid?: String, diagnosticType?: String): VcHostDiagnosticPartitionCreateDescription;
		queryPartitionCreateOptions(storageType?: String, diagnosticType?: String): VcHostDiagnosticPartitionCreateOption[];
		selectActivePartition(partition?: VcHostScsiDiskPartition): void;
	}

	declare const VcHostDiagnosticSystem: VcHostDiagnosticSystem;

	declare class VcHostDigestInfo
	{
		digestMethod: String;
		digestValue: Number[];
		objectName: String;

		constructor();
	}

	interface VcHostDigestInfoDigestMethodType
	{
		readonly _MD5: String;
		readonly _SHA1: String;
		readonly id: String;
		readonly MD5: VcHostDigestInfoDigestMethodType;
		readonly name: String;
		readonly SHA1: VcHostDigestInfoDigestMethodType;
		readonly value: String;

		fromString(value?: String): VcHostDigestInfoDigestMethodType;
	}

	interface VcHostDigestInfoDigestMethodTypeConstructor {
		new(value?:any): VcHostDigestInfoDigestMethodType;
		readonly prototype: VcHostDigestInfoDigestMethodType;
	}

	declare const VcHostDigestInfoDigestMethodType: VcHostDigestInfoDigestMethodTypeConstructor;

	interface VcHostDirectoryStore
	{
		readonly id: String;
		info: VcHostAuthenticationStoreInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostDirectoryStore: VcHostDirectoryStore;

	declare class VcHostDirectoryStoreInfo
	{
		enabled: boolean;

		constructor();
	}

	declare class VcHostDisconnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostDisconnectedEventReasonCode
	{
		readonly _agentOutOfDate: String;
		readonly _agentUpgrade: String;
		readonly _insufficientLicenses: String;
		readonly _licenseExpired: String;
		readonly _passwordDecryptFailure: String;
		readonly _sslThumbprintVerifyFailed: String;
		readonly _unknown: String;
		readonly _userRequest: String;
		readonly _vcVRAMCapacityExceeded: String;
		readonly agentOutOfDate: VcHostDisconnectedEventReasonCode;
		readonly agentUpgrade: VcHostDisconnectedEventReasonCode;
		readonly id: String;
		readonly insufficientLicenses: VcHostDisconnectedEventReasonCode;
		readonly licenseExpired: VcHostDisconnectedEventReasonCode;
		readonly name: String;
		readonly passwordDecryptFailure: VcHostDisconnectedEventReasonCode;
		readonly sslThumbprintVerifyFailed: VcHostDisconnectedEventReasonCode;
		readonly unknown: VcHostDisconnectedEventReasonCode;
		readonly userRequest: VcHostDisconnectedEventReasonCode;
		readonly value: String;
		readonly vcVRAMCapacityExceeded: VcHostDisconnectedEventReasonCode;

		fromString(value?: String): VcHostDisconnectedEventReasonCode;
	}

	interface VcHostDisconnectedEventReasonCodeConstructor {
		new(value?:any): VcHostDisconnectedEventReasonCode;
		readonly prototype: VcHostDisconnectedEventReasonCode;
	}

	declare const VcHostDisconnectedEventReasonCode: VcHostDisconnectedEventReasonCodeConstructor;

	declare class VcHostDiskConfigurationResult
	{
		devicePath: String;
		fault: VcLocalizedMethodFault;
		success: boolean;

		constructor();
	}

	declare class VcHostDiskDimensions
	{

		constructor();
	}

	declare class VcHostDiskDimensionsChs
	{
		cylinder: Number;
		head: Number;
		sector: Number;

		constructor();
	}

	declare class VcHostDiskDimensionsLba
	{
		block: Number;
		blockSize: Number;

		constructor();
	}

	declare class VcHostDiskMappingInfo
	{
		exclusive: boolean;
		name: String;
		physicalPartition: VcHostDiskMappingPartitionInfo;

		constructor();
	}

	declare class VcHostDiskMappingOption
	{
		name: String;
		physicalPartition: VcHostDiskMappingPartitionOption[];

		constructor();
	}

	declare class VcHostDiskMappingPartitionInfo
	{
		capacityInKb: Number;
		fileSystem: String;
		name: String;

		constructor();
	}

	declare class VcHostDiskMappingPartitionOption
	{
		capacityInKb: Number;
		fileSystem: String;
		name: String;

		constructor();
	}

	declare class VcHostDiskPartitionAttributes
	{
		attributes: Number;
		endSector: Number;
		guid: String;
		logical: boolean;
		partition: Number;
		partitionAlignment: Number;
		startSector: Number;
		type: String;

		constructor();
	}

	declare class VcHostDiskPartitionBlockRange
	{
		end: VcHostDiskDimensionsLba;
		partition: Number;
		start: VcHostDiskDimensionsLba;
		type: String;

		constructor();
	}

	declare class VcHostDiskPartitionInfo
	{
		deviceName: String;
		layout: VcHostDiskPartitionLayout;
		spec: VcHostDiskPartitionSpec;

		constructor();
	}

	interface VcHostDiskPartitionInfoPartitionFormat
	{
		readonly _gpt: String;
		readonly _mbr: String;
		readonly _unknown: String;
		readonly gpt: VcHostDiskPartitionInfoPartitionFormat;
		readonly id: String;
		readonly mbr: VcHostDiskPartitionInfoPartitionFormat;
		readonly name: String;
		readonly unknown: VcHostDiskPartitionInfoPartitionFormat;
		readonly value: String;

		fromString(value?: String): VcHostDiskPartitionInfoPartitionFormat;
	}

	interface VcHostDiskPartitionInfoPartitionFormatConstructor {
		new(value?:any): VcHostDiskPartitionInfoPartitionFormat;
		readonly prototype: VcHostDiskPartitionInfoPartitionFormat;
	}

	declare const VcHostDiskPartitionInfoPartitionFormat: VcHostDiskPartitionInfoPartitionFormatConstructor;

	interface VcHostDiskPartitionInfoType
	{
		readonly _extended: String;
		readonly _linuxNative: String;
		readonly _linuxSwap: String;
		readonly _none: String;
		readonly _ntfs: String;
		readonly _vffs: String;
		readonly _vmfs: String;
		readonly _vmkDiagnostic: String;
		readonly extended: VcHostDiskPartitionInfoType;
		readonly id: String;
		readonly linuxNative: VcHostDiskPartitionInfoType;
		readonly linuxSwap: VcHostDiskPartitionInfoType;
		readonly name: String;
		readonly none: VcHostDiskPartitionInfoType;
		readonly ntfs: VcHostDiskPartitionInfoType;
		readonly value: String;
		readonly vffs: VcHostDiskPartitionInfoType;
		readonly vmfs: VcHostDiskPartitionInfoType;
		readonly vmkDiagnostic: VcHostDiskPartitionInfoType;

		fromString(value?: String): VcHostDiskPartitionInfoType;
	}

	interface VcHostDiskPartitionInfoTypeConstructor {
		new(value?:any): VcHostDiskPartitionInfoType;
		readonly prototype: VcHostDiskPartitionInfoType;
	}

	declare const VcHostDiskPartitionInfoType: VcHostDiskPartitionInfoTypeConstructor;

	declare class VcHostDiskPartitionLayout
	{
		partition: VcHostDiskPartitionBlockRange[];
		total: VcHostDiskDimensionsLba;

		constructor();
	}

	declare class VcHostDiskPartitionSpec
	{
		chs: VcHostDiskDimensionsChs;
		partition: VcHostDiskPartitionAttributes[];
		partitionFormat: String;
		totalSectors: Number;

		constructor();
	}

	declare class VcHostDnsConfig
	{
		address: String[];
		dhcp: boolean;
		domainName: String;
		hostName: String;
		searchDomain: String[];
		virtualNicDevice: String;

		constructor();
	}

	declare class VcHostDnsConfigSpec
	{
		address: String[];
		dhcp: boolean;
		domainName: String;
		hostName: String;
		searchDomain: String[];
		virtualNicConnection: VcHostVirtualNicConnection;
		virtualNicDevice: String;

		constructor();
	}

	declare class VcHostDVPortEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		eventType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostDVPortEventEventCode
	{
		readonly _blocked: String;
		readonly _connected: String;
		readonly _created: String;
		readonly _deleted: String;
		readonly _disconnected: String;
		readonly _joinedPortgroup: String;
		readonly _leftPortgroup: String;
		readonly _linkdown: String;
		readonly _linkup: String;
		readonly _reconfigured: String;
		readonly _unblocked: String;
		readonly blocked: VcHostDVPortEventEventCode;
		readonly connected: VcHostDVPortEventEventCode;
		readonly created: VcHostDVPortEventEventCode;
		readonly deleted: VcHostDVPortEventEventCode;
		readonly disconnected: VcHostDVPortEventEventCode;
		readonly id: String;
		readonly joinedPortgroup: VcHostDVPortEventEventCode;
		readonly leftPortgroup: VcHostDVPortEventEventCode;
		readonly linkdown: VcHostDVPortEventEventCode;
		readonly linkup: VcHostDVPortEventEventCode;
		readonly name: String;
		readonly reconfigured: VcHostDVPortEventEventCode;
		readonly unblocked: VcHostDVPortEventEventCode;
		readonly value: String;

		fromString(value?: String): VcHostDVPortEventEventCode;
	}

	interface VcHostDVPortEventEventCodeConstructor {
		new(value?:any): VcHostDVPortEventEventCode;
		readonly prototype: VcHostDVPortEventEventCode;
	}

	declare const VcHostDVPortEventEventCode: VcHostDVPortEventEventCodeConstructor;

	declare class VcHostEnableAdminFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		permissions: VcPermission[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostEsxAgentHostManager
	{
		configInfo: VcHostEsxAgentHostManagerConfigInfo;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		esxAgentHostManagerUpdateConfig(configInfo?: VcHostEsxAgentHostManagerConfigInfo): void;
	}

	declare const VcHostEsxAgentHostManager: VcHostEsxAgentHostManager;

	declare class VcHostEsxAgentHostManagerConfigInfo
	{
		agentVmDatastore: VcDatastore;
		agentVmNetwork: VcNetwork;

		constructor();
	}

	declare class VcHostEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostEventArgument
	{
		host: VcHostSystem;
		name: String;

		constructor();
	}

	declare class VcHostExtraNetworksEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ips: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostFaultToleranceManagerComponentHealthInfo
	{
		isNetworkHealthy: boolean;
		isStorageHealthy: boolean;

		constructor();
	}

	declare class VcHostFeatureCapability
	{
		featureName: String;
		key: String;
		value: String;

		constructor();
	}

	declare class VcHostFeatureMask
	{
		featureName: String;
		key: String;
		value: String;

		constructor();
	}

	declare class VcHostFeatureVersionInfo
	{
		key: String;
		value: String;

		constructor();
	}

	interface VcHostFeatureVersionKey
	{
		readonly _faultTolerance: String;
		readonly faultTolerance: VcHostFeatureVersionKey;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostFeatureVersionKey;
	}

	interface VcHostFeatureVersionKeyConstructor {
		new(value?:any): VcHostFeatureVersionKey;
		readonly prototype: VcHostFeatureVersionKey;
	}

	declare const VcHostFeatureVersionKey: VcHostFeatureVersionKeyConstructor;

	declare class VcHostFibreChannelHba
	{
		bus: Number;
		device: String;
		driver: String;
		key: String;
		model: String;
		nodeWorldWideName: Number;
		readonly nodeWorldWideNameHex: String;
		pci: String;
		portType: VcFibreChannelPortType;
		portWorldWideName: Number;
		readonly portWorldWideNameHex: String;
		speed: Number;
		status: String;

		constructor();
	}

	declare class VcHostFibreChannelOverEthernetHba
	{
		bus: Number;
		device: String;
		driver: String;
		isSoftwareFcoe: boolean;
		key: String;
		linkInfo: VcHostFibreChannelOverEthernetHbaLinkInfo;
		markedForRemoval: boolean;
		model: String;
		nodeWorldWideName: Number;
		pci: String;
		portType: VcFibreChannelPortType;
		portWorldWideName: Number;
		speed: Number;
		status: String;
		underlyingNic: String;

		constructor();
	}

	declare class VcHostFibreChannelOverEthernetHbaLinkInfo
	{
		fcfMac: String;
		vlanId: Number;
		vnportMac: String;

		constructor();
	}

	declare class VcHostFibreChannelOverEthernetTargetTransport
	{
		fcfMac: String;
		nodeWorldWideName: Number;
		portWorldWideName: Number;
		vlanId: Number;
		vnportMac: String;

		constructor();
	}

	declare class VcHostFibreChannelTargetTransport
	{
		nodeWorldWideName: Number;
		portWorldWideName: Number;

		constructor();
	}

	declare class VcHostFileAccess
	{
		what: String;
		who: String;

		constructor();
	}

	declare class VcHostFileSystemMountInfo
	{
		mountInfo: VcHostMountInfo;
		volume: VcHostFileSystemVolume;
		vStorageSupport: String;

		constructor();
	}

	declare class VcHostFileSystemVolume
	{
		capacity: Number;
		name: String;
		type: String;

		constructor();
	}

	interface VcHostFileSystemVolumeFileSystemType
	{
		readonly _CIFS: String;
		readonly _NFS: String;
		readonly _NFS41: String;
		readonly _OTHER: String;
		readonly _VFFS: String;
		readonly _VMFS: String;
		readonly _vsan: String;
		readonly _VVOL: String;
		readonly CIFS: VcHostFileSystemVolumeFileSystemType;
		readonly id: String;
		readonly name: String;
		readonly NFS: VcHostFileSystemVolumeFileSystemType;
		readonly NFS41: VcHostFileSystemVolumeFileSystemType;
		readonly OTHER: VcHostFileSystemVolumeFileSystemType;
		readonly value: String;
		readonly VFFS: VcHostFileSystemVolumeFileSystemType;
		readonly VMFS: VcHostFileSystemVolumeFileSystemType;
		readonly vsan: VcHostFileSystemVolumeFileSystemType;
		readonly VVOL: VcHostFileSystemVolumeFileSystemType;

		fromString(value?: String): VcHostFileSystemVolumeFileSystemType;
	}

	interface VcHostFileSystemVolumeFileSystemTypeConstructor {
		new(value?:any): VcHostFileSystemVolumeFileSystemType;
		readonly prototype: VcHostFileSystemVolumeFileSystemType;
	}

	declare const VcHostFileSystemVolumeFileSystemType: VcHostFileSystemVolumeFileSystemTypeConstructor;

	declare class VcHostFileSystemVolumeInfo
	{
		mountInfo: VcHostFileSystemMountInfo[];
		volumeTypeList: String[];

		constructor();
	}

	declare class VcHostFirewallConfig
	{
		defaultBlockingPolicy: VcHostFirewallDefaultPolicy;
		rule: VcHostFirewallConfigRuleSetConfig[];

		constructor();
	}

	declare class VcHostFirewallConfigRuleSetConfig
	{
		allowedHosts: VcHostFirewallRulesetIpList;
		enabled: boolean;
		rulesetId: String;

		constructor();
	}

	declare class VcHostFirewallDefaultPolicy
	{
		incomingBlocked: boolean;
		outgoingBlocked: boolean;

		constructor();
	}

	declare class VcHostFirewallInfo
	{
		defaultPolicy: VcHostFirewallDefaultPolicy;
		ruleset: VcHostFirewallRuleset[];

		constructor();
	}

	declare class VcHostFirewallRule
	{
		direction: VcHostFirewallRuleDirection;
		endPort: Number;
		port: Number;
		portType: VcHostFirewallRulePortType;
		protocol: String;

		constructor();
	}

	interface VcHostFirewallRuleDirection
	{
		readonly _inbound: String;
		readonly _outbound: String;
		readonly id: String;
		readonly inbound: VcHostFirewallRuleDirection;
		readonly name: String;
		readonly outbound: VcHostFirewallRuleDirection;
		readonly value: String;

		fromString(value?: String): VcHostFirewallRuleDirection;
	}

	interface VcHostFirewallRuleDirectionConstructor {
		new(value?:any): VcHostFirewallRuleDirection;
		readonly prototype: VcHostFirewallRuleDirection;
	}

	declare const VcHostFirewallRuleDirection: VcHostFirewallRuleDirectionConstructor;

	interface VcHostFirewallRulePortType
	{
		readonly _dst: String;
		readonly _src: String;
		readonly dst: VcHostFirewallRulePortType;
		readonly id: String;
		readonly name: String;
		readonly src: VcHostFirewallRulePortType;
		readonly value: String;

		fromString(value?: String): VcHostFirewallRulePortType;
	}

	interface VcHostFirewallRulePortTypeConstructor {
		new(value?:any): VcHostFirewallRulePortType;
		readonly prototype: VcHostFirewallRulePortType;
	}

	declare const VcHostFirewallRulePortType: VcHostFirewallRulePortTypeConstructor;

	interface VcHostFirewallRuleProtocol
	{
		readonly _tcp: String;
		readonly _udp: String;
		readonly id: String;
		readonly name: String;
		readonly tcp: VcHostFirewallRuleProtocol;
		readonly udp: VcHostFirewallRuleProtocol;
		readonly value: String;

		fromString(value?: String): VcHostFirewallRuleProtocol;
	}

	interface VcHostFirewallRuleProtocolConstructor {
		new(value?:any): VcHostFirewallRuleProtocol;
		readonly prototype: VcHostFirewallRuleProtocol;
	}

	declare const VcHostFirewallRuleProtocol: VcHostFirewallRuleProtocolConstructor;

	declare class VcHostFirewallRuleset
	{
		allowedHosts: VcHostFirewallRulesetIpList;
		enabled: boolean;
		key: String;
		label: String;
		required: boolean;
		rule: VcHostFirewallRule[];
		service: String;

		constructor();
	}

	declare class VcHostFirewallRulesetIpList
	{
		allIp: boolean;
		ipAddress: String[];
		ipNetwork: VcHostFirewallRulesetIpNetwork[];

		constructor();
	}

	declare class VcHostFirewallRulesetIpNetwork
	{
		network: String;
		prefixLength: Number;

		constructor();
	}

	declare class VcHostFirewallRulesetRulesetSpec
	{
		allowedHosts: VcHostFirewallRulesetIpList;

		constructor();
	}

	interface VcHostFirewallSystem
	{
		availableField: VcCustomFieldDef[];
		firewallInfo: VcHostFirewallInfo;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		disableRuleset(id?: String): void;
		enableRuleset(id?: String): void;
		refreshFirewall(): void;
		setCustomValue(key?: String, value?: String): void;
		updateDefaultPolicy(defaultPolicy?: VcHostFirewallDefaultPolicy): void;
		updateRuleset(id?: String, spec?: VcHostFirewallRulesetRulesetSpec): void;
	}

	declare const VcHostFirewallSystem: VcHostFirewallSystem;

	interface VcHostFirmwareSystem
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		backupFirmwareConfiguration(): String;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryFirmwareConfigUploadURL(): String;
		resetFirmwareToFactoryDefaults(): void;
		restoreFirmwareConfiguration(force?: boolean): void;
	}

	declare const VcHostFirmwareSystem: VcHostFirmwareSystem;

	declare class VcHostFlagInfo
	{
		backgroundSnapshotsEnabled: boolean;

		constructor();
	}

	declare class VcHostForceMountedInfo
	{
		mounted: boolean;
		persist: boolean;

		constructor();
	}

	declare class VcHostGatewaySpec
	{
		gatewayId: String;
		gatewayType: String;
		hostAuthParams: VcKeyValue[];
		trustVerificationToken: String;

		constructor();
	}

	declare class VcHostGetShortNameFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostGraphicsInfo
	{
		deviceName: String;
		graphicsType: String;
		memorySizeInKB: Number;
		pciId: String;
		vendorName: String;
		vm: VcVirtualMachine[];

		constructor();
	}

	interface VcHostGraphicsInfoGraphicsType
	{
		readonly _basic: String;
		readonly _direct: String;
		readonly _shared: String;
		readonly basic: VcHostGraphicsInfoGraphicsType;
		readonly direct: VcHostGraphicsInfoGraphicsType;
		readonly id: String;
		readonly name: String;
		readonly shared: VcHostGraphicsInfoGraphicsType;
		readonly value: String;

		fromString(value?: String): VcHostGraphicsInfoGraphicsType;
	}

	interface VcHostGraphicsInfoGraphicsTypeConstructor {
		new(value?:any): VcHostGraphicsInfoGraphicsType;
		readonly prototype: VcHostGraphicsInfoGraphicsType;
	}

	declare const VcHostGraphicsInfoGraphicsType: VcHostGraphicsInfoGraphicsTypeConstructor;

	interface VcHostGraphicsManager
	{
		availableField: VcCustomFieldDef[];
		graphicsInfo: VcHostGraphicsInfo[];
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		sharedPassthruGpuTypes: String[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		isSharedGraphicsActive(): boolean;
		refreshGraphicsManager(): void;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcHostGraphicsManager: VcHostGraphicsManager;

	declare class VcHostHardwareElementInfo
	{
		name: String;
		status: VcElementDescription;

		constructor();
	}

	interface VcHostHardwareElementStatus
	{
		readonly _Green: String;
		readonly _Red: String;
		readonly _Unknown: String;
		readonly _Yellow: String;
		readonly Green: VcHostHardwareElementStatus;
		readonly id: String;
		readonly name: String;
		readonly Red: VcHostHardwareElementStatus;
		readonly Unknown: VcHostHardwareElementStatus;
		readonly value: String;
		readonly Yellow: VcHostHardwareElementStatus;

		fromString(value?: String): VcHostHardwareElementStatus;
	}

	interface VcHostHardwareElementStatusConstructor {
		new(value?:any): VcHostHardwareElementStatus;
		readonly prototype: VcHostHardwareElementStatus;
	}

	declare const VcHostHardwareElementStatus: VcHostHardwareElementStatusConstructor;

	declare class VcHostHardwareInfo
	{
		biosInfo: VcHostBIOSInfo;
		cpuFeature: VcHostCpuIdInfo[];
		cpuInfo: VcHostCpuInfo;
		cpuPkg: VcHostCpuPackage[];
		cpuPowerManagementInfo: VcHostCpuPowerManagementInfo;
		memorySize: Number;
		numaInfo: VcHostNumaInfo;
		pciDevice: VcHostPciDevice[];
		reliableMemoryInfo: VcHostReliableMemoryInfo;
		smcPresent: boolean;
		systemInfo: VcHostSystemInfo;

		constructor();
	}

	declare class VcHostHardwareStatusInfo
	{
		cpuStatusInfo: VcHostHardwareElementInfo[];
		memoryStatusInfo: VcHostHardwareElementInfo[];
		storageStatusInfo: VcHostStorageElementInfo[];

		constructor();
	}

	declare class VcHostHardwareSummary
	{
		cpuMhz: Number;
		cpuModel: String;
		memorySize: Number;
		model: String;
		numCpuCores: Number;
		numCpuPkgs: Number;
		numCpuThreads: Number;
		numHBAs: Number;
		numNics: Number;
		otherIdentifyingInfo: VcHostSystemIdentificationInfo[];
		uuid: String;
		vendor: String;

		constructor();
	}

	interface VcHostHasComponentFailureHostComponentType
	{
		readonly _Datastore: String;
		readonly Datastore: VcHostHasComponentFailureHostComponentType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostHasComponentFailureHostComponentType;
	}

	interface VcHostHasComponentFailureHostComponentTypeConstructor {
		new(value?:any): VcHostHasComponentFailureHostComponentType;
		readonly prototype: VcHostHasComponentFailureHostComponentType;
	}

	declare const VcHostHasComponentFailureHostComponentType: VcHostHasComponentFailureHostComponentTypeConstructor;

	interface VcHostHealthStatusSystem
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		runtime: VcHealthSystemRuntime;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		refreshHealthStatusSystem(): void;
		resetSystemHealthInfo(): void;
	}

	declare const VcHostHealthStatusSystem: VcHostHealthStatusSystem;

	declare class VcHostHostBusAdapter
	{
		bus: Number;
		device: String;
		driver: String;
		key: String;
		model: String;
		pci: String;
		status: String;

		constructor();
	}

	interface VcHostHostUpdateProxyManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureHostUpdateProxy(configInfo?: VcHostUpdateProxyConfigInfo): void;
		retrieveHostUpdateProxyConfig(): VcHostUpdateProxyConfigInfo;
	}

	declare const VcHostHostUpdateProxyManager: VcHostHostUpdateProxyManager;

	declare class VcHostHyperThreadScheduleInfo
	{
		active: boolean;
		available: boolean;
		config: boolean;

		constructor();
	}

	interface VcHostImageAcceptanceLevel
	{
		readonly _community: String;
		readonly _partner: String;
		readonly _vmware_accepted: String;
		readonly _vmware_certified: String;
		readonly community: VcHostImageAcceptanceLevel;
		readonly id: String;
		readonly name: String;
		readonly partner: VcHostImageAcceptanceLevel;
		readonly value: String;
		readonly vmware_accepted: VcHostImageAcceptanceLevel;
		readonly vmware_certified: VcHostImageAcceptanceLevel;

		fromString(value?: String): VcHostImageAcceptanceLevel;
	}

	interface VcHostImageAcceptanceLevelConstructor {
		new(value?:any): VcHostImageAcceptanceLevel;
		readonly prototype: VcHostImageAcceptanceLevel;
	}

	declare const VcHostImageAcceptanceLevel: VcHostImageAcceptanceLevelConstructor;

	interface VcHostImageConfigManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		hostImageConfigGetAcceptance(): String;
		hostImageConfigGetProfile(): VcHostImageProfileSummary;
		updateHostImageAcceptanceLevel(newAcceptanceLevel?: String): void;
	}

	declare const VcHostImageConfigManager: VcHostImageConfigManager;

	declare class VcHostImageProfileSummary
	{
		name: String;
		vendor: String;

		constructor();
	}

	declare class VcHostInAuditModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostIncompatibleForFaultToleranceReason
	{
		readonly _processor: String;
		readonly _product: String;
		readonly id: String;
		readonly name: String;
		readonly processor: VcHostIncompatibleForFaultToleranceReason;
		readonly product: VcHostIncompatibleForFaultToleranceReason;
		readonly value: String;

		fromString(value?: String): VcHostIncompatibleForFaultToleranceReason;
	}

	interface VcHostIncompatibleForFaultToleranceReasonConstructor {
		new(value?:any): VcHostIncompatibleForFaultToleranceReason;
		readonly prototype: VcHostIncompatibleForFaultToleranceReason;
	}

	declare const VcHostIncompatibleForFaultToleranceReason: VcHostIncompatibleForFaultToleranceReasonConstructor;

	interface VcHostIncompatibleForRecordReplayReason
	{
		readonly _processor: String;
		readonly _product: String;
		readonly id: String;
		readonly name: String;
		readonly processor: VcHostIncompatibleForRecordReplayReason;
		readonly product: VcHostIncompatibleForRecordReplayReason;
		readonly value: String;

		fromString(value?: String): VcHostIncompatibleForRecordReplayReason;
	}

	interface VcHostIncompatibleForRecordReplayReasonConstructor {
		new(value?:any): VcHostIncompatibleForRecordReplayReason;
		readonly prototype: VcHostIncompatibleForRecordReplayReason;
	}

	declare const VcHostIncompatibleForRecordReplayReason: VcHostIncompatibleForRecordReplayReasonConstructor;

	declare class VcHostInternetScsiHba
	{
		advancedOptions: VcHostInternetScsiHbaParamValue[];
		authenticationCapabilities: VcHostInternetScsiHbaAuthenticationCapabilities;
		authenticationProperties: VcHostInternetScsiHbaAuthenticationProperties;
		bus: Number;
		canBeDisabled: boolean;
		configuredSendTarget: VcHostInternetScsiHbaSendTarget[];
		configuredStaticTarget: VcHostInternetScsiHbaStaticTarget[];
		currentSpeedMb: Number;
		device: String;
		digestCapabilities: VcHostInternetScsiHbaDigestCapabilities;
		digestProperties: VcHostInternetScsiHbaDigestProperties;
		discoveryCapabilities: VcHostInternetScsiHbaDiscoveryCapabilities;
		discoveryProperties: VcHostInternetScsiHbaDiscoveryProperties;
		driver: String;
		ipCapabilities: VcHostInternetScsiHbaIPCapabilities;
		ipProperties: VcHostInternetScsiHbaIPProperties;
		iScsiAlias: String;
		iScsiName: String;
		isSoftwareBased: boolean;
		key: String;
		maxSpeedMb: Number;
		model: String;
		networkBindingSupport: VcHostInternetScsiHbaNetworkBindingSupportType;
		pci: String;
		status: String;
		supportedAdvancedOptions: VcOptionDef[];

		constructor();
	}

	declare class VcHostInternetScsiHbaAuthenticationCapabilities
	{
		chapAuthSettable: boolean;
		krb5AuthSettable: boolean;
		mutualChapSettable: boolean;
		spkmAuthSettable: boolean;
		srpAuthSettable: boolean;
		targetChapSettable: boolean;
		targetMutualChapSettable: boolean;

		constructor();
	}

	declare class VcHostInternetScsiHbaAuthenticationProperties
	{
		chapAuthEnabled: boolean;
		chapAuthenticationType: String;
		chapInherited: boolean;
		chapName: String;
		chapSecret: String;
		mutualChapAuthenticationType: String;
		mutualChapInherited: boolean;
		mutualChapName: String;
		mutualChapSecret: String;

		constructor();
	}

	interface VcHostInternetScsiHbaChapAuthenticationType
	{
		readonly _chapDiscouraged: String;
		readonly _chapPreferred: String;
		readonly _chapProhibited: String;
		readonly _chapRequired: String;
		readonly chapDiscouraged: VcHostInternetScsiHbaChapAuthenticationType;
		readonly chapPreferred: VcHostInternetScsiHbaChapAuthenticationType;
		readonly chapProhibited: VcHostInternetScsiHbaChapAuthenticationType;
		readonly chapRequired: VcHostInternetScsiHbaChapAuthenticationType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostInternetScsiHbaChapAuthenticationType;
	}

	interface VcHostInternetScsiHbaChapAuthenticationTypeConstructor {
		new(value?:any): VcHostInternetScsiHbaChapAuthenticationType;
		readonly prototype: VcHostInternetScsiHbaChapAuthenticationType;
	}

	declare const VcHostInternetScsiHbaChapAuthenticationType: VcHostInternetScsiHbaChapAuthenticationTypeConstructor;

	declare class VcHostInternetScsiHbaDigestCapabilities
	{
		dataDigestSettable: boolean;
		headerDigestSettable: boolean;
		targetDataDigestSettable: boolean;
		targetHeaderDigestSettable: boolean;

		constructor();
	}

	declare class VcHostInternetScsiHbaDigestProperties
	{
		dataDigestInherited: boolean;
		dataDigestType: String;
		headerDigestInherited: boolean;
		headerDigestType: String;

		constructor();
	}

	interface VcHostInternetScsiHbaDigestType
	{
		readonly _digestDiscouraged: String;
		readonly _digestPreferred: String;
		readonly _digestProhibited: String;
		readonly _digestRequired: String;
		readonly digestDiscouraged: VcHostInternetScsiHbaDigestType;
		readonly digestPreferred: VcHostInternetScsiHbaDigestType;
		readonly digestProhibited: VcHostInternetScsiHbaDigestType;
		readonly digestRequired: VcHostInternetScsiHbaDigestType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostInternetScsiHbaDigestType;
	}

	interface VcHostInternetScsiHbaDigestTypeConstructor {
		new(value?:any): VcHostInternetScsiHbaDigestType;
		readonly prototype: VcHostInternetScsiHbaDigestType;
	}

	declare const VcHostInternetScsiHbaDigestType: VcHostInternetScsiHbaDigestTypeConstructor;

	declare class VcHostInternetScsiHbaDiscoveryCapabilities
	{
		iSnsDiscoverySettable: boolean;
		sendTargetsDiscoverySettable: boolean;
		slpDiscoverySettable: boolean;
		staticTargetDiscoverySettable: boolean;

		constructor();
	}

	declare class VcHostInternetScsiHbaDiscoveryProperties
	{
		iSnsDiscoveryEnabled: boolean;
		iSnsDiscoveryMethod: String;
		iSnsHost: String;
		sendTargetsDiscoveryEnabled: boolean;
		slpDiscoveryEnabled: boolean;
		slpDiscoveryMethod: String;
		slpHost: String;
		staticTargetDiscoveryEnabled: boolean;

		constructor();
	}

	declare class VcHostInternetScsiHbaIPCapabilities
	{
		addressSettable: boolean;
		alternateDnsServerAddressSettable: boolean;
		arpRedirectSettable: boolean;
		defaultGatewaySettable: boolean;
		hostNameAsTargetAddress: boolean;
		ipConfigurationMethodSettable: boolean;
		ipv4EnableSettable: boolean;
		ipv6DefaultGatewaySettable: boolean;
		ipv6DhcpConfigurationSettable: boolean;
		ipv6EnableSettable: boolean;
		ipv6LinkLocalAutoConfigurationSettable: boolean;
		ipv6MaxStaticAddressesSupported: Number;
		ipv6PrefixLength: Number;
		ipv6PrefixLengthSettable: boolean;
		ipv6RouterAdvertisementConfigurationSettable: boolean;
		ipv6Supported: boolean;
		mtuSettable: boolean;
		nameAliasSettable: boolean;
		primaryDnsServerAddressSettable: boolean;
		subnetMaskSettable: boolean;

		constructor();
	}

	declare class VcHostInternetScsiHbaIPProperties
	{
		address: String;
		alternateDnsServerAddress: String;
		arpRedirectEnabled: boolean;
		defaultGateway: String;
		dhcpConfigurationEnabled: boolean;
		ipv4Enabled: boolean;
		ipv6Address: String;
		ipv6DefaultGateway: String;
		ipv6Enabled: boolean;
		ipv6properties: VcHostInternetScsiHbaIPv6Properties;
		ipv6SubnetMask: String;
		jumboFramesEnabled: boolean;
		mac: String;
		mtu: Number;
		primaryDnsServerAddress: String;
		subnetMask: String;

		constructor();
	}

	declare class VcHostInternetScsiHbaIPv6Properties
	{
		ipv6DefaultGateway: String;
		ipv6DhcpConfigurationEnabled: boolean;
		ipv6LinkLocalAutoConfigurationEnabled: boolean;
		ipv6RouterAdvertisementConfigurationEnabled: boolean;
		iscsiIpv6Address: VcHostInternetScsiHbaIscsiIpv6Address[];

		constructor();
	}

	declare class VcHostInternetScsiHbaIscsiIpv6Address
	{
		address: String;
		operation: String;
		origin: String;
		prefixLength: Number;

		constructor();
	}

	interface VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType
	{
		readonly _AutoConfigured: String;
		readonly _DHCP: String;
		readonly _Other: String;
		readonly _Static: String;
		readonly AutoConfigured: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly DHCP: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly id: String;
		readonly name: String;
		readonly Other: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly Static: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly value: String;

		fromString(value?: String): VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
	}

	interface VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationTypeConstructor {
		new(value?:any): VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly prototype: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
	}

	declare const VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType: VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationTypeConstructor;

	interface VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation
	{
		readonly _add: String;
		readonly _remove: String;
		readonly add: VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
		readonly id: String;
		readonly name: String;
		readonly remove: VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
		readonly value: String;

		fromString(value?: String): VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
	}

	interface VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperationConstructor {
		new(value?:any): VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
		readonly prototype: VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
	}

	declare const VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation: VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperationConstructor;

	interface VcHostInternetScsiHbaNetworkBindingSupportType
	{
		readonly _notsupported: String;
		readonly _optional: String;
		readonly _required: String;
		readonly id: String;
		readonly name: String;
		readonly notsupported: VcHostInternetScsiHbaNetworkBindingSupportType;
		readonly optional: VcHostInternetScsiHbaNetworkBindingSupportType;
		readonly required: VcHostInternetScsiHbaNetworkBindingSupportType;
		readonly value: String;

		fromString(value?: String): VcHostInternetScsiHbaNetworkBindingSupportType;
	}

	interface VcHostInternetScsiHbaNetworkBindingSupportTypeConstructor {
		new(value?:any): VcHostInternetScsiHbaNetworkBindingSupportType;
		readonly prototype: VcHostInternetScsiHbaNetworkBindingSupportType;
	}

	declare const VcHostInternetScsiHbaNetworkBindingSupportType: VcHostInternetScsiHbaNetworkBindingSupportTypeConstructor;

	declare class VcHostInternetScsiHbaParamValue
	{
		isInherited: boolean;
		key: String;
		value: Object;
		value_FloatValue: Number;
		value_IntValue: Number;
		value_LongValue: Number;

		constructor();
	}

	declare class VcHostInternetScsiHbaSendTarget
	{
		address: String;
		advancedOptions: VcHostInternetScsiHbaParamValue[];
		authenticationProperties: VcHostInternetScsiHbaAuthenticationProperties;
		digestProperties: VcHostInternetScsiHbaDigestProperties;
		parent: String;
		port: Number;
		supportedAdvancedOptions: VcOptionDef[];

		constructor();
	}

	declare class VcHostInternetScsiHbaStaticTarget
	{
		address: String;
		advancedOptions: VcHostInternetScsiHbaParamValue[];
		authenticationProperties: VcHostInternetScsiHbaAuthenticationProperties;
		digestProperties: VcHostInternetScsiHbaDigestProperties;
		discoveryMethod: String;
		iScsiName: String;
		parent: String;
		port: Number;
		supportedAdvancedOptions: VcOptionDef[];

		constructor();
	}

	interface VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod
	{
		readonly _isnsMethod: String;
		readonly _sendTargetMethod: String;
		readonly _slpMethod: String;
		readonly _staticMethod: String;
		readonly _unknownMethod: String;
		readonly id: String;
		readonly isnsMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly name: String;
		readonly sendTargetMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly slpMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly staticMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly unknownMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly value: String;

		fromString(value?: String): VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
	}

	interface VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethodConstructor {
		new(value?:any): VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly prototype: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
	}

	declare const VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod: VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethodConstructor;

	declare class VcHostInternetScsiHbaTargetSet
	{
		sendTargets: VcHostInternetScsiHbaSendTarget[];
		staticTargets: VcHostInternetScsiHbaStaticTarget[];

		constructor();
	}

	declare class VcHostInternetScsiTargetTransport
	{
		address: String[];
		iScsiAlias: String;
		iScsiName: String;

		constructor();
	}

	declare class VcHostInventoryFullEvent
	{
		capacity: Number;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostInventoryUnreadableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostIoFilterInfo
	{
		available: boolean;
		id: String;
		name: String;
		releaseDate: String;
		summary: String;
		vendor: String;
		version: String;

		constructor();
	}

	declare class VcHostIpChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newIP: String;
		oldIP: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostIpConfig
	{
		dhcp: boolean;
		ipAddress: String;
		ipV6Config: VcHostIpConfigIpV6AddressConfiguration;
		subnetMask: String;

		constructor();
	}

	declare class VcHostIpConfigIpV6Address
	{
		dadState: String;
		ipAddress: String;
		lifetime: Date;
		operation: String;
		origin: String;
		prefixLength: Number;

		constructor();
	}

	interface VcHostIpConfigIpV6AddressConfigType
	{
		readonly _dhcp: String;
		readonly _linklayer: String;
		readonly _manual: String;
		readonly _other: String;
		readonly _random: String;
		readonly dhcp: VcHostIpConfigIpV6AddressConfigType;
		readonly id: String;
		readonly linklayer: VcHostIpConfigIpV6AddressConfigType;
		readonly manual: VcHostIpConfigIpV6AddressConfigType;
		readonly name: String;
		readonly other: VcHostIpConfigIpV6AddressConfigType;
		readonly random: VcHostIpConfigIpV6AddressConfigType;
		readonly value: String;

		fromString(value?: String): VcHostIpConfigIpV6AddressConfigType;
	}

	interface VcHostIpConfigIpV6AddressConfigTypeConstructor {
		new(value?:any): VcHostIpConfigIpV6AddressConfigType;
		readonly prototype: VcHostIpConfigIpV6AddressConfigType;
	}

	declare const VcHostIpConfigIpV6AddressConfigType: VcHostIpConfigIpV6AddressConfigTypeConstructor;

	declare class VcHostIpConfigIpV6AddressConfiguration
	{
		autoConfigurationEnabled: boolean;
		dhcpV6Enabled: boolean;
		ipV6Address: VcHostIpConfigIpV6Address[];

		constructor();
	}

	interface VcHostIpConfigIpV6AddressStatus
	{
		readonly _deprecated: String;
		readonly _duplicate: String;
		readonly _inaccessible: String;
		readonly _invalid: String;
		readonly _preferred: String;
		readonly _tentative: String;
		readonly _unknown: String;
		readonly deprecated: VcHostIpConfigIpV6AddressStatus;
		readonly duplicate: VcHostIpConfigIpV6AddressStatus;
		readonly id: String;
		readonly inaccessible: VcHostIpConfigIpV6AddressStatus;
		readonly invalid: VcHostIpConfigIpV6AddressStatus;
		readonly name: String;
		readonly preferred: VcHostIpConfigIpV6AddressStatus;
		readonly tentative: VcHostIpConfigIpV6AddressStatus;
		readonly unknown: VcHostIpConfigIpV6AddressStatus;
		readonly value: String;

		fromString(value?: String): VcHostIpConfigIpV6AddressStatus;
	}

	interface VcHostIpConfigIpV6AddressStatusConstructor {
		new(value?:any): VcHostIpConfigIpV6AddressStatus;
		readonly prototype: VcHostIpConfigIpV6AddressStatus;
	}

	declare const VcHostIpConfigIpV6AddressStatus: VcHostIpConfigIpV6AddressStatusConstructor;

	declare class VcHostIpInconsistentEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ipAddress: String;
		ipAddress2: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostIpmiInfo
	{
		bmcIpAddress: String;
		bmcMacAddress: String;
		login: String;
		password: String;

		constructor();
	}

	declare class VcHostIpRouteConfig
	{
		defaultGateway: String;
		gatewayDevice: String;
		ipV6DefaultGateway: String;
		ipV6GatewayDevice: String;

		constructor();
	}

	declare class VcHostIpRouteConfigSpec
	{
		defaultGateway: String;
		gatewayDevice: String;
		gatewayDeviceConnection: VcHostVirtualNicConnection;
		ipV6DefaultGateway: String;
		ipV6GatewayDevice: String;
		ipV6GatewayDeviceConnection: VcHostVirtualNicConnection;

		constructor();
	}

	declare class VcHostIpRouteEntry
	{
		deviceName: String;
		gateway: String;
		network: String;
		prefixLength: Number;

		constructor();
	}

	declare class VcHostIpRouteOp
	{
		changeOperation: String;
		route: VcHostIpRouteEntry;

		constructor();
	}

	declare class VcHostIpRouteTableConfig
	{
		ipRoute: VcHostIpRouteOp[];
		ipv6Route: VcHostIpRouteOp[];

		constructor();
	}

	declare class VcHostIpRouteTableInfo
	{
		ipRoute: VcHostIpRouteEntry[];
		ipv6Route: VcHostIpRouteEntry[];

		constructor();
	}

	declare class VcHostIpSecConfig
	{
		ipSecPolicy: VcHostIpSecConfigIpSecPolicy[];
		securityAssociation: VcHostIpSecConfigSecurityAssociationConfig[];

		constructor();
	}

	interface VcHostIpSecConfigEncryptionAlgorithm
	{
		readonly _aes128cbc: String;
		readonly _des3cbc: String;
		readonly aes128cbc: VcHostIpSecConfigEncryptionAlgorithm;
		readonly des3cbc: VcHostIpSecConfigEncryptionAlgorithm;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostIpSecConfigEncryptionAlgorithm;
	}

	interface VcHostIpSecConfigEncryptionAlgorithmConstructor {
		new(value?:any): VcHostIpSecConfigEncryptionAlgorithm;
		readonly prototype: VcHostIpSecConfigEncryptionAlgorithm;
	}

	declare const VcHostIpSecConfigEncryptionAlgorithm: VcHostIpSecConfigEncryptionAlgorithmConstructor;

	declare class VcHostIpSecConfigEncryptionMethod
	{
		algorithm: String;
		initialVector: String;
		keyingMaterial: String;

		constructor();
	}

	declare class VcHostIpSecConfigEndPoint
	{
		ipAddress: String;
		portRange: VcHostIpSecConfigPortRange;
		subnetMask: Number;

		constructor();
	}

	interface VcHostIpSecConfigIntegrityAlgorithm
	{
		readonly _sha1: String;
		readonly id: String;
		readonly name: String;
		readonly sha1: VcHostIpSecConfigIntegrityAlgorithm;
		readonly value: String;

		fromString(value?: String): VcHostIpSecConfigIntegrityAlgorithm;
	}

	interface VcHostIpSecConfigIntegrityAlgorithmConstructor {
		new(value?:any): VcHostIpSecConfigIntegrityAlgorithm;
		readonly prototype: VcHostIpSecConfigIntegrityAlgorithm;
	}

	declare const VcHostIpSecConfigIntegrityAlgorithm: VcHostIpSecConfigIntegrityAlgorithmConstructor;

	declare class VcHostIpSecConfigIntegrityMethod
	{
		algorithm: String;
		keyBlob: String;

		constructor();
	}

	declare class VcHostIpSecConfigIpSecPolicy
	{
		destinationEndPoint: VcHostIpSecConfigEndPoint;
		priority: Number;
		securityAssociationName: String;
		sourceEndPoint: VcHostIpSecConfigEndPoint;
		upperLayerProtocol: String[];

		constructor();
	}

	interface VcHostIpSecConfigIpSecSAMode
	{
		readonly _transport: String;
		readonly _tunnel: String;
		readonly id: String;
		readonly name: String;
		readonly transport: VcHostIpSecConfigIpSecSAMode;
		readonly tunnel: VcHostIpSecConfigIpSecSAMode;
		readonly value: String;

		fromString(value?: String): VcHostIpSecConfigIpSecSAMode;
	}

	interface VcHostIpSecConfigIpSecSAModeConstructor {
		new(value?:any): VcHostIpSecConfigIpSecSAMode;
		readonly prototype: VcHostIpSecConfigIpSecSAMode;
	}

	declare const VcHostIpSecConfigIpSecSAMode: VcHostIpSecConfigIpSecSAModeConstructor;

	declare class VcHostIpSecConfigPortRange
	{
		end: Number;
		start: Number;

		constructor();
	}

	interface VcHostIpSecConfigSAKeyingType
	{
		readonly _ike: String;
		readonly _manual: String;
		readonly id: String;
		readonly ike: VcHostIpSecConfigSAKeyingType;
		readonly manual: VcHostIpSecConfigSAKeyingType;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostIpSecConfigSAKeyingType;
	}

	interface VcHostIpSecConfigSAKeyingTypeConstructor {
		new(value?:any): VcHostIpSecConfigSAKeyingType;
		readonly prototype: VcHostIpSecConfigSAKeyingType;
	}

	declare const VcHostIpSecConfigSAKeyingType: VcHostIpSecConfigSAKeyingTypeConstructor;

	declare class VcHostIpSecConfigSecurityAssociationConfig
	{
		encryptionSetting: VcHostIpSecConfigEncryptionMethod;
		integritySetting: VcHostIpSecConfigIntegrityMethod;
		keyingType: String;
		mode: String;
		name: String;
		preSharedKey: String;
		saLifeTimeData: Number;
		saLifeTimeMins: Number;
		spi: Number;
		tunnelDestinationAddress: String;
		tunnelSourceAddress: String;

		constructor();
	}

	interface VcHostIpSecConfigUpperLayerProtocolType
	{
		readonly _icmp: String;
		readonly _tcp: String;
		readonly _udp: String;
		readonly icmp: VcHostIpSecConfigUpperLayerProtocolType;
		readonly id: String;
		readonly name: String;
		readonly tcp: VcHostIpSecConfigUpperLayerProtocolType;
		readonly udp: VcHostIpSecConfigUpperLayerProtocolType;
		readonly value: String;

		fromString(value?: String): VcHostIpSecConfigUpperLayerProtocolType;
	}

	interface VcHostIpSecConfigUpperLayerProtocolTypeConstructor {
		new(value?:any): VcHostIpSecConfigUpperLayerProtocolType;
		readonly prototype: VcHostIpSecConfigUpperLayerProtocolType;
	}

	declare const VcHostIpSecConfigUpperLayerProtocolType: VcHostIpSecConfigUpperLayerProtocolTypeConstructor;

	declare class VcHostIpToShortNameFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostIsolationIpPingFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		isolationIp: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostKernelModuleSystem
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryConfiguredModuleOptionString(name?: String): String;
		queryModules(): VcKernelModuleInfo[];
		updateModuleOptionString(name?: String, options?: String): void;
	}

	declare const VcHostKernelModuleSystem: VcHostKernelModuleSystem;

	declare class VcHostLicensableResourceInfo
	{
		resource: VcKeyAnyValue[];

		constructor();
	}

	interface VcHostLicensableResourceKey
	{
		readonly _memoryForVms: String;
		readonly _memorySize: String;
		readonly _numCpuCores: String;
		readonly _numCpuPackages: String;
		readonly _numVmsStarted: String;
		readonly _numVmsStarting: String;
		readonly id: String;
		readonly memoryForVms: VcHostLicensableResourceKey;
		readonly memorySize: VcHostLicensableResourceKey;
		readonly name: String;
		readonly numCpuCores: VcHostLicensableResourceKey;
		readonly numCpuPackages: VcHostLicensableResourceKey;
		readonly numVmsStarted: VcHostLicensableResourceKey;
		readonly numVmsStarting: VcHostLicensableResourceKey;
		readonly value: String;

		fromString(value?: String): VcHostLicensableResourceKey;
	}

	interface VcHostLicensableResourceKeyConstructor {
		new(value?:any): VcHostLicensableResourceKey;
		readonly prototype: VcHostLicensableResourceKey;
	}

	declare const VcHostLicensableResourceKey: VcHostLicensableResourceKeyConstructor;

	declare class VcHostLicenseConnectInfo
	{
		evaluation: VcLicenseManagerEvaluationInfo;
		license: VcLicenseManagerLicenseInfo;
		resource: VcHostLicensableResourceInfo;

		constructor();
	}

	declare class VcHostLicenseExpiredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostLicenseSpec
	{
		disabledFeatureKey: String[];
		editionKey: String;
		enabledFeatureKey: String[];
		source: VcLicenseSource;

		constructor();
	}

	declare class VcHostListSummary
	{
		config: VcHostConfigSummary;
		currentEVCModeKey: String;
		customValue: VcCustomFieldValue[];
		gateway: VcHostListSummaryGatewaySummary;
		hardware: VcHostHardwareSummary;
		host: VcHostSystem;
		managementServerIp: String;
		maxEVCModeKey: String;
		overallStatus: VcManagedEntityStatus;
		quickStats: VcHostListSummaryQuickStats;
		rebootRequired: boolean;
		runtime: VcHostRuntimeInfo;

		constructor();
	}

	declare class VcHostListSummaryGatewaySummary
	{
		gatewayId: String;
		gatewayType: String;

		constructor();
	}

	declare class VcHostListSummaryQuickStats
	{
		distributedCpuFairness: Number;
		distributedMemoryFairness: Number;
		overallCpuUsage: Number;
		overallMemoryUsage: Number;
		uptime: Number;

		constructor();
	}

	interface VcHostLocalAccountManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		assignUserToGroup(user?: String, group?: String): void;
		createGroup(group?: VcHostAccountSpec): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createUser(user?: VcHostAccountSpec): void;
		removeGroup(groupName?: String): void;
		removeUser(userName?: String): void;
		unassignUserFromGroup(user?: String, group?: String): void;
		updateUser(user?: VcHostAccountSpec): void;
	}

	declare const VcHostLocalAccountManager: VcHostLocalAccountManager;

	interface VcHostLocalAuthentication
	{
		readonly id: String;
		info: VcHostAuthenticationStoreInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostLocalAuthentication: VcHostLocalAuthentication;

	declare class VcHostLocalAuthenticationInfo
	{
		enabled: boolean;

		constructor();
	}

	declare class VcHostLocalFileSystemVolume
	{
		capacity: Number;
		device: String;
		name: String;
		type: String;

		constructor();
	}

	declare class VcHostLocalFileSystemVolumeSpec
	{
		device: String;
		localPath: String;

		constructor();
	}

	declare class VcHostLocalPortCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostLocalPort: VcDVSHostLocalPortInfo;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostLockdownMode
	{
		readonly _lockdownDisabled: String;
		readonly _lockdownNormal: String;
		readonly _lockdownStrict: String;
		readonly id: String;
		readonly lockdownDisabled: VcHostLockdownMode;
		readonly lockdownNormal: VcHostLockdownMode;
		readonly lockdownStrict: VcHostLockdownMode;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostLockdownMode;
	}

	interface VcHostLockdownModeConstructor {
		new(value?:any): VcHostLockdownMode;
		readonly prototype: VcHostLockdownMode;
	}

	declare const VcHostLockdownMode: VcHostLockdownModeConstructor;

	declare class VcHostLowLevelProvisioningManagerDiskLayoutSpec
	{
		busNumber: Number;
		controllerType: String;
		dstFilename: String;
		srcFilename: String;
		unitNumber: Number;

		constructor();
	}

	declare class VcHostLowLevelProvisioningManagerFileDeleteResult
	{
		fault: VcLocalizedMethodFault;
		fileName: String;

		constructor();
	}

	declare class VcHostLowLevelProvisioningManagerFileDeleteSpec
	{
		fileName: String;
		fileType: String;

		constructor();
	}

	declare class VcHostLowLevelProvisioningManagerFileReserveResult
	{
		baseName: String;
		parentDir: String;
		reservedName: String;

		constructor();
	}

	declare class VcHostLowLevelProvisioningManagerFileReserveSpec
	{
		baseName: String;
		fileType: String;
		parentDir: String;
		storageProfile: String;

		constructor();
	}

	interface VcHostLowLevelProvisioningManagerFileType
	{
		readonly _Directory: String;
		readonly _File: String;
		readonly _VirtualDisk: String;
		readonly Directory: VcHostLowLevelProvisioningManagerFileType;
		readonly File: VcHostLowLevelProvisioningManagerFileType;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly VirtualDisk: VcHostLowLevelProvisioningManagerFileType;

		fromString(value?: String): VcHostLowLevelProvisioningManagerFileType;
	}

	interface VcHostLowLevelProvisioningManagerFileTypeConstructor {
		new(value?:any): VcHostLowLevelProvisioningManagerFileType;
		readonly prototype: VcHostLowLevelProvisioningManagerFileType;
	}

	declare const VcHostLowLevelProvisioningManagerFileType: VcHostLowLevelProvisioningManagerFileTypeConstructor;

	interface VcHostLowLevelProvisioningManagerReloadTarget
	{
		readonly _currentConfig: String;
		readonly _snapshotConfig: String;
		readonly currentConfig: VcHostLowLevelProvisioningManagerReloadTarget;
		readonly id: String;
		readonly name: String;
		readonly snapshotConfig: VcHostLowLevelProvisioningManagerReloadTarget;
		readonly value: String;

		fromString(value?: String): VcHostLowLevelProvisioningManagerReloadTarget;
	}

	interface VcHostLowLevelProvisioningManagerReloadTargetConstructor {
		new(value?:any): VcHostLowLevelProvisioningManagerReloadTarget;
		readonly prototype: VcHostLowLevelProvisioningManagerReloadTarget;
	}

	declare const VcHostLowLevelProvisioningManagerReloadTarget: VcHostLowLevelProvisioningManagerReloadTargetConstructor;

	declare class VcHostLowLevelProvisioningManagerSnapshotLayoutSpec
	{
		disk: VcHostLowLevelProvisioningManagerDiskLayoutSpec[];
		dstFilename: String;
		id: Number;
		srcFilename: String;

		constructor();
	}

	declare class VcHostLowLevelProvisioningManagerVmMigrationStatus
	{
		consideredSuccessful: boolean;
		migrationId: Number;
		source: boolean;
		type: String;

		constructor();
	}

	declare class VcHostLowLevelProvisioningManagerVmRecoveryInfo
	{
		biosUUID: String;
		ftInfo: VcFaultToleranceConfigInfo;
		instanceUUID: String;
		version: String;

		constructor();
	}

	declare class VcHostMaintenanceSpec
	{
		vsanMode: VcVsanHostDecommissionMode;

		constructor();
	}

	declare class VcHostMemberHealthCheckResult
	{
		summary: String;

		constructor();
	}

	declare class VcHostMemberRuntimeInfo
	{
		healthCheckResult: VcHostMemberHealthCheckResult[];
		host: VcHostSystem;
		status: String;
		statusDetail: String;

		constructor();
	}

	declare class VcHostMemberUplinkHealthCheckResult
	{
		summary: String;
		uplinkPortKey: String;

		constructor();
	}

	declare class VcHostMemoryProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcHostMemorySpec
	{
		serviceConsoleReservation: Number;

		constructor();
	}

	interface VcHostMemorySystem
	{
		availableField: VcCustomFieldDef[];
		consoleReservationInfo: VcServiceConsoleReservationInfo;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;
		virtualMachineReservationInfo: VcVirtualMachineMemoryReservationInfo;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureServiceConsoleReservation(cfgBytes?: Number): void;
		reconfigureVirtualMachineReservation(spec?: VcVirtualMachineMemoryReservationSpec): void;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcHostMemorySystem: VcHostMemorySystem;

	declare class VcHostMissingNetworksEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ips: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostMonitoringStateChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		state: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostMountInfo
	{
		accessible: boolean;
		accessMode: String;
		inaccessibleReason: String;
		mounted: boolean;
		path: String;

		constructor();
	}

	interface VcHostMountInfoInaccessibleReason
	{
		readonly _AllPathsDown_Start: String;
		readonly _AllPathsDown_Timeout: String;
		readonly _PermanentDeviceLoss: String;
		readonly AllPathsDown_Start: VcHostMountInfoInaccessibleReason;
		readonly AllPathsDown_Timeout: VcHostMountInfoInaccessibleReason;
		readonly id: String;
		readonly name: String;
		readonly PermanentDeviceLoss: VcHostMountInfoInaccessibleReason;
		readonly value: String;

		fromString(value?: String): VcHostMountInfoInaccessibleReason;
	}

	interface VcHostMountInfoInaccessibleReasonConstructor {
		new(value?:any): VcHostMountInfoInaccessibleReason;
		readonly prototype: VcHostMountInfoInaccessibleReason;
	}

	declare const VcHostMountInfoInaccessibleReason: VcHostMountInfoInaccessibleReasonConstructor;

	interface VcHostMountMode
	{
		readonly _readOnly: String;
		readonly _readWrite: String;
		readonly id: String;
		readonly name: String;
		readonly readOnly: VcHostMountMode;
		readonly readWrite: VcHostMountMode;
		readonly value: String;

		fromString(value?: String): VcHostMountMode;
	}

	interface VcHostMountModeConstructor {
		new(value?:any): VcHostMountMode;
		readonly prototype: VcHostMountMode;
	}

	declare const VcHostMountMode: VcHostMountModeConstructor;

	declare class VcHostMultipathInfo
	{
		lun: VcHostMultipathInfoLogicalUnit[];

		constructor();
	}

	declare class VcHostMultipathInfoFixedLogicalUnitPolicy
	{
		policy: String;
		prefer: String;

		constructor();
	}

	declare class VcHostMultipathInfoLogicalUnit
	{
		id: String;
		key: String;
		lun: VcScsiLun;
		path: VcHostMultipathInfoPath[];
		policy: VcHostMultipathInfoLogicalUnitPolicy;
		storageArrayTypePolicy: VcHostMultipathInfoLogicalUnitStorageArrayTypePolicy;

		constructor();
	}

	declare class VcHostMultipathInfoLogicalUnitPolicy
	{
		policy: String;

		constructor();
	}

	declare class VcHostMultipathInfoLogicalUnitStorageArrayTypePolicy
	{
		policy: String;

		constructor();
	}

	declare class VcHostMultipathInfoPath
	{
		adapter: VcHostHostBusAdapter;
		isWorkingPath: boolean;
		key: String;
		lun: VcHostMultipathInfoLogicalUnit;
		name: String;
		pathState: String;
		state: String;
		transport: VcHostTargetTransport;

		constructor();
	}

	declare class VcHostMultipathStateInfo
	{
		path: VcHostMultipathStateInfoPath[];

		constructor();
	}

	declare class VcHostMultipathStateInfoPath
	{
		name: String;
		pathState: String;

		constructor();
	}

	declare class VcHostNasVolume
	{
		capacity: Number;
		name: String;
		protocolEndpoint: boolean;
		remoteHost: String;
		remoteHostNames: String[];
		remotePath: String;
		securityType: String;
		type: String;
		userName: String;

		constructor();
	}

	declare class VcHostNasVolumeConfig
	{
		changeOperation: String;
		spec: VcHostNasVolumeSpec;

		constructor();
	}

	interface VcHostNasVolumeSecurityType
	{
		readonly _AUTH_SYS: String;
		readonly _SEC_KRB5: String;
		readonly AUTH_SYS: VcHostNasVolumeSecurityType;
		readonly id: String;
		readonly name: String;
		readonly SEC_KRB5: VcHostNasVolumeSecurityType;
		readonly value: String;

		fromString(value?: String): VcHostNasVolumeSecurityType;
	}

	interface VcHostNasVolumeSecurityTypeConstructor {
		new(value?:any): VcHostNasVolumeSecurityType;
		readonly prototype: VcHostNasVolumeSecurityType;
	}

	declare const VcHostNasVolumeSecurityType: VcHostNasVolumeSecurityTypeConstructor;

	declare class VcHostNasVolumeSpec
	{
		accessMode: String;
		localPath: String;
		password: String;
		remoteHost: String;
		remoteHostNames: String[];
		remotePath: String;
		securityType: String;
		type: String;
		userName: String;

		constructor();
	}

	declare class VcHostNasVolumeUserInfo
	{
		user: String;

		constructor();
	}

	declare class VcHostNatService
	{
		key: String;
		spec: VcHostNatServiceSpec;

		constructor();
	}

	declare class VcHostNatServiceConfig
	{
		changeOperation: String;
		key: String;
		spec: VcHostNatServiceSpec;

		constructor();
	}

	declare class VcHostNatServiceNameServiceSpec
	{
		dnsAutoDetect: boolean;
		dnsNameServer: String[];
		dnsPolicy: String;
		dnsRetries: Number;
		dnsTimeout: Number;
		nbdsTimeout: Number;
		nbnsRetries: Number;
		nbnsTimeout: Number;

		constructor();
	}

	declare class VcHostNatServicePortForwardSpec
	{
		guestIpAddress: String;
		guestPort: Number;
		hostPort: Number;
		name: String;
		type: String;

		constructor();
	}

	declare class VcHostNatServiceSpec
	{
		activeFtp: boolean;
		allowAnyOui: boolean;
		configPort: boolean;
		ipGatewayAddress: String;
		nameService: VcHostNatServiceNameServiceSpec;
		portForward: VcHostNatServicePortForwardSpec[];
		udpTimeout: Number;
		virtualSwitch: String;

		constructor();
	}

	declare class VcHostNetCapabilities
	{
		canSetPhysicalNicLinkSpeed: boolean;
		dhcpOnVnicSupported: boolean;
		dnsConfigSupported: boolean;
		ipRouteConfigSupported: boolean;
		ipV6Supported: boolean;
		maxPortGroupsPerVswitch: Number;
		nicTeamingPolicy: String[];
		supportsNetworkHints: boolean;
		supportsNicTeaming: boolean;
		supportsVlan: boolean;
		usesServiceConsoleNic: boolean;
		vnicConfigSupported: boolean;
		vswitchConfigSupported: boolean;

		constructor();
	}

	declare class VcHostNetOffloadCapabilities
	{
		csumOffload: boolean;
		tcpSegmentation: boolean;
		zeroCopyXmit: boolean;

		constructor();
	}

	declare class VcHostNetStackInstance
	{
		congestionControlAlgorithm: String;
		dnsConfig: VcHostDnsConfig;
		ipRouteConfig: VcHostIpRouteConfig;
		ipV6Enabled: boolean;
		key: String;
		name: String;
		requestedMaxNumberOfConnections: Number;
		routeTableConfig: VcHostIpRouteTableConfig;

		constructor();
	}

	interface VcHostNetStackInstanceCongestionControlAlgorithmType
	{
		readonly _cubic: String;
		readonly _newreno: String;
		readonly cubic: VcHostNetStackInstanceCongestionControlAlgorithmType;
		readonly id: String;
		readonly name: String;
		readonly newreno: VcHostNetStackInstanceCongestionControlAlgorithmType;
		readonly value: String;

		fromString(value?: String): VcHostNetStackInstanceCongestionControlAlgorithmType;
	}

	interface VcHostNetStackInstanceCongestionControlAlgorithmTypeConstructor {
		new(value?:any): VcHostNetStackInstanceCongestionControlAlgorithmType;
		readonly prototype: VcHostNetStackInstanceCongestionControlAlgorithmType;
	}

	declare const VcHostNetStackInstanceCongestionControlAlgorithmType: VcHostNetStackInstanceCongestionControlAlgorithmTypeConstructor;

	interface VcHostNetStackInstanceSystemStackKey
	{
		readonly _defaultTcpipStack: String;
		readonly _vmotion: String;
		readonly _vSphereProvisioning: String;
		readonly defaultTcpipStack: VcHostNetStackInstanceSystemStackKey;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmotion: VcHostNetStackInstanceSystemStackKey;
		readonly vSphereProvisioning: VcHostNetStackInstanceSystemStackKey;

		fromString(value?: String): VcHostNetStackInstanceSystemStackKey;
	}

	interface VcHostNetStackInstanceSystemStackKeyConstructor {
		new(value?:any): VcHostNetStackInstanceSystemStackKey;
		readonly prototype: VcHostNetStackInstanceSystemStackKey;
	}

	declare const VcHostNetStackInstanceSystemStackKey: VcHostNetStackInstanceSystemStackKeyConstructor;

	declare class VcHostNetworkConfig
	{
		consoleIpRouteConfig: VcHostIpRouteConfig;
		consoleIpSecConfig: VcHostIpSecConfig;
		consoleVnic: VcHostVirtualNicConfig[];
		dhcp: VcHostDhcpServiceConfig[];
		dnsConfig: VcHostDnsConfig;
		ipRouteConfig: VcHostIpRouteConfig;
		ipSecConfig: VcHostIpSecConfig;
		ipV6Enabled: boolean;
		nat: VcHostNatServiceConfig[];
		netStackSpec: VcHostNetworkConfigNetStackSpec[];
		pnic: VcPhysicalNicConfig[];
		portgroup: VcHostPortGroupConfig[];
		proxySwitch: VcHostProxySwitchConfig[];
		routeTableConfig: VcHostIpRouteTableConfig;
		vnic: VcHostVirtualNicConfig[];
		vswitch: VcHostVirtualSwitchConfig[];

		constructor();
	}

	declare class VcHostNetworkConfigNetStackSpec
	{
		netStackInstance: VcHostNetStackInstance;
		operation: String;

		constructor();
	}

	declare class VcHostNetworkConfigResult
	{
		consoleVnicDevice: String[];
		vnicDevice: String[];

		constructor();
	}

	declare class VcHostNetworkInfo
	{
		atBootIpV6Enabled: boolean;
		consoleIpRouteConfig: VcHostIpRouteConfig;
		consoleIpSecConfig: VcHostIpSecConfig;
		consoleVnic: VcHostVirtualNic[];
		dhcp: VcHostDhcpService[];
		dnsConfig: VcHostDnsConfig;
		ipRouteConfig: VcHostIpRouteConfig;
		ipSecConfig: VcHostIpSecConfig;
		ipV6Enabled: boolean;
		nat: VcHostNatService[];
		netStackInstance: VcHostNetStackInstance[];
		opaqueNetwork: VcHostOpaqueNetworkInfo[];
		opaqueSwitch: VcHostOpaqueSwitch[];
		pnic: VcPhysicalNic[];
		portgroup: VcHostPortGroup[];
		proxySwitch: VcHostProxySwitch[];
		routeTableInfo: VcHostIpRouteTableInfo;
		vnic: VcHostVirtualNic[];
		vswitch: VcHostVirtualSwitch[];

		constructor();
	}

	declare class VcHostNetworkPolicy
	{
		nicTeaming: VcHostNicTeamingPolicy;
		offloadPolicy: VcHostNetOffloadCapabilities;
		security: VcHostNetworkSecurityPolicy;
		shapingPolicy: VcHostNetworkTrafficShapingPolicy;

		constructor();
	}

	declare class VcHostNetworkResourceRuntime
	{
		pnicResourceInfo: VcHostPnicNetworkResourceInfo[];

		constructor();
	}

	declare class VcHostNetworkSecurityPolicy
	{
		allowPromiscuous: boolean;
		forgedTransmits: boolean;
		macChanges: boolean;

		constructor();
	}

	interface VcHostNetworkSystem
	{
		availableField: VcCustomFieldDef[];
		capabilities: VcHostNetCapabilities;
		consoleIpRouteConfig: VcHostIpRouteConfig;
		dnsConfig: VcHostDnsConfig;
		readonly id: String;
		ipRouteConfig: VcHostIpRouteConfig;
		networkConfig: VcHostNetworkConfig;
		networkInfo: VcHostNetworkInfo;
		offloadCapabilities: VcHostNetOffloadCapabilities;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addPortGroup(portgrp?: VcHostPortGroupSpec): void;
		addServiceConsoleVirtualNic(portgroup?: String, nic?: VcHostVirtualNicSpec): String;
		addVirtualNic(portgroup?: String, nic?: VcHostVirtualNicSpec): String;
		addVirtualSwitch(vswitchName?: String, spec?: VcHostVirtualSwitchSpec): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryNetworkHint(device?: String[]): VcPhysicalNicHintInfo[];
		refreshNetworkSystem(): void;
		removePortGroup(pgName?: String): void;
		removeServiceConsoleVirtualNic(device?: String): void;
		removeVirtualNic(device?: String): void;
		removeVirtualSwitch(vswitchName?: String): void;
		restartServiceConsoleVirtualNic(device?: String): void;
		setCustomValue(key?: String, value?: String): void;
		updateConsoleIpRouteConfig(config?: VcHostIpRouteConfig): void;
		updateConsoleIpSecConfig(config?: VcHostIpSecConfig): void;
		updateDnsConfig(config?: VcHostDnsConfig): void;
		updateIpRouteConfig(config?: VcHostIpRouteConfig): void;
		updateIpRouteTableConfig(config?: VcHostIpRouteTableConfig): void;
		updateIpSecConfig(config?: VcHostIpSecConfig): void;
		updateNetworkConfig(config?: VcHostNetworkConfig, changeMode?: String): VcHostNetworkConfigResult;
		updatePhysicalNicLinkSpeed(device?: String, linkSpeed?: VcPhysicalNicLinkInfo): void;
		updatePortGroup(pgName?: String, portgrp?: VcHostPortGroupSpec): void;
		updateServiceConsoleVirtualNic(device?: String, nic?: VcHostVirtualNicSpec): void;
		updateVirtualNic(device?: String, nic?: VcHostVirtualNicSpec): void;
		updateVirtualSwitch(vswitchName?: String, spec?: VcHostVirtualSwitchSpec): void;
	}

	declare const VcHostNetworkSystem: VcHostNetworkSystem;

	declare class VcHostNetworkTrafficShapingPolicy
	{
		averageBandwidth: Number;
		burstSize: Number;
		enabled: boolean;
		peakBandwidth: Number;

		constructor();
	}

	declare class VcHostNewNetworkConnectInfo
	{
		summary: VcNetworkSummary;

		constructor();
	}

	declare class VcHostNicFailureCriteria
	{
		checkBeacon: boolean;
		checkDuplex: boolean;
		checkErrorPercent: boolean;
		checkSpeed: String;
		fullDuplex: boolean;
		percentage: Number;
		speed: Number;

		constructor();
	}

	declare class VcHostNicOrderPolicy
	{
		activeNic: String[];
		standbyNic: String[];

		constructor();
	}

	declare class VcHostNicTeamingPolicy
	{
		failureCriteria: VcHostNicFailureCriteria;
		nicOrder: VcHostNicOrderPolicy;
		notifySwitches: boolean;
		policy: String;
		reversePolicy: boolean;
		rollingOrder: boolean;

		constructor();
	}

	declare class VcHostNoAvailableNetworksEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ips: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostNoHAEnabledPortGroupsEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostNonCompliantEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostNoRedundantManagementNetworkEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostNotInClusterEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostNtpConfig
	{
		configFile: String[];
		server: String[];

		constructor();
	}

	declare class VcHostNumaInfo
	{
		numaNode: VcHostNumaNode[];
		numNodes: Number;
		type: String;

		constructor();
	}

	declare class VcHostNumaNode
	{
		cpuID: Number[];
		memoryRangeBegin: Number;
		memoryRangeLength: Number;
		typeId: Number;

		constructor();
	}

	interface VcHostNumericSensorHealthState
	{
		readonly _green: String;
		readonly _red: String;
		readonly _unknown: String;
		readonly _yellow: String;
		readonly green: VcHostNumericSensorHealthState;
		readonly id: String;
		readonly name: String;
		readonly red: VcHostNumericSensorHealthState;
		readonly unknown: VcHostNumericSensorHealthState;
		readonly value: String;
		readonly yellow: VcHostNumericSensorHealthState;

		fromString(value?: String): VcHostNumericSensorHealthState;
	}

	interface VcHostNumericSensorHealthStateConstructor {
		new(value?:any): VcHostNumericSensorHealthState;
		readonly prototype: VcHostNumericSensorHealthState;
	}

	declare const VcHostNumericSensorHealthState: VcHostNumericSensorHealthStateConstructor;

	declare class VcHostNumericSensorInfo
	{
		baseUnits: String;
		currentReading: Number;
		healthState: VcElementDescription;
		name: String;
		rateUnits: String;
		sensorType: String;
		unitModifier: Number;

		constructor();
	}

	interface VcHostNumericSensorType
	{
		readonly _fan: String;
		readonly _other: String;
		readonly _power: String;
		readonly _temperature: String;
		readonly _voltage: String;
		readonly fan: VcHostNumericSensorType;
		readonly id: String;
		readonly name: String;
		readonly other: VcHostNumericSensorType;
		readonly power: VcHostNumericSensorType;
		readonly temperature: VcHostNumericSensorType;
		readonly value: String;
		readonly voltage: VcHostNumericSensorType;

		fromString(value?: String): VcHostNumericSensorType;
	}

	interface VcHostNumericSensorTypeConstructor {
		new(value?:any): VcHostNumericSensorType;
		readonly prototype: VcHostNumericSensorType;
	}

	declare const VcHostNumericSensorType: VcHostNumericSensorTypeConstructor;

	declare class VcHostOpaqueNetworkInfo
	{
		opaqueNetworkId: String;
		opaqueNetworkName: String;
		opaqueNetworkType: String;
		pnicZone: String[];

		constructor();
	}

	declare class VcHostOpaqueSwitch
	{
		key: String;
		name: String;
		pnic: VcPhysicalNic[];
		pnicZone: VcHostOpaqueSwitchPhysicalNicZone[];
		status: String;
		vtep: VcHostVirtualNic[];

		constructor();
	}

	interface VcHostOpaqueSwitchOpaqueSwitchState
	{
		readonly _down: String;
		readonly _up: String;
		readonly _warning: String;
		readonly down: VcHostOpaqueSwitchOpaqueSwitchState;
		readonly id: String;
		readonly name: String;
		readonly up: VcHostOpaqueSwitchOpaqueSwitchState;
		readonly value: String;
		readonly warning: VcHostOpaqueSwitchOpaqueSwitchState;

		fromString(value?: String): VcHostOpaqueSwitchOpaqueSwitchState;
	}

	interface VcHostOpaqueSwitchOpaqueSwitchStateConstructor {
		new(value?:any): VcHostOpaqueSwitchOpaqueSwitchState;
		readonly prototype: VcHostOpaqueSwitchOpaqueSwitchState;
	}

	declare const VcHostOpaqueSwitchOpaqueSwitchState: VcHostOpaqueSwitchOpaqueSwitchStateConstructor;

	declare class VcHostOpaqueSwitchPhysicalNicZone
	{
		key: String;
		pnicDevice: String[];

		constructor();
	}

	declare class VcHostOvercommittedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostParallelScsiHba
	{
		bus: Number;
		device: String;
		driver: String;
		key: String;
		model: String;
		pci: String;
		status: String;

		constructor();
	}

	declare class VcHostParallelScsiTargetTransport
	{

		constructor();
	}

	interface VcHostPatchManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		checkHostPatch_Task(metaUrls?: String[], bundleUrls?: String[], spec?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		installHostPatch_Task(repository?: VcHostPatchManagerLocator, updateID?: String, force?: boolean): VcTask;
		installHostPatchV2_Task(metaUrls?: String[], bundleUrls?: String[], vibUrls?: String[], spec?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
		queryHostPatch_Task(spec?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
		scanHostPatch_Task(repository?: VcHostPatchManagerLocator, updateID?: String[]): VcTask;
		scanHostPatchV2_Task(metaUrls?: String[], bundleUrls?: String[], spec?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
		stageHostPatch_Task(metaUrls?: String[], bundleUrls?: String[], vibUrls?: String[], spec?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
		uninstallHostPatch_Task(bulletinIds?: String[], spec?: VcHostPatchManagerPatchManagerOperationSpec): VcTask;
	}

	declare const VcHostPatchManager: VcHostPatchManager;

	interface VcHostPatchManagerInstallState
	{
		readonly _hostRestarted: String;
		readonly _imageActive: String;
		readonly hostRestarted: VcHostPatchManagerInstallState;
		readonly id: String;
		readonly imageActive: VcHostPatchManagerInstallState;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostPatchManagerInstallState;
	}

	interface VcHostPatchManagerInstallStateConstructor {
		new(value?:any): VcHostPatchManagerInstallState;
		readonly prototype: VcHostPatchManagerInstallState;
	}

	declare const VcHostPatchManagerInstallState: VcHostPatchManagerInstallStateConstructor;

	interface VcHostPatchManagerIntegrityStatus
	{
		readonly _digestMismatch: String;
		readonly _keyExpired: String;
		readonly _keyNotFound: String;
		readonly _keyRevoked: String;
		readonly _notEnoughSignatures: String;
		readonly _validated: String;
		readonly _validationError: String;
		readonly digestMismatch: VcHostPatchManagerIntegrityStatus;
		readonly id: String;
		readonly keyExpired: VcHostPatchManagerIntegrityStatus;
		readonly keyNotFound: VcHostPatchManagerIntegrityStatus;
		readonly keyRevoked: VcHostPatchManagerIntegrityStatus;
		readonly name: String;
		readonly notEnoughSignatures: VcHostPatchManagerIntegrityStatus;
		readonly validated: VcHostPatchManagerIntegrityStatus;
		readonly validationError: VcHostPatchManagerIntegrityStatus;
		readonly value: String;

		fromString(value?: String): VcHostPatchManagerIntegrityStatus;
	}

	interface VcHostPatchManagerIntegrityStatusConstructor {
		new(value?:any): VcHostPatchManagerIntegrityStatus;
		readonly prototype: VcHostPatchManagerIntegrityStatus;
	}

	declare const VcHostPatchManagerIntegrityStatus: VcHostPatchManagerIntegrityStatusConstructor;

	declare class VcHostPatchManagerLocator
	{
		proxy: String;
		url: String;

		constructor();
	}

	declare class VcHostPatchManagerPatchManagerOperationSpec
	{
		cmdOption: String;
		password: String;
		port: Number;
		proxy: String;
		userName: String;

		constructor();
	}

	interface VcHostPatchManagerReason
	{
		readonly _conflictLib: String;
		readonly _conflictPatch: String;
		readonly _hasDependentPatch: String;
		readonly _missingLib: String;
		readonly _missingPatch: String;
		readonly _obsoleted: String;
		readonly conflictLib: VcHostPatchManagerReason;
		readonly conflictPatch: VcHostPatchManagerReason;
		readonly hasDependentPatch: VcHostPatchManagerReason;
		readonly id: String;
		readonly missingLib: VcHostPatchManagerReason;
		readonly missingPatch: VcHostPatchManagerReason;
		readonly name: String;
		readonly obsoleted: VcHostPatchManagerReason;
		readonly value: String;

		fromString(value?: String): VcHostPatchManagerReason;
	}

	interface VcHostPatchManagerReasonConstructor {
		new(value?:any): VcHostPatchManagerReason;
		readonly prototype: VcHostPatchManagerReason;
	}

	declare const VcHostPatchManagerReason: VcHostPatchManagerReasonConstructor;

	declare class VcHostPatchManagerResult
	{
		status: VcHostPatchManagerStatus[];
		version: String;
		xmlResult: String;

		constructor();
	}

	declare class VcHostPatchManagerStatus
	{
		applicable: boolean;
		id: String;
		installed: boolean;
		installState: String[];
		integrity: String;
		prerequisitePatch: VcHostPatchManagerStatusPrerequisitePatch[];
		reason: String[];
		reconnectRequired: boolean;
		restartRequired: boolean;
		supersededPatchIds: String[];
		vmOffRequired: boolean;

		constructor();
	}

	declare class VcHostPatchManagerStatusPrerequisitePatch
	{
		id: String;
		installState: String[];

		constructor();
	}

	declare class VcHostPathSelectionPolicyOption
	{
		policy: VcElementDescription;

		constructor();
	}

	declare class VcHostPciDevice
	{
		bus: Number;
		classId: Number;
		deviceId: Number;
		deviceName: String;
		function: Number;
		id: String;
		parentBridge: String;
		slot: Number;
		subDeviceId: Number;
		subVendorId: Number;
		vendorId: Number;
		vendorName: String;

		constructor();
	}

	declare class VcHostPciPassthruConfig
	{
		id: String;
		passthruEnabled: boolean;

		constructor();
	}

	declare class VcHostPciPassthruInfo
	{
		dependentDevice: String;
		id: String;
		passthruActive: boolean;
		passthruCapable: boolean;
		passthruEnabled: boolean;

		constructor();
	}

	interface VcHostPciPassthruSystem
	{
		availableField: VcCustomFieldDef[];
		readonly id: String;
		pciPassthruInfo: VcHostPciPassthruInfo[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		refresh(): void;
		setCustomValue(key?: String, value?: String): void;
		updatePassthruConfig(config?: VcHostPciPassthruConfig[]): void;
	}

	declare const VcHostPciPassthruSystem: VcHostPciPassthruSystem;

	declare class VcHostPlacedVirtualNicIdentifier
	{
		reservation: Number;
		vm: VcVirtualMachine;
		vnicKey: String;

		constructor();
	}

	declare class VcHostPlugStoreTopology
	{
		adapter: VcHostPlugStoreTopologyAdapter[];
		device: VcHostPlugStoreTopologyDevice[];
		path: VcHostPlugStoreTopologyPath[];
		plugin: VcHostPlugStoreTopologyPlugin[];
		target: VcHostPlugStoreTopologyTarget[];

		constructor();
	}

	declare class VcHostPlugStoreTopologyAdapter
	{
		adapter: VcHostHostBusAdapter;
		key: String;
		path: VcHostPlugStoreTopologyPath[];

		constructor();
	}

	declare class VcHostPlugStoreTopologyDevice
	{
		key: String;
		lun: VcScsiLun;
		path: VcHostPlugStoreTopologyPath[];

		constructor();
	}

	declare class VcHostPlugStoreTopologyPath
	{
		adapter: VcHostPlugStoreTopologyAdapter;
		channelNumber: Number;
		device: VcHostPlugStoreTopologyDevice;
		key: String;
		lunNumber: Number;
		name: String;
		target: VcHostPlugStoreTopologyTarget;
		targetNumber: Number;

		constructor();
	}

	declare class VcHostPlugStoreTopologyPlugin
	{
		claimedPath: VcHostPlugStoreTopologyPath[];
		device: VcHostPlugStoreTopologyDevice[];
		key: String;
		name: String;

		constructor();
	}

	declare class VcHostPlugStoreTopologyTarget
	{
		key: String;
		transport: VcHostTargetTransport;

		constructor();
	}

	declare class VcHostPnicNetworkResourceInfo
	{
		availableBandwidthForVMTraffic: Number;
		placedVirtualNics: VcHostPlacedVirtualNicIdentifier[];
		pnicDevice: String;
		unusedBandwidthForVMTraffic: Number;

		constructor();
	}

	declare class VcHostPortGroup
	{
		computedPolicy: VcHostNetworkPolicy;
		key: String;
		port: VcHostPortGroupPort[];
		spec: VcHostPortGroupSpec;
		vswitch: VcHostVirtualSwitch;

		constructor();
	}

	declare class VcHostPortGroupConfig
	{
		changeOperation: String;
		spec: VcHostPortGroupSpec;

		constructor();
	}

	declare class VcHostPortGroupPort
	{
		key: String;
		mac: String[];
		type: String;

		constructor();
	}

	declare class VcHostPortGroupProfile
	{
		enabled: boolean;
		ipConfig: VcIpAddressProfile;
		key: String;
		name: String;
		networkPolicy: VcNetworkPolicyProfile;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		vlan: VcVlanProfile;
		vswitch: VcVirtualSwitchSelectionProfile;

		constructor();
	}

	declare class VcHostPortGroupSpec
	{
		name: String;
		policy: VcHostNetworkPolicy;
		vlanId: Number;
		vswitchName: String;

		constructor();
	}

	declare class VcHostPosixAccountSpec
	{
		description: String;
		id: String;
		password: String;
		posixId: Number;
		shellAccess: boolean;

		constructor();
	}

	interface VcHostPowerOperationType
	{
		readonly _powerOff: String;
		readonly _powerOn: String;
		readonly id: String;
		readonly name: String;
		readonly powerOff: VcHostPowerOperationType;
		readonly powerOn: VcHostPowerOperationType;
		readonly value: String;

		fromString(value?: String): VcHostPowerOperationType;
	}

	interface VcHostPowerOperationTypeConstructor {
		new(value?:any): VcHostPowerOperationType;
		readonly prototype: VcHostPowerOperationType;
	}

	declare const VcHostPowerOperationType: VcHostPowerOperationTypeConstructor;

	declare class VcHostPowerPolicy
	{
		description: String;
		key: Number;
		name: String;
		shortName: String;

		constructor();
	}

	interface VcHostPowerSystem
	{
		capability: VcPowerSystemCapability;
		readonly id: String;
		info: VcPowerSystemInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		configurePowerPolicy(key?: Number): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcHostPowerSystem: VcHostPowerSystem;

	declare class VcHostPrimaryAgentNotShortNameEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		primaryAgent: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostProfile
	{
		complianceStatus: String;
		config: VcProfileConfigInfo;
		createdTime: Date;
		description: VcProfileDescription;
		entity: VcManagedEntity[];
		readonly id: String;
		modifiedTime: Date;
		name: String;
		readonly reference: VcManagedObjectReference;
		referenceHost: VcHostSystem;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		associateProfile(entity?: VcManagedEntity[]): void;
		checkProfileCompliance_Task(entity?: VcManagedEntity[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyProfile(): void;
		dissociateProfile(entity?: VcManagedEntity[]): void;
		executeHostProfile(host?: VcHostSystem, deferredParam?: VcProfileDeferredPolicyOptionParameter[]): VcProfileExecuteResult;
		exportProfile(): String;
		retrieveDescription(): VcProfileDescription;
		updateHostProfile(config?: VcHostProfileConfigSpec): void;
		updateReferenceHost(host?: VcHostSystem): void;
	}

	declare const VcHostProfile: VcHostProfile;

	declare class VcHostProfileAppliedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostProfileAttributeCondition
	{
		compareValue: Object;
		compareValue_FloatValue: Number;
		compareValue_IntValue: Number;
		compareValue_LongValue: Number;
		operator: String;

		constructor();
	}

	declare class VcHostProfileCompleteConfigSpec
	{
		annotation: String;
		applyProfile: VcHostApplyProfile;
		customComplyProfile: VcComplianceProfile;
		disabledExpressionList: String[];
		disabledExpressionListChanged: boolean;
		enabled: boolean;
		name: String;
		validating: boolean;
		validatorHost: VcHostSystem;

		constructor();
	}

	declare class VcHostProfileConfigInfo
	{
		annotation: String;
		applyProfile: VcHostApplyProfile;
		customComplyProfile: VcComplianceProfile;
		defaultComplyLocator: VcComplianceLocator[];
		defaultComplyProfile: VcComplianceProfile;
		disabledExpressionList: String[];
		enabled: boolean;
		name: String;

		constructor();
	}

	declare class VcHostProfileConfigSpec
	{
		annotation: String;
		enabled: boolean;
		name: String;

		constructor();
	}

	declare class VcHostProfileHostBasedConfigSpec
	{
		annotation: String;
		enabled: boolean;
		host: VcHostSystem;
		name: String;
		profilesToExtract: String[];
		useHostProfileEngine: boolean;

		constructor();
	}

	interface VcHostProfileManager
	{
		readonly id: String;
		profile: VcProfile[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		supportedCustomizationFormats: VcExtendedElementDescription[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		applyHostConfig_Task(host?: VcHostSystem, configSpec?: VcHostConfigSpec, userInput?: VcProfileDeferredPolicyOptionParameter[]): VcTask;
		checkAnswerFileStatus_Task(host?: VcHostSystem[]): VcTask;
		createDefaultProfile(profileType?: String, profileTypeName?: String, profile?: VcProfile): VcApplyProfile;
		createProfile(createSpec?: VcProfileCreateSpec): VcProfile;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		exportAnswerFile_Task(host?: VcHostSystem): VcTask;
		findAssociatedProfile(entity?: VcManagedEntity): VcProfile[];
		generateConfigTaskList(configSpec?: VcHostConfigSpec, host?: VcHostSystem): VcHostProfileManagerConfigTaskList;
		generateHostProfileTaskList_Task(configSpec?: VcHostConfigSpec, host?: VcHostSystem): VcTask;
		queryAnswerFileStatus(host?: VcHostSystem[]): VcAnswerFileStatusResult[];
		queryHostProfileMetadata(profileName?: String[], profile?: VcProfile): VcProfileMetadata[];
		queryPolicyMetadata(policyName?: String[], profile?: VcProfile): VcProfilePolicyMetadata[];
		queryProfileStructure(profile?: VcProfile): VcProfileProfileStructure;
		retrieveAnswerFile(host?: VcHostSystem): VcAnswerFile;
		retrieveAnswerFileForProfile(host?: VcHostSystem, applyProfile?: VcHostApplyProfile): VcAnswerFile;
		updateAnswerFile_Task(host?: VcHostSystem, configSpec?: VcAnswerFileCreateSpec): VcTask;
	}

	declare const VcHostProfileManager: VcHostProfileManager;

	interface VcHostProfileManagerAnswerFileStatus
	{
		readonly _invalid: String;
		readonly _unknown: String;
		readonly _valid: String;
		readonly id: String;
		readonly invalid: VcHostProfileManagerAnswerFileStatus;
		readonly name: String;
		readonly unknown: VcHostProfileManagerAnswerFileStatus;
		readonly valid: VcHostProfileManagerAnswerFileStatus;
		readonly value: String;

		fromString(value?: String): VcHostProfileManagerAnswerFileStatus;
	}

	interface VcHostProfileManagerAnswerFileStatusConstructor {
		new(value?:any): VcHostProfileManagerAnswerFileStatus;
		readonly prototype: VcHostProfileManagerAnswerFileStatus;
	}

	declare const VcHostProfileManagerAnswerFileStatus: VcHostProfileManagerAnswerFileStatusConstructor;

	declare class VcHostProfileManagerConfigTaskList
	{
		configSpec: VcHostConfigSpec;
		taskDescription: VcLocalizableMessage[];
		taskListRequirement: String[];

		constructor();
	}

	interface VcHostProfileManagerTaskListRequirement
	{
		readonly _maintenanceModeRequired: String;
		readonly _rebootRequired: String;
		readonly id: String;
		readonly maintenanceModeRequired: VcHostProfileManagerTaskListRequirement;
		readonly name: String;
		readonly rebootRequired: VcHostProfileManagerTaskListRequirement;
		readonly value: String;

		fromString(value?: String): VcHostProfileManagerTaskListRequirement;
	}

	interface VcHostProfileManagerTaskListRequirementConstructor {
		new(value?:any): VcHostProfileManagerTaskListRequirement;
		readonly prototype: VcHostProfileManagerTaskListRequirement;
	}

	declare const VcHostProfileManagerTaskListRequirement: VcHostProfileManagerTaskListRequirementConstructor;

	declare class VcHostProfileMapping
	{
		apiId: String;
		data: VcHostProfileMappingProfileMappingData;
		policyMapping: VcHostProfilePolicyMapping[];
		profileTypeName: String;

		constructor();
	}

	declare class VcHostProfileMappingData
	{
		attributePath: String;
		basePath: String;
		condition: VcHostProfileAttributeCondition;
		lookup: VcHostProfileMappingLookup;

		constructor();
	}

	declare class VcHostProfileMappingLookup
	{
		apiMapping: VcHostProfileMappingLookupMappingPair[];
		baseProfilePath: String;
		profileMapping: VcHostProfileMappingLookupMappingPair[];

		constructor();
	}

	declare class VcHostProfileMappingLookupMappingPair
	{
		sourcePath: String;
		targetProfilePath: String;

		constructor();
	}

	declare class VcHostProfileMappingProfileMappingData
	{
		attributePath: String;
		basePath: String;
		condition: VcHostProfileAttributeCondition;
		lookup: VcHostProfileMappingLookup;

		constructor();
	}

	declare class VcHostProfileParameterMapping
	{
		data: VcHostProfileParameterMappingParameterMappingData;
		id: String;

		constructor();
	}

	declare class VcHostProfileParameterMappingParameterMappingData
	{
		attributePath: String;
		basePath: String;
		condition: VcHostProfileAttributeCondition;
		isKey: boolean;
		lookup: VcHostProfileMappingLookup;

		constructor();
	}

	declare class VcHostProfilePolicyMapping
	{
		data: VcHostProfilePolicyMappingPolicyMappingData;
		id: String;
		policyOptionMapping: VcHostProfilePolicyOptionMapping[];

		constructor();
	}

	declare class VcHostProfilePolicyMappingPolicyMappingData
	{
		attributePath: String;
		basePath: String;
		condition: VcHostProfileAttributeCondition;
		lookup: VcHostProfileMappingLookup;

		constructor();
	}

	declare class VcHostProfilePolicyOptionMapping
	{
		data: VcHostProfilePolicyOptionMappingPolicyOptionMappingData;
		id: String;
		parameterMapping: VcHostProfileParameterMapping[];

		constructor();
	}

	declare class VcHostProfilePolicyOptionMappingPolicyOptionMappingData
	{
		attributePath: String;
		basePath: String;
		condition: VcHostProfileAttributeCondition;
		lookup: VcHostProfileMappingLookup;

		constructor();
	}

	declare class VcHostProfileSerializedHostProfileSpec
	{
		annotation: String;
		enabled: boolean;
		name: String;
		profileConfigString: String;
		validating: boolean;
		validatorHost: VcHostSystem;

		constructor();
	}

	declare class VcHostProtocolEndpoint
	{
		deviceId: String;
		hostKey: VcHostSystem[];
		nfsDir: String;
		nfsServer: String;
		peType: String;
		storageArray: String;
		uuid: String;

		constructor();
	}

	interface VcHostProtocolEndpointPEType
	{
		readonly _block: String;
		readonly _nas: String;
		readonly block: VcHostProtocolEndpointPEType;
		readonly id: String;
		readonly name: String;
		readonly nas: VcHostProtocolEndpointPEType;
		readonly value: String;

		fromString(value?: String): VcHostProtocolEndpointPEType;
	}

	interface VcHostProtocolEndpointPETypeConstructor {
		new(value?:any): VcHostProtocolEndpointPEType;
		readonly prototype: VcHostProtocolEndpointPEType;
	}

	declare const VcHostProtocolEndpointPEType: VcHostProtocolEndpointPETypeConstructor;

	declare class VcHostProxySwitch
	{
		configNumPorts: Number;
		dvsName: String;
		dvsUuid: String;
		hostLag: VcHostProxySwitchHostLagConfig[];
		key: String;
		mtu: Number;
		networkReservationSupported: boolean;
		numPorts: Number;
		numPortsAvailable: Number;
		pnic: VcPhysicalNic[];
		spec: VcHostProxySwitchSpec;
		uplinkPort: VcKeyValue[];

		constructor();
	}

	declare class VcHostProxySwitchConfig
	{
		changeOperation: String;
		spec: VcHostProxySwitchSpec;
		uuid: String;

		constructor();
	}

	declare class VcHostProxySwitchHostLagConfig
	{
		lagKey: String;
		lagName: String;
		uplinkPort: VcKeyValue[];

		constructor();
	}

	declare class VcHostProxySwitchSpec
	{
		backing: VcDistributedVirtualSwitchHostMemberBacking;

		constructor();
	}

	declare class VcHostReconnectionFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostReliableMemoryInfo
	{
		memorySize: Number;

		constructor();
	}

	declare class VcHostRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostReplayUnsupportedReason
	{
		readonly _cpuidLimitSet: String;
		readonly _hvDisabled: String;
		readonly _incompatibleCpu: String;
		readonly _incompatibleProduct: String;
		readonly _oldBIOS: String;
		readonly _unknown: String;
		readonly cpuidLimitSet: VcHostReplayUnsupportedReason;
		readonly hvDisabled: VcHostReplayUnsupportedReason;
		readonly id: String;
		readonly incompatibleCpu: VcHostReplayUnsupportedReason;
		readonly incompatibleProduct: VcHostReplayUnsupportedReason;
		readonly name: String;
		readonly oldBIOS: VcHostReplayUnsupportedReason;
		readonly unknown: VcHostReplayUnsupportedReason;
		readonly value: String;

		fromString(value?: String): VcHostReplayUnsupportedReason;
	}

	interface VcHostReplayUnsupportedReasonConstructor {
		new(value?:any): VcHostReplayUnsupportedReason;
		readonly prototype: VcHostReplayUnsupportedReason;
	}

	declare const VcHostReplayUnsupportedReason: VcHostReplayUnsupportedReasonConstructor;

	declare class VcHostResignatureRescanResult
	{
		rescan: VcHostVmfsRescanResult[];
		result: VcDatastore;

		constructor();
	}

	declare class VcHostRuntimeInfo
	{
		bootTime: Date;
		connectionState: VcHostSystemConnectionState;
		cpuCapacityForVm: Number;
		dasHostState: VcClusterDasFdmHostState;
		healthSystemRuntime: VcHealthSystemRuntime;
		hostMaxVirtualDiskCapacity: Number;
		inMaintenanceMode: boolean;
		memoryCapacityForVm: Number;
		networkRuntimeInfo: VcHostRuntimeInfoNetworkRuntimeInfo;
		powerState: VcHostSystemPowerState;
		standbyMode: String;
		tpmPcrValues: VcHostTpmDigestInfo[];
		vFlashResourceRuntimeInfo: VcHostVFlashManagerVFlashResourceRunTimeInfo;
		vsanRuntimeInfo: VcVsanHostRuntimeInfo;

		constructor();
	}

	declare class VcHostRuntimeInfoNetStackInstanceRuntimeInfo
	{
		currentIpV6Enabled: boolean;
		maxNumberOfConnections: Number;
		netStackInstanceKey: String;
		state: String;
		vmknicKeys: String[];

		constructor();
	}

	interface VcHostRuntimeInfoNetStackInstanceRuntimeInfoState
	{
		readonly _activating: String;
		readonly _active: String;
		readonly _deactivating: String;
		readonly _inactive: String;
		readonly activating: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly active: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly deactivating: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly id: String;
		readonly inactive: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
	}

	interface VcHostRuntimeInfoNetStackInstanceRuntimeInfoStateConstructor {
		new(value?:any): VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly prototype: VcHostRuntimeInfoNetStackInstanceRuntimeInfoState;
	}

	declare const VcHostRuntimeInfoNetStackInstanceRuntimeInfoState: VcHostRuntimeInfoNetStackInstanceRuntimeInfoStateConstructor;

	declare class VcHostRuntimeInfoNetworkRuntimeInfo
	{
		netStackInstanceRuntimeInfo: VcHostRuntimeInfoNetStackInstanceRuntimeInfo[];
		networkResourceRuntime: VcHostNetworkResourceRuntime;

		constructor();
	}

	declare class VcHostScsiDisk
	{
		alternateName: VcScsiLunDurableName[];
		canonicalName: String;
		capabilities: VcScsiLunCapabilities;
		capacity: VcHostDiskDimensionsLba;
		descriptor: VcScsiLunDescriptor[];
		deviceName: String;
		devicePath: String;
		deviceType: String;
		displayName: String;
		durableName: VcScsiLunDurableName;
		emulatedDIXDIFEnabled: boolean;
		key: String;
		localDisk: boolean;
		lunType: String;
		model: String;
		operationalState: String[];
		physicalLocation: String[];
		protocolEndpoint: boolean;
		queueDepth: Number;
		revision: String;
		scsiLevel: Number;
		serialNumber: String;
		ssd: boolean;
		standardInquiry: Number[];
		uuid: String;
		vendor: String;
		vsanDiskInfo: VcVsanHostVsanDiskInfo;
		vStorageSupport: String;

		constructor();
	}

	declare class VcHostScsiDiskPartition
	{
		diskName: String;
		partition: Number;

		constructor();
	}

	declare class VcHostScsiTopology
	{
		adapter: VcHostScsiTopologyInterface[];

		constructor();
	}

	declare class VcHostScsiTopologyInterface
	{
		adapter: VcHostHostBusAdapter;
		key: String;
		target: VcHostScsiTopologyTarget[];

		constructor();
	}

	declare class VcHostScsiTopologyLun
	{
		key: String;
		lun: Number;
		scsiLun: VcScsiLun;

		constructor();
	}

	declare class VcHostScsiTopologyTarget
	{
		key: String;
		lun: VcHostScsiTopologyLun[];
		target: Number;
		transport: VcHostTargetTransport;

		constructor();
	}

	declare class VcHostSecuritySpec
	{
		addPermission: VcPermission[];
		adminPassword: String;
		removePermission: VcPermission[];

		constructor();
	}

	declare class VcHostService
	{
		key: String;
		label: String;
		policy: String;
		required: boolean;
		ruleset: String[];
		running: boolean;
		sourcePackage: VcHostServiceSourcePackage;
		uninstallable: boolean;

		constructor();
	}

	declare class VcHostServiceConfig
	{
		serviceId: String;
		startupPolicy: String;

		constructor();
	}

	declare class VcHostServiceInfo
	{
		service: VcHostService[];

		constructor();
	}

	interface VcHostServicePolicy
	{
		readonly _automatic: String;
		readonly _off: String;
		readonly _on: String;
		readonly automatic: VcHostServicePolicy;
		readonly id: String;
		readonly name: String;
		readonly off: VcHostServicePolicy;
		readonly on: VcHostServicePolicy;
		readonly value: String;

		fromString(value?: String): VcHostServicePolicy;
	}

	interface VcHostServicePolicyConstructor {
		new(value?:any): VcHostServicePolicy;
		readonly prototype: VcHostServicePolicy;
	}

	declare const VcHostServicePolicy: VcHostServicePolicyConstructor;

	declare class VcHostServiceSourcePackage
	{
		description: String;
		sourcePackageName: String;

		constructor();
	}

	interface VcHostServiceSystem
	{
		availableField: VcCustomFieldDef[];
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		serviceInfo: VcHostServiceInfo;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		refreshServices(): void;
		restartService(id?: String): void;
		setCustomValue(key?: String, value?: String): void;
		startService(id?: String): void;
		stopService(id?: String): void;
		uninstallService(id?: String): void;
		updateServicePolicy(id?: String, policy?: String): void;
	}

	declare const VcHostServiceSystem: VcHostServiceSystem;

	declare class VcHostServiceTicket
	{
		host: String;
		port: Number;
		service: String;
		serviceVersion: String;
		sessionId: String;
		sslThumbprint: String;

		constructor();
	}

	declare class VcHostShortNameInconsistentEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		shortName: String;
		shortName2: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostShortNameToIpFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		shortName: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostShutdownEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostSnmpAgentCapability
	{
		readonly _COMPLETE: String;
		readonly _CONFIGURATION: String;
		readonly _DIAGNOSTICS: String;
		readonly COMPLETE: VcHostSnmpAgentCapability;
		readonly CONFIGURATION: VcHostSnmpAgentCapability;
		readonly DIAGNOSTICS: VcHostSnmpAgentCapability;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcHostSnmpAgentCapability;
	}

	interface VcHostSnmpAgentCapabilityConstructor {
		new(value?:any): VcHostSnmpAgentCapability;
		readonly prototype: VcHostSnmpAgentCapability;
	}

	declare const VcHostSnmpAgentCapability: VcHostSnmpAgentCapabilityConstructor;

	declare class VcHostSnmpConfigSpec
	{
		enabled: boolean;
		option: VcKeyValue[];
		port: Number;
		readOnlyCommunities: String[];
		trapTargets: VcHostSnmpDestination[];

		constructor();
	}

	declare class VcHostSnmpDestination
	{
		community: String;
		hostName: String;
		port: Number;

		constructor();
	}

	interface VcHostSnmpSystem
	{
		configuration: VcHostSnmpConfigSpec;
		readonly id: String;
		limits: VcHostSnmpSystemAgentLimits;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureSnmpAgent(spec?: VcHostSnmpConfigSpec): void;
		sendTestNotification(): void;
	}

	declare const VcHostSnmpSystem: VcHostSnmpSystem;

	declare class VcHostSnmpSystemAgentLimits
	{
		capability: VcHostSnmpAgentCapability;
		maxBufferSize: Number;
		maxCommunityLength: Number;
		maxReadOnlyCommunities: Number;
		maxTrapDestinations: Number;

		constructor();
	}

	declare class VcHostSriovConfig
	{
		id: String;
		numVirtualFunction: Number;
		passthruEnabled: boolean;
		sriovEnabled: boolean;

		constructor();
	}

	declare class VcHostSriovInfo
	{
		dependentDevice: String;
		id: String;
		maxVirtualFunctionSupported: Number;
		numVirtualFunction: Number;
		numVirtualFunctionRequested: Number;
		passthruActive: boolean;
		passthruCapable: boolean;
		passthruEnabled: boolean;
		sriovActive: boolean;
		sriovCapable: boolean;
		sriovEnabled: boolean;

		constructor();
	}

	declare class VcHostSslThumbprintInfo
	{
		ownerTag: String;
		principal: String;
		sslThumbprints: String[];

		constructor();
	}

	interface VcHostStandbyMode
	{
		readonly _entering: String;
		readonly _exiting: String;
		readonly _in: String;
		readonly _none: String;
		readonly entering: VcHostStandbyMode;
		readonly exiting: VcHostStandbyMode;
		readonly id: String;
		readonly in: VcHostStandbyMode;
		readonly name: String;
		readonly none: VcHostStandbyMode;
		readonly value: String;

		fromString(value?: String): VcHostStandbyMode;
	}

	interface VcHostStandbyModeConstructor {
		new(value?:any): VcHostStandbyMode;
		readonly prototype: VcHostStandbyMode;
	}

	declare const VcHostStandbyMode: VcHostStandbyModeConstructor;

	declare class VcHostStatusChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newStatus: String;
		oldStatus: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostStorageArrayTypePolicyOption
	{
		policy: VcElementDescription;

		constructor();
	}

	declare class VcHostStorageDeviceInfo
	{
		hostBusAdapter: VcHostHostBusAdapter[];
		multipathInfo: VcHostMultipathInfo;
		plugStoreTopology: VcHostPlugStoreTopology;
		scsiLun: VcScsiLun[];
		scsiTopology: VcHostScsiTopology;
		softwareInternetScsiEnabled: boolean;

		constructor();
	}

	declare class VcHostStorageElementInfo
	{
		name: String;
		operationalInfo: VcHostStorageOperationalInfo[];
		status: VcElementDescription;

		constructor();
	}

	declare class VcHostStorageOperationalInfo
	{
		property: String;
		value: String;

		constructor();
	}

	interface VcHostStorageSystem
	{
		availableField: VcCustomFieldDef[];
		fileSystemVolumeInfo: VcHostFileSystemVolumeInfo;
		readonly id: String;
		multipathStateInfo: VcHostMultipathStateInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		storageDeviceInfo: VcHostStorageDeviceInfo;
		systemFile: String[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addInternetScsiSendTargets(iScsiHbaDevice?: String, targets?: VcHostInternetScsiHbaSendTarget[]): void;
		addInternetScsiStaticTargets(iScsiHbaDevice?: String, targets?: VcHostInternetScsiHbaStaticTarget[]): void;
		attachScsiLun(lunUuid?: String): void;
		attachScsiLunEx_Task(lunUuid?: String[]): VcTask;
		attachVmfsExtent(vmfsPath?: String, extent?: VcHostScsiDiskPartition): void;
		changeNFSUserPassword(password?: String): void;
		clearNFSUser(): void;
		computeDiskPartitionInfo(devicePath?: String, layout?: VcHostDiskPartitionLayout, partitionFormat?: String): VcHostDiskPartitionInfo;
		computeDiskPartitionInfoForResize(partition?: VcHostScsiDiskPartition, blockRange?: VcHostDiskPartitionBlockRange, partitionFormat?: String): VcHostDiskPartitionInfo;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteScsiLunState(lunCanonicalName?: String): void;
		deleteVffsVolumeState(vffsUuid?: String): void;
		deleteVmfsVolumeState(vmfsUuid?: String): void;
		destroyVffs(vffsPath?: String): void;
		detachScsiLun(lunUuid?: String): void;
		detachScsiLunEx_Task(lunUuid?: String[]): VcTask;
		disableMultipathPath(pathName?: String): void;
		discoverFcoeHbas(fcoeSpec?: VcFcoeConfigFcoeSpecification): void;
		enableMultipathPath(pathName?: String): void;
		expandVmfsExtent(vmfsPath?: String, extent?: VcHostScsiDiskPartition): void;
		extendVffs(vffsPath?: String, devicePath?: String, spec?: VcHostDiskPartitionSpec): void;
		formatVffs(createSpec?: VcHostVffsSpec): VcHostVffsVolume;
		formatVmfs(createSpec?: VcHostVmfsSpec): VcHostVmfsVolume;
		markAsLocal_Task(scsiDiskUuid?: String): VcTask;
		markAsNonLocal_Task(scsiDiskUuid?: String): VcTask;
		markAsNonSsd_Task(scsiDiskUuid?: String): VcTask;
		markAsSsd_Task(scsiDiskUuid?: String): VcTask;
		markForRemoval(hbaName?: String, remove?: boolean): void;
		mountVffsVolume(vffsUuid?: String): void;
		mountVmfsVolume(vmfsUuid?: String): void;
		mountVmfsVolumeEx_Task(vmfsUuid?: String[]): VcTask;
		queryAvailableSsds(vffsPath?: String): VcHostScsiDisk[];
		queryNFSUser(): VcHostNasVolumeUserInfo;
		queryPathSelectionPolicyOptions(): VcHostPathSelectionPolicyOption[];
		queryStorageArrayTypePolicyOptions(): VcHostStorageArrayTypePolicyOption[];
		queryUnresolvedVmfsVolume(): VcHostUnresolvedVmfsVolume[];
		refreshStorageSystem(): void;
		removeInternetScsiSendTargets(iScsiHbaDevice?: String, targets?: VcHostInternetScsiHbaSendTarget[]): void;
		removeInternetScsiStaticTargets(iScsiHbaDevice?: String, targets?: VcHostInternetScsiHbaStaticTarget[]): void;
		rescanAllHba(): void;
		rescanHba(hbaDevice?: String): void;
		rescanVffs(): void;
		rescanVmfs(): void;
		resolveMultipleUnresolvedVmfsVolumes(resolutionSpec?: VcHostUnresolvedVmfsResolutionSpec[]): VcHostUnresolvedVmfsResolutionResult[];
		resolveMultipleUnresolvedVmfsVolumesEx_Task(resolutionSpec?: VcHostUnresolvedVmfsResolutionSpec[]): VcTask;
		retrieveDiskPartitionInfo(devicePath?: String[]): VcHostDiskPartitionInfo[];
		setCustomValue(key?: String, value?: String): void;
		setMultipathLunPolicy(lunId?: String, policy?: VcHostMultipathInfoLogicalUnitPolicy): void;
		setNFSUser(user?: String, password?: String): void;
		turnDiskLocatorLedOff_Task(scsiDiskUuids?: String[]): VcTask;
		turnDiskLocatorLedOn_Task(scsiDiskUuids?: String[]): VcTask;
		unmapVmfsVolumeEx_Task(vmfsUuid?: String[]): VcTask;
		unmountForceMountedVmfsVolume(vmfsUuid?: String): void;
		unmountVffsVolume(vffsUuid?: String): void;
		unmountVmfsVolume(vmfsUuid?: String): void;
		unmountVmfsVolumeEx_Task(vmfsUuid?: String[]): VcTask;
		updateDiskPartitions(devicePath?: String, spec?: VcHostDiskPartitionSpec): void;
		updateInternetScsiAdvancedOptions(iScsiHbaDevice?: String, targetSet?: VcHostInternetScsiHbaTargetSet, options?: VcHostInternetScsiHbaParamValue[]): void;
		updateInternetScsiAlias(iScsiHbaDevice?: String, iScsiAlias?: String): void;
		updateInternetScsiAuthenticationProperties(iScsiHbaDevice?: String, authenticationProperties?: VcHostInternetScsiHbaAuthenticationProperties, targetSet?: VcHostInternetScsiHbaTargetSet): void;
		updateInternetScsiDigestProperties(iScsiHbaDevice?: String, targetSet?: VcHostInternetScsiHbaTargetSet, digestProperties?: VcHostInternetScsiHbaDigestProperties): void;
		updateInternetScsiDiscoveryProperties(iScsiHbaDevice?: String, discoveryProperties?: VcHostInternetScsiHbaDiscoveryProperties): void;
		updateInternetScsiIPProperties(iScsiHbaDevice?: String, ipProperties?: VcHostInternetScsiHbaIPProperties): void;
		updateInternetScsiName(iScsiHbaDevice?: String, iScsiName?: String): void;
		updateScsiLunDisplayName(lunUuid?: String, displayName?: String): void;
		updateSoftwareInternetScsiEnabled(enabled?: boolean): void;
		upgradeVmfs(vmfsPath?: String): void;
		upgradeVmLayout(): void;
	}

	declare const VcHostStorageSystem: VcHostStorageSystem;

	declare class VcHostStorageSystemDiskLocatorLedResult
	{
		fault: VcLocalizedMethodFault;
		key: String;

		constructor();
	}

	declare class VcHostStorageSystemScsiLunResult
	{
		fault: VcLocalizedMethodFault;
		key: String;

		constructor();
	}

	declare class VcHostStorageSystemVmfsVolumeResult
	{
		fault: VcLocalizedMethodFault;
		key: String;

		constructor();
	}

	declare class VcHostSyncFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcHostSystem
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		capability: VcHostCapability;
		config: VcHostConfigInfo;
		configIssue: VcEvent[];
		configManager: VcHostConfigManager;
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		datastoreBrowser: VcHostDatastoreBrowser;
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		hardware: VcHostHardwareInfo;
		readonly id: String;
		licensableResource: VcHostLicensableResourceInfo;
		name: String;
		network: VcNetwork[];
		readonly network_DistributedVirtualPortgroup: DistributedVirtualPortgroup[];
		readonly network_Network: Network[];
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		runtime: VcHostRuntimeInfo;
		readonly sdkConnection: VcSdkConnection;
		summary: VcHostListSummary;
		systemResources: VcHostSystemResourceInfo;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;
		vm: VcVirtualMachine[];

		acquireCimServicesTicket(): VcHostServiceTicket;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		disconnectHost_Task(): VcTask;
		enterLockdownMode(): void;
		enterMaintenanceMode_Task(timeout?: Number, evacuatePoweredOffVms?: boolean, maintenanceSpec?: VcHostMaintenanceSpec): VcTask;
		exitLockdownMode(): void;
		exitMaintenanceMode_Task(timeout?: Number): VcTask;
		powerDownHostToStandBy_Task(timeoutSec?: Number, evacuatePoweredOffVms?: boolean): VcTask;
		powerUpHostFromStandBy_Task(timeoutSec?: Number): VcTask;
		queryHostConnectionInfo(): VcHostConnectInfo;
		queryMemoryOverhead(memorySize?: Number, videoRamSize?: Number, numVcpus?: Number): Number;
		queryMemoryOverheadEx(vmConfigInfo?: VcVirtualMachineConfigInfo): Number;
		querySystemResourceUsage(): VcHostSystemResourceUsage;
		queryTpmAttestationReport(): VcHostTpmAttestationReport;
		rebootHost_Task(force?: boolean): VcTask;
		reconfigureHostForDAS_Task(): VcTask;
		reconnectHost_Task(cnxSpec?: VcHostConnectSpec, reconnectSpec?: VcHostSystemReconnectSpec): VcTask;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		retrieveHardwareUptime(): Number;
		setCustomValue(key?: String, value?: String): void;
		shutdownHost_Task(force?: boolean): VcTask;
		updateFlags(flagInfo?: VcHostFlagInfo): void;
		updateIpmi(ipmiInfo?: VcHostIpmiInfo): void;
		updateSystemResources(resourceInfo?: VcHostSystemResourceInfo): void;
		updateSystemSwapConfiguration(sysSwapConfig?: VcHostSystemSwapConfiguration): void;
	}

	declare const VcHostSystem: VcHostSystem;

	interface VcHostSystemConnectionState
	{
		readonly _connected: String;
		readonly _disconnected: String;
		readonly _notResponding: String;
		readonly connected: VcHostSystemConnectionState;
		readonly disconnected: VcHostSystemConnectionState;
		readonly id: String;
		readonly name: String;
		readonly notResponding: VcHostSystemConnectionState;
		readonly value: String;

		fromString(value?: String): VcHostSystemConnectionState;
	}

	interface VcHostSystemConnectionStateConstructor {
		new(value?:any): VcHostSystemConnectionState;
		readonly prototype: VcHostSystemConnectionState;
	}

	declare const VcHostSystemConnectionState: VcHostSystemConnectionStateConstructor;

	declare class VcHostSystemHealthInfo
	{
		numericSensorInfo: VcHostNumericSensorInfo[];

		constructor();
	}

	declare class VcHostSystemIdentificationInfo
	{
		identifierType: VcElementDescription;
		identifierValue: String;

		constructor();
	}

	interface VcHostSystemIdentificationInfoIdentifier
	{
		readonly _AssetTag: String;
		readonly _OemSpecificString: String;
		readonly _ServiceTag: String;
		readonly AssetTag: VcHostSystemIdentificationInfoIdentifier;
		readonly id: String;
		readonly name: String;
		readonly OemSpecificString: VcHostSystemIdentificationInfoIdentifier;
		readonly ServiceTag: VcHostSystemIdentificationInfoIdentifier;
		readonly value: String;

		fromString(value?: String): VcHostSystemIdentificationInfoIdentifier;
	}

	interface VcHostSystemIdentificationInfoIdentifierConstructor {
		new(value?:any): VcHostSystemIdentificationInfoIdentifier;
		readonly prototype: VcHostSystemIdentificationInfoIdentifier;
	}

	declare const VcHostSystemIdentificationInfoIdentifier: VcHostSystemIdentificationInfoIdentifierConstructor;

	declare class VcHostSystemInfo
	{
		model: String;
		otherIdentifyingInfo: VcHostSystemIdentificationInfo[];
		uuid: String;
		vendor: String;

		constructor();
	}

	interface VcHostSystemPowerState
	{
		readonly _poweredOff: String;
		readonly _poweredOn: String;
		readonly _standBy: String;
		readonly _unknown: String;
		readonly id: String;
		readonly name: String;
		readonly poweredOff: VcHostSystemPowerState;
		readonly poweredOn: VcHostSystemPowerState;
		readonly standBy: VcHostSystemPowerState;
		readonly unknown: VcHostSystemPowerState;
		readonly value: String;

		fromString(value?: String): VcHostSystemPowerState;
	}

	interface VcHostSystemPowerStateConstructor {
		new(value?:any): VcHostSystemPowerState;
		readonly prototype: VcHostSystemPowerState;
	}

	declare const VcHostSystemPowerState: VcHostSystemPowerStateConstructor;

	declare class VcHostSystemReconnectSpec
	{
		syncState: boolean;

		constructor();
	}

	declare class VcHostSystemResourceInfo
	{
		child: VcHostSystemResourceInfo[];
		config: VcResourceConfigSpec;
		key: String;

		constructor();
	}

	declare class VcHostSystemResourceSpec
	{
		afInetSockets: VcHostSystemResourceSpecResourceSettings;
		afLocalSockets: VcHostSystemResourceSpecResourceSettings;
		changeVersion: String;
		cpuAllocation: VcResourceAllocationInfo;
		diskBlocks: VcHostSystemResourceSpecResourceSettings;
		entity: VcManagedEntity;
		fileDescriptors: VcHostSystemResourceSpecResourceSettings;
		iNodes: VcHostSystemResourceSpecResourceSettings;
		lastModified: Date;
		maxFileSize: VcHostSystemResourceSpecResourceSettings;
		memoryAllocation: VcResourceAllocationInfo;
		networkBandwidthAllocation: VcNetworkBandwidthAllocationInfo[];
		semaphores: VcHostSystemResourceSpecResourceSettings;
		sockets: VcHostSystemResourceSpecResourceSettings;
		threads: VcHostSystemResourceSpecResourceSettings;

		constructor();
	}

	declare class VcHostSystemResourceSpecResourceSettings
	{
		limit: Number;

		constructor();
	}

	declare class VcHostSystemResourceUsage
	{
		afInetSockets: VcHostSystemResourceUsageUsageInfo;
		afLocalSockets: VcHostSystemResourceUsageUsageInfo;
		child: VcHostSystemResourceUsage[];
		cpu: VcHostSystemResourceUsageUsageInfo;
		diskBlocks: VcHostSystemResourceUsageUsageInfo;
		fileDescriptors: VcHostSystemResourceUsageUsageInfo;
		iNodes: VcHostSystemResourceUsageUsageInfo;
		key: String;
		maxFileSize: VcHostSystemResourceUsageUsageInfo;
		memory: VcHostSystemResourceUsageUsageInfo;
		semaphores: VcHostSystemResourceUsageUsageInfo;
		sockets: VcHostSystemResourceUsageUsageInfo;
		threads: VcHostSystemResourceUsageUsageInfo;

		constructor();
	}

	declare class VcHostSystemResourceUsageUsageInfo
	{
		current: Number;
		peak: Number;

		constructor();
	}

	declare class VcHostSystemSwapConfiguration
	{
		option: VcHostSystemSwapConfigurationSystemSwapOption[];

		constructor();
	}

	declare class VcHostSystemSwapConfigurationDatastoreOption
	{
		datastore: String;
		key: Number;

		constructor();
	}

	declare class VcHostSystemSwapConfigurationDisabledOption
	{
		key: Number;

		constructor();
	}

	declare class VcHostSystemSwapConfigurationHostCacheOption
	{
		key: Number;

		constructor();
	}

	declare class VcHostSystemSwapConfigurationHostLocalSwapOption
	{
		key: Number;

		constructor();
	}

	declare class VcHostSystemSwapConfigurationSystemSwapOption
	{
		key: Number;

		constructor();
	}

	declare class VcHostTargetTransport
	{

		constructor();
	}

	declare class VcHostTpmAttestationReport
	{
		tpmEvents: VcHostTpmEventLogEntry[];
		tpmLogReliable: boolean;
		tpmPcrValues: VcHostTpmDigestInfo[];

		constructor();
	}

	declare class VcHostTpmBootSecurityOptionEventDetails
	{
		bootSecurityOption: String;
		dataHash: Number[];

		constructor();
	}

	declare class VcHostTpmCommandEventDetails
	{
		commandLine: String;
		dataHash: Number[];

		constructor();
	}

	declare class VcHostTpmDigestInfo
	{
		digestMethod: String;
		digestValue: Number[];
		objectName: String;
		pcrNumber: Number;

		constructor();
	}

	declare class VcHostTpmEventDetails
	{
		dataHash: Number[];

		constructor();
	}

	declare class VcHostTpmEventLogEntry
	{
		eventDetails: VcHostTpmEventDetails;
		pcrIndex: Number;

		constructor();
	}

	declare class VcHostTpmOptionEventDetails
	{
		bootOptions: Number[];
		dataHash: Number[];
		optionsFileName: String;

		constructor();
	}

	declare class VcHostTpmSoftwareComponentEventDetails
	{
		componentName: String;
		dataHash: Number[];
		vibName: String;
		vibVendor: String;
		vibVersion: String;

		constructor();
	}

	declare class VcHostUnresolvedVmfsExtent
	{
		device: VcHostScsiDiskPartition;
		devicePath: String;
		endBlock: Number;
		isHeadExtent: boolean;
		ordinal: Number;
		reason: String;
		startBlock: Number;
		vmfsUuid: String;

		constructor();
	}

	interface VcHostUnresolvedVmfsExtentUnresolvedReason
	{
		readonly _diskIdMismatch: String;
		readonly _uuidConflict: String;
		readonly diskIdMismatch: VcHostUnresolvedVmfsExtentUnresolvedReason;
		readonly id: String;
		readonly name: String;
		readonly uuidConflict: VcHostUnresolvedVmfsExtentUnresolvedReason;
		readonly value: String;

		fromString(value?: String): VcHostUnresolvedVmfsExtentUnresolvedReason;
	}

	interface VcHostUnresolvedVmfsExtentUnresolvedReasonConstructor {
		new(value?:any): VcHostUnresolvedVmfsExtentUnresolvedReason;
		readonly prototype: VcHostUnresolvedVmfsExtentUnresolvedReason;
	}

	declare const VcHostUnresolvedVmfsExtentUnresolvedReason: VcHostUnresolvedVmfsExtentUnresolvedReasonConstructor;

	declare class VcHostUnresolvedVmfsResignatureSpec
	{
		extentDevicePath: String[];

		constructor();
	}

	declare class VcHostUnresolvedVmfsResolutionResult
	{
		fault: VcLocalizedMethodFault;
		spec: VcHostUnresolvedVmfsResolutionSpec;
		vmfs: VcHostVmfsVolume;

		constructor();
	}

	declare class VcHostUnresolvedVmfsResolutionSpec
	{
		extentDevicePath: String[];
		uuidResolution: String;

		constructor();
	}

	interface VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution
	{
		readonly _forceMount: String;
		readonly _resignature: String;
		readonly forceMount: VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
		readonly id: String;
		readonly name: String;
		readonly resignature: VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
		readonly value: String;

		fromString(value?: String): VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
	}

	interface VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolutionConstructor {
		new(value?:any): VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
		readonly prototype: VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
	}

	declare const VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution: VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolutionConstructor;

	declare class VcHostUnresolvedVmfsVolume
	{
		extent: VcHostUnresolvedVmfsExtent[];
		resolveStatus: VcHostUnresolvedVmfsVolumeResolveStatus;
		totalBlocks: Number;
		vmfsLabel: String;
		vmfsUuid: String;

		constructor();
	}

	declare class VcHostUnresolvedVmfsVolumeResolveStatus
	{
		incompleteExtents: boolean;
		multipleCopies: boolean;
		resolvable: boolean;

		constructor();
	}

	declare class VcHostUpdateProxyConfigInfo
	{
		cacheLocation: String;
		cachePruningLimits: Number;
		cacheSize: Number;
		repoLocation: String;

		constructor();
	}

	declare class VcHostUpgradeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostUserWorldSwapNotEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostVfatVolume
	{
		capacity: Number;
		name: String;
		type: String;

		constructor();
	}

	declare class VcHostVffsSpec
	{
		devicePath: String;
		majorVersion: Number;
		partition: VcHostDiskPartitionSpec;
		volumeName: String;

		constructor();
	}

	declare class VcHostVffsVolume
	{
		capacity: Number;
		extent: VcHostScsiDiskPartition[];
		majorVersion: Number;
		name: String;
		type: String;
		uuid: String;
		version: String;

		constructor();
	}

	interface VcHostVFlashManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		vFlashConfigInfo: VcHostVFlashManagerVFlashConfigInfo;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		configureVFlashResourceEx_Task(devicePath?: String[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		hostConfigureVFlashResource(spec?: VcHostVFlashManagerVFlashResourceConfigSpec): void;
		hostConfigVFlashCache(spec?: VcHostVFlashManagerVFlashCacheConfigSpec): void;
		hostGetVFlashModuleDefaultConfig(vFlashModule?: String): VcVirtualDiskVFlashCacheConfigInfo;
		hostRemoveVFlashResource(): void;
	}

	declare const VcHostVFlashManager: VcHostVFlashManager;

	declare class VcHostVFlashManagerVFlashCacheConfigInfo
	{
		defaultVFlashModule: String;
		swapCacheReservationInGB: Number;
		vFlashModuleConfigOption: VcHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption[];

		constructor();
	}

	declare class VcHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption
	{
		blockSizeInKBOption: VcLongOption;
		cacheConsistencyType: VcChoiceOption;
		cacheMode: VcChoiceOption;
		maxDiskSizeInKB: Number;
		minSupportedModuleVersion: String;
		reservationInMBOption: VcLongOption;
		vFlashModule: String;
		vFlashModuleVersion: String;

		constructor();
	}

	declare class VcHostVFlashManagerVFlashCacheConfigSpec
	{
		defaultVFlashModule: String;
		swapCacheReservationInGB: Number;

		constructor();
	}

	declare class VcHostVFlashManagerVFlashConfigInfo
	{
		vFlashCacheConfigInfo: VcHostVFlashManagerVFlashCacheConfigInfo;
		vFlashResourceConfigInfo: VcHostVFlashManagerVFlashResourceConfigInfo;

		constructor();
	}

	declare class VcHostVFlashManagerVFlashResourceConfigInfo
	{
		capacity: Number;
		vffs: VcHostVffsVolume;

		constructor();
	}

	declare class VcHostVFlashManagerVFlashResourceConfigSpec
	{
		vffsUuid: String;

		constructor();
	}

	declare class VcHostVFlashManagerVFlashResourceRunTimeInfo
	{
		accessible: boolean;
		capacity: Number;
		capacityForVmCache: Number;
		freeForVmCache: Number;
		usage: Number;

		constructor();
	}

	declare class VcHostVFlashResourceConfigurationResult
	{
		devicePath: String[];
		diskConfigurationResult: VcHostDiskConfigurationResult[];
		vffs: VcHostVffsVolume;

		constructor();
	}

	declare class VcHostVirtualNic
	{
		device: String;
		key: String;
		port: VcHostPortGroupPort;
		portgroup: String;
		spec: VcHostVirtualNicSpec;

		constructor();
	}

	declare class VcHostVirtualNicConfig
	{
		changeOperation: String;
		device: String;
		portgroup: String;
		spec: VcHostVirtualNicSpec;

		constructor();
	}

	declare class VcHostVirtualNicConnection
	{
		dvPort: VcDistributedVirtualSwitchPortConnection;
		portgroup: String;

		constructor();
	}

	interface VcHostVirtualNicManager
	{
		availableField: VcCustomFieldDef[];
		readonly id: String;
		info: VcHostVirtualNicManagerInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deselectVnicForNicType(nicType?: String, device?: String): void;
		queryNetConfig(nicType?: String): VcVirtualNicManagerNetConfig;
		selectVnicForNicType(nicType?: String, device?: String): void;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcHostVirtualNicManager: VcHostVirtualNicManager;

	declare class VcHostVirtualNicManagerInfo
	{
		netConfig: VcVirtualNicManagerNetConfig[];

		constructor();
	}

	interface VcHostVirtualNicManagerNicType
	{
		readonly _faultToleranceLogging: String;
		readonly _management: String;
		readonly _vmotion: String;
		readonly _vsan: String;
		readonly _vSphereProvisioning: String;
		readonly _vSphereReplication: String;
		readonly _vSphereReplicationNFC: String;
		readonly faultToleranceLogging: VcHostVirtualNicManagerNicType;
		readonly id: String;
		readonly management: VcHostVirtualNicManagerNicType;
		readonly name: String;
		readonly value: String;
		readonly vmotion: VcHostVirtualNicManagerNicType;
		readonly vsan: VcHostVirtualNicManagerNicType;
		readonly vSphereProvisioning: VcHostVirtualNicManagerNicType;
		readonly vSphereReplication: VcHostVirtualNicManagerNicType;
		readonly vSphereReplicationNFC: VcHostVirtualNicManagerNicType;

		fromString(value?: String): VcHostVirtualNicManagerNicType;
	}

	interface VcHostVirtualNicManagerNicTypeConstructor {
		new(value?:any): VcHostVirtualNicManagerNicType;
		readonly prototype: VcHostVirtualNicManagerNicType;
	}

	declare const VcHostVirtualNicManagerNicType: VcHostVirtualNicManagerNicTypeConstructor;

	declare class VcHostVirtualNicManagerNicTypeSelection
	{
		nicType: String[];
		vnic: VcHostVirtualNicConnection;

		constructor();
	}

	declare class VcHostVirtualNicOpaqueNetworkSpec
	{
		opaqueNetworkId: String;
		opaqueNetworkType: String;

		constructor();
	}

	declare class VcHostVirtualNicSpec
	{
		distributedVirtualPort: VcDistributedVirtualSwitchPortConnection;
		externalId: String;
		ip: VcHostIpConfig;
		mac: String;
		mtu: Number;
		netStackInstanceKey: String;
		opaqueNetwork: VcHostVirtualNicOpaqueNetworkSpec;
		pinnedPnic: String;
		portgroup: String;
		tsoEnabled: boolean;

		constructor();
	}

	declare class VcHostVirtualSwitch
	{
		key: String;
		mtu: Number;
		name: String;
		numPorts: Number;
		numPortsAvailable: Number;
		pnic: VcPhysicalNic[];
		portgroup: VcHostPortGroup[];
		spec: VcHostVirtualSwitchSpec;

		constructor();
	}

	declare class VcHostVirtualSwitchAutoBridge
	{
		excludedNicDevice: String[];

		constructor();
	}

	declare class VcHostVirtualSwitchBeaconConfig
	{
		interval: Number;

		constructor();
	}

	declare class VcHostVirtualSwitchBondBridge
	{
		beacon: VcHostVirtualSwitchBeaconConfig;
		linkDiscoveryProtocolConfig: VcLinkDiscoveryProtocolConfig;
		nicDevice: String[];

		constructor();
	}

	declare class VcHostVirtualSwitchBridge
	{

		constructor();
	}

	declare class VcHostVirtualSwitchConfig
	{
		changeOperation: String;
		name: String;
		spec: VcHostVirtualSwitchSpec;

		constructor();
	}

	declare class VcHostVirtualSwitchSimpleBridge
	{
		nicDevice: String;

		constructor();
	}

	declare class VcHostVirtualSwitchSpec
	{
		bridge: VcHostVirtualSwitchBridge;
		mtu: Number;
		numPorts: Number;
		policy: VcHostNetworkPolicy;

		constructor();
	}

	declare class VcHostVmciAccessManagerAccessSpec
	{
		mode: String;
		services: String[];
		vm: VcVirtualMachine;

		constructor();
	}

	interface VcHostVmciAccessManagerMode
	{
		readonly _grant: String;
		readonly _replace: String;
		readonly _revoke: String;
		readonly grant: VcHostVmciAccessManagerMode;
		readonly id: String;
		readonly name: String;
		readonly replace: VcHostVmciAccessManagerMode;
		readonly revoke: VcHostVmciAccessManagerMode;
		readonly value: String;

		fromString(value?: String): VcHostVmciAccessManagerMode;
	}

	interface VcHostVmciAccessManagerModeConstructor {
		new(value?:any): VcHostVmciAccessManagerMode;
		readonly prototype: VcHostVmciAccessManagerMode;
	}

	declare const VcHostVmciAccessManagerMode: VcHostVmciAccessManagerModeConstructor;

	declare class VcHostVmfsRescanResult
	{
		fault: VcLocalizedMethodFault;
		host: VcHostSystem;

		constructor();
	}

	declare class VcHostVmfsSpec
	{
		blockSizeMb: Number;
		extent: VcHostScsiDiskPartition;
		majorVersion: Number;
		volumeName: String;

		constructor();
	}

	declare class VcHostVmfsVolume
	{
		blockSizeMb: Number;
		capacity: Number;
		extent: VcHostScsiDiskPartition[];
		forceMountedInfo: VcHostForceMountedInfo;
		local: boolean;
		majorVersion: Number;
		maxBlocks: Number;
		name: String;
		ssd: boolean;
		type: String;
		uuid: String;
		version: String;
		vmfsUpgradable: boolean;

		constructor();
	}

	declare class VcHostVMotionCompatibility
	{
		compatibility: String[];
		host: VcHostSystem;

		constructor();
	}

	declare class VcHostVMotionConfig
	{
		enabled: boolean;
		vmotionNicKey: String;

		constructor();
	}

	declare class VcHostVMotionInfo
	{
		ipConfig: VcHostIpConfig;
		netConfig: VcHostVMotionNetConfig;

		constructor();
	}

	declare class VcHostVMotionNetConfig
	{
		candidateVnic: VcHostVirtualNic[];
		selectedVnic: VcHostVirtualNic;

		constructor();
	}

	interface VcHostVMotionSystem
	{
		availableField: VcCustomFieldDef[];
		readonly id: String;
		ipConfig: VcHostIpConfig;
		netConfig: VcHostVMotionNetConfig;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deselectVnic(): void;
		selectVnic(device?: String): void;
		setCustomValue(key?: String, value?: String): void;
		updateIpConfig(ipConfig?: VcHostIpConfig): void;
	}

	declare const VcHostVMotionSystem: VcHostVMotionSystem;

	declare class VcHostVnicConnectedToCustomizedDVPortEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;
		vnic: VcVnicPortArgument;

		constructor();
	}

	interface VcHostVsanInternalSystem
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		abdicateDomOwnership(uuids?: String[]): String[];
		canProvisionObjects(npbs?: VcVsanNewPolicyBatch[], ignoreSatisfiability?: boolean): VcVsanPolicySatisfiability[];
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		deleteVsanObjects(uuids?: String[], force?: boolean): VcHostVsanInternalSystemDeleteVsanObjectsResult[];
		getVsanObjExtAttrs(uuids?: String[]): String;
		queryCmmds(queries?: VcHostVsanInternalSystemCmmdsQuery[]): String;
		queryObjectsOnPhysicalVsanDisk(disks?: String[]): String;
		queryPhysicalVsanDisks(props?: String[]): String;
		querySyncingVsanObjects(uuids?: String[]): String;
		queryVsanObjects(uuids?: String[]): String;
		queryVsanObjectUuidsByFilter(uuids?: String[], limit?: Number, version?: Number): String[];
		queryVsanStatistics(labels?: String[]): String;
		reconfigurationSatisfiable(pcbs?: VcVsanPolicyChangeBatch[], ignoreSatisfiability?: boolean): VcVsanPolicySatisfiability[];
		reconfigureDomObject(uuid?: String, policy?: String): void;
		runVsanPhysicalDiskDiagnostics(disks?: String[]): VcHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult[];
		upgradeVsanObjects(uuids?: String[], newVersion?: Number): VcHostVsanInternalSystemVsanObjectOperationResult[];
	}

	declare const VcHostVsanInternalSystem: VcHostVsanInternalSystem;

	declare class VcHostVsanInternalSystemCmmdsQuery
	{
		owner: String;
		type: String;
		uuid: String;

		constructor();
	}

	declare class VcHostVsanInternalSystemDeleteVsanObjectsResult
	{
		failureReason: VcLocalizableMessage[];
		success: boolean;
		uuid: String;

		constructor();
	}

	declare class VcHostVsanInternalSystemVsanObjectOperationResult
	{
		failureReason: VcLocalizableMessage[];
		uuid: String;

		constructor();
	}

	declare class VcHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult
	{
		diskUuid: String;
		failureReason: String;
		success: boolean;

		constructor();
	}

	interface VcHostVsanSystem
	{
		config: VcVsanHostConfigInfo;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addDisks_Task(disk?: VcHostScsiDisk[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		evacuateVsanNode_Task(maintenanceSpec?: VcHostMaintenanceSpec, timeout?: Number): VcTask;
		initializeDisks_Task(mapping?: VcVsanHostDiskMapping[]): VcTask;
		queryDisksForVsan(canonicalName?: String[]): VcVsanHostDiskResult[];
		queryHostStatus(): VcVsanHostClusterStatus;
		recommissionVsanNode_Task(): VcTask;
		removeDisk_Task(disk?: VcHostScsiDisk[], maintenanceSpec?: VcHostMaintenanceSpec, timeout?: Number): VcTask;
		removeDiskMapping_Task(mapping?: VcVsanHostDiskMapping[], maintenanceSpec?: VcHostMaintenanceSpec, timeout?: Number): VcTask;
		unmountDiskMapping_Task(mapping?: VcVsanHostDiskMapping[]): VcTask;
		updateVsan_Task(config?: VcVsanHostConfigInfo): VcTask;
	}

	declare const VcHostVsanSystem: VcHostVsanSystem;

	declare class VcHostVvolVolume
	{
		capacity: Number;
		hostPE: VcVVolHostPE[];
		name: String;
		scId: String;
		storageArray: VcVASAStorageArray[];
		type: String;
		vasaProviderInfo: VcVimVasaProviderInfo[];

		constructor();
	}

	declare class VcHostVvolVolumeSpecification
	{
		maxSizeInMB: Number;
		storageArray: VcVASAStorageArray[];
		uuid: String;
		vasaProviderInfo: VcVimVasaProviderInfo[];
		volumeName: String;

		constructor();
	}

	declare class VcHostWwnChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newNodeWwns: Number[];
		newPortWwns: Number[];
		oldNodeWwns: Number[];
		oldPortWwns: Number[];
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcHostWwnConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedHosts: VcHostEventArgument[];
		conflictedVms: VcVmEventArgument[];
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;
		wwn: Number;

		constructor();
	}

	declare class VcHourlyTaskScheduler
	{
		activeTime: Date;
		expireTime: Date;
		interval: Number;
		minute: Number;

		constructor();
	}

	interface VcHttpNfcLease
	{
		error: VcLocalizedMethodFault;
		readonly id: String;
		info: VcHttpNfcLeaseInfo;
		initializeProgress: Number;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		state: VcHttpNfcLeaseState;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		httpNfcLeaseAbort(fault?: VcMethodFault): void;
		httpNfcLeaseComplete(): void;
		httpNfcLeaseGetManifest(): VcHttpNfcLeaseManifestEntry[];
		httpNfcLeaseProgress(percent?: Number): void;
	}

	declare const VcHttpNfcLease: VcHttpNfcLease;

	declare class VcHttpNfcLeaseDatastoreLeaseInfo
	{
		datastoreKey: String;
		hosts: VcHttpNfcLeaseHostInfo[];

		constructor();
	}

	declare class VcHttpNfcLeaseDeviceUrl
	{
		datastoreKey: String;
		disk: boolean;
		fileSize: Number;
		importKey: String;
		key: String;
		sslThumbprint: String;
		targetId: String;
		url: String;

		constructor();
	}

	declare class VcHttpNfcLeaseHostInfo
	{
		sslThumbprint: String;
		url: String;

		constructor();
	}

	declare class VcHttpNfcLeaseInfo
	{
		deviceUrl: VcHttpNfcLeaseDeviceUrl[];
		entity: VcManagedEntity;
		hostMap: VcHttpNfcLeaseDatastoreLeaseInfo[];
		lease: VcHttpNfcLease;
		leaseTimeout: Number;
		totalDiskCapacityInKB: Number;

		constructor();
	}

	declare class VcHttpNfcLeaseManifestEntry
	{
		capacity: Number;
		disk: boolean;
		key: String;
		populatedSize: Number;
		sha1: String;
		size: Number;

		constructor();
	}

	interface VcHttpNfcLeaseState
	{
		readonly _done: String;
		readonly _error: String;
		readonly _initializing: String;
		readonly _ready: String;
		readonly done: VcHttpNfcLeaseState;
		readonly error: VcHttpNfcLeaseState;
		readonly id: String;
		readonly initializing: VcHttpNfcLeaseState;
		readonly name: String;
		readonly ready: VcHttpNfcLeaseState;
		readonly value: String;

		fromString(value?: String): VcHttpNfcLeaseState;
	}

	interface VcHttpNfcLeaseStateConstructor {
		new(value?:any): VcHttpNfcLeaseState;
		readonly prototype: VcHttpNfcLeaseState;
	}

	declare const VcHttpNfcLeaseState: VcHttpNfcLeaseStateConstructor;

	declare class VcImportOperationBulkFaultFaultOnImport
	{
		entityType: String;
		fault: VcLocalizedMethodFault;
		key: String;

		constructor();
	}

	declare class VcImportSpec
	{
		entityConfig: VcVAppEntityConfigInfo;
		instantiationOst: VcOvfConsumerOstNode;

		constructor();
	}

	interface VcIncompatibleHostForVmReplicationIncompatibleReason
	{
		readonly _netCompression: String;
		readonly _rpo: String;
		readonly id: String;
		readonly name: String;
		readonly netCompression: VcIncompatibleHostForVmReplicationIncompatibleReason;
		readonly rpo: VcIncompatibleHostForVmReplicationIncompatibleReason;
		readonly value: String;

		fromString(value?: String): VcIncompatibleHostForVmReplicationIncompatibleReason;
	}

	interface VcIncompatibleHostForVmReplicationIncompatibleReasonConstructor {
		new(value?:any): VcIncompatibleHostForVmReplicationIncompatibleReason;
		readonly prototype: VcIncompatibleHostForVmReplicationIncompatibleReason;
	}

	declare const VcIncompatibleHostForVmReplicationIncompatibleReason: VcIncompatibleHostForVmReplicationIncompatibleReasonConstructor;

	declare class VcIncorrectHostInformationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcInfoUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcInheritablePolicy
	{
		inherited: boolean;

		constructor();
	}

	declare class VcInsufficientFailoverResourcesEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcInternetScsiSnsDiscoveryMethod
	{
		readonly _isnsDhcp: String;
		readonly _isnsSlp: String;
		readonly _isnsStatic: String;
		readonly id: String;
		readonly isnsDhcp: VcInternetScsiSnsDiscoveryMethod;
		readonly isnsSlp: VcInternetScsiSnsDiscoveryMethod;
		readonly isnsStatic: VcInternetScsiSnsDiscoveryMethod;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcInternetScsiSnsDiscoveryMethod;
	}

	interface VcInternetScsiSnsDiscoveryMethodConstructor {
		new(value?:any): VcInternetScsiSnsDiscoveryMethod;
		readonly prototype: VcInternetScsiSnsDiscoveryMethod;
	}

	declare const VcInternetScsiSnsDiscoveryMethod: VcInternetScsiSnsDiscoveryMethodConstructor;

	declare class VcIntExpression
	{
		negate: boolean;
		value: Number;

		constructor();
	}

	declare class VcIntOption
	{
		defaultValue: Number;
		max: Number;
		min: Number;
		valueIsReadonly: boolean;

		constructor();
	}

	declare class VcIntPolicy
	{
		inherited: boolean;
		value: Number;

		constructor();
	}

	interface VcInvalidDasConfigArgumentEntryForInvalidArgument
	{
		readonly _admissionControl: String;
		readonly _userHeartbeatDs: String;
		readonly _vmConfig: String;
		readonly admissionControl: VcInvalidDasConfigArgumentEntryForInvalidArgument;
		readonly id: String;
		readonly name: String;
		readonly userHeartbeatDs: VcInvalidDasConfigArgumentEntryForInvalidArgument;
		readonly value: String;
		readonly vmConfig: VcInvalidDasConfigArgumentEntryForInvalidArgument;

		fromString(value?: String): VcInvalidDasConfigArgumentEntryForInvalidArgument;
	}

	interface VcInvalidDasConfigArgumentEntryForInvalidArgumentConstructor {
		new(value?:any): VcInvalidDasConfigArgumentEntryForInvalidArgument;
		readonly prototype: VcInvalidDasConfigArgumentEntryForInvalidArgument;
	}

	declare const VcInvalidDasConfigArgumentEntryForInvalidArgument: VcInvalidDasConfigArgumentEntryForInvalidArgumentConstructor;

	declare class VcInvalidEditionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		feature: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcInvalidProfileReferenceHostReason
	{
		readonly _incompatibleVersion: String;
		readonly _missingReferenceHost: String;
		readonly id: String;
		readonly incompatibleVersion: VcInvalidProfileReferenceHostReason;
		readonly missingReferenceHost: VcInvalidProfileReferenceHostReason;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcInvalidProfileReferenceHostReason;
	}

	interface VcInvalidProfileReferenceHostReasonConstructor {
		new(value?:any): VcInvalidProfileReferenceHostReason;
		readonly prototype: VcInvalidProfileReferenceHostReason;
	}

	declare const VcInvalidProfileReferenceHostReason: VcInvalidProfileReferenceHostReasonConstructor;

	declare class VcInventoryDescription
	{
		numClusters: Number;
		numCpuDev: Number;
		numDiskDev: Number;
		numHosts: Number;
		numNetDev: Number;
		numResourcePools: Number;
		numvCpuDev: Number;
		numvDiskDev: Number;
		numVirtualMachines: Number;
		numvNetDev: Number;

		constructor();
	}

	interface VcInventoryView
	{

	}

	declare const VcInventoryView: VcInventoryView;

	declare class VcIoFilterHostIssue
	{
		host: VcHostSystem;
		issue: VcLocalizedMethodFault[];

		constructor();
	}

	declare class VcIoFilterInfo
	{
		id: String;
		name: String;
		releaseDate: String;
		summary: String;
		vendor: String;
		version: String;

		constructor();
	}

	interface VcIoFilterManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		installIoFilter_Task(vibUrl?: String, compRes?: VcComputeResource): VcTask;
		queryDisksUsingFilter(filterId?: String, compRes?: VcComputeResource): VcVirtualDiskId[];
		queryIoFilterInfo(compRes?: VcComputeResource): VcClusterIoFilterInfo[];
		queryIoFilterIssues(filterId?: String, compRes?: VcComputeResource): VcIoFilterQueryIssueResult;
		resolveInstallationErrorsOnCluster_Task(filterId?: String, cluster?: VcClusterComputeResource): VcTask;
		resolveInstallationErrorsOnHost_Task(filterId?: String, host?: VcHostSystem): VcTask;
		uninstallIoFilter_Task(filterId?: String, compRes?: VcComputeResource): VcTask;
		upgradeIoFilter_Task(filterId?: String, compRes?: VcComputeResource, vibUrl?: String): VcTask;
	}

	declare const VcIoFilterManager: VcIoFilterManager;

	interface VcIoFilterOperation
	{
		readonly _install: String;
		readonly _uninstall: String;
		readonly _upgrade: String;
		readonly id: String;
		readonly install: VcIoFilterOperation;
		readonly name: String;
		readonly uninstall: VcIoFilterOperation;
		readonly upgrade: VcIoFilterOperation;
		readonly value: String;

		fromString(value?: String): VcIoFilterOperation;
	}

	interface VcIoFilterOperationConstructor {
		new(value?:any): VcIoFilterOperation;
		readonly prototype: VcIoFilterOperation;
	}

	declare const VcIoFilterOperation: VcIoFilterOperationConstructor;

	declare class VcIoFilterQueryIssueResult
	{
		hostIssue: VcIoFilterHostIssue[];
		opType: String;

		constructor();
	}

	declare class VcIpAddress
	{
		negate: boolean;

		constructor();
	}

	declare class VcIpAddressProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcIpPool
	{
		allocatedIpv4Addresses: Number;
		allocatedIpv6Addresses: Number;
		availableIpv4Addresses: Number;
		availableIpv6Addresses: Number;
		dnsDomain: String;
		dnsSearchPath: String;
		hostPrefix: String;
		httpProxy: String;
		id: Number;
		ipv4Config: VcIpPoolIpPoolConfigInfo;
		ipv6Config: VcIpPoolIpPoolConfigInfo;
		name: String;
		networkAssociation: VcIpPoolAssociation[];

		constructor();
	}

	declare class VcIpPoolAssociation
	{
		network: VcNetwork;
		networkName: String;

		constructor();
	}

	declare class VcIpPoolIpPoolConfigInfo
	{
		dhcpServerAvailable: boolean;
		dns: String[];
		gateway: String;
		ipPoolEnabled: boolean;
		netmask: String;
		range: String;
		subnetAddress: String;

		constructor();
	}

	interface VcIpPoolManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		allocateIpv4Address(dc?: VcDatacenter, poolId?: Number, allocationId?: String): String;
		allocateIpv6Address(dc?: VcDatacenter, poolId?: Number, allocationId?: String): String;
		createIpPool(dc?: VcDatacenter, pool?: VcIpPool): Number;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyIpPool(dc?: VcDatacenter, id?: Number, force?: boolean): void;
		queryIPAllocations(dc?: VcDatacenter, poolId?: Number, extensionKey?: String): VcIpPoolManagerIpAllocation[];
		queryIpPools(dc?: VcDatacenter): VcIpPool[];
		releaseIpAllocation(dc?: VcDatacenter, poolId?: Number, allocationId?: String): void;
		updateIpPool(dc?: VcDatacenter, pool?: VcIpPool): void;
	}

	declare const VcIpPoolManager: VcIpPoolManager;

	declare class VcIpPoolManagerIpAllocation
	{
		allocationId: String;
		ipAddress: String;

		constructor();
	}

	declare class VcIpRange
	{
		addressPrefix: String;
		negate: boolean;
		prefixLength: Number;

		constructor();
	}

	declare class VcIpRouteProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		staticRoute: VcStaticRouteProfile[];

		constructor();
	}

	declare class VcIScsiBootFailureEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcIscsiDependencyEntity
	{
		pnicDevice: String;
		vmhbaName: String;
		vnicDevice: String;

		constructor();
	}

	interface VcIscsiManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		bindVnic(iScsiHbaName?: String, vnicDevice?: String): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryBoundVnics(iScsiHbaName?: String): VcIscsiPortInfo[];
		queryCandidateNics(iScsiHbaName?: String): VcIscsiPortInfo[];
		queryMigrationDependencies(pnicDevice?: String[]): VcIscsiMigrationDependency;
		queryPnicStatus(pnicDevice?: String): VcIscsiStatus;
		queryVnicStatus(vnicDevice?: String): VcIscsiStatus;
		unbindVnic(iScsiHbaName?: String, vnicDevice?: String, force?: boolean): void;
	}

	declare const VcIscsiManager: VcIscsiManager;

	declare class VcIscsiMigrationDependency
	{
		dependency: VcIscsiDependencyEntity[];
		disallowReason: VcIscsiStatus;
		migrationAllowed: boolean;

		constructor();
	}

	declare class VcIscsiPortInfo
	{
		complianceStatus: VcIscsiStatus;
		pathStatus: String;
		pnic: VcPhysicalNic;
		pnicDevice: String;
		portgroupKey: String;
		portgroupName: String;
		portKey: String;
		switchName: String;
		switchUuid: String;
		vnic: VcHostVirtualNic;
		vnicDevice: String;

		constructor();
	}

	interface VcIscsiPortInfoPathStatus
	{
		readonly _active: String;
		readonly _lastActive: String;
		readonly _notUsed: String;
		readonly _standBy: String;
		readonly active: VcIscsiPortInfoPathStatus;
		readonly id: String;
		readonly lastActive: VcIscsiPortInfoPathStatus;
		readonly name: String;
		readonly notUsed: VcIscsiPortInfoPathStatus;
		readonly standBy: VcIscsiPortInfoPathStatus;
		readonly value: String;

		fromString(value?: String): VcIscsiPortInfoPathStatus;
	}

	interface VcIscsiPortInfoPathStatusConstructor {
		new(value?:any): VcIscsiPortInfoPathStatus;
		readonly prototype: VcIscsiPortInfoPathStatus;
	}

	declare const VcIscsiPortInfoPathStatus: VcIscsiPortInfoPathStatusConstructor;

	declare class VcIscsiStatus
	{
		reason: VcLocalizedMethodFault[];

		constructor();
	}

	declare class VcIsoImageFileInfo
	{
		fileSize: Number;
		modification: Date;
		owner: String;
		path: String;

		constructor();
	}

	declare class VcIsoImageFileQuery
	{

		constructor();
	}

	declare class VcKernelModuleInfo
	{
		bssSection: VcKernelModuleSectionInfo;
		dataSection: VcKernelModuleSectionInfo;
		enabled: boolean;
		filename: String;
		id: Number;
		loaded: boolean;
		name: String;
		optionString: String;
		readOnlySection: VcKernelModuleSectionInfo;
		textSection: VcKernelModuleSectionInfo;
		useCount: Number;
		version: String;
		writableSection: VcKernelModuleSectionInfo;

		constructor();
	}

	declare class VcKernelModuleSectionInfo
	{
		address: Number;
		length: Number;

		constructor();
	}

	declare class VcKeyAnyValue
	{
		key: String;
		value: Object;
		value_FloatValue: Number;
		value_IntValue: Number;
		value_LongValue: Number;

		constructor();
	}

	declare class VcKeyValue
	{
		key: String;
		value: String;

		constructor();
	}

	declare class VcLatencySensitivity
	{
		level: VcLatencySensitivitySensitivityLevel;
		sensitivity: Number;

		constructor();
	}

	interface VcLatencySensitivitySensitivityLevel
	{
		readonly _custom: String;
		readonly _high: String;
		readonly _low: String;
		readonly _medium: String;
		readonly _normal: String;
		readonly custom: VcLatencySensitivitySensitivityLevel;
		readonly high: VcLatencySensitivitySensitivityLevel;
		readonly id: String;
		readonly low: VcLatencySensitivitySensitivityLevel;
		readonly medium: VcLatencySensitivitySensitivityLevel;
		readonly name: String;
		readonly normal: VcLatencySensitivitySensitivityLevel;
		readonly value: String;

		fromString(value?: String): VcLatencySensitivitySensitivityLevel;
	}

	interface VcLatencySensitivitySensitivityLevelConstructor {
		new(value?:any): VcLatencySensitivitySensitivityLevel;
		readonly prototype: VcLatencySensitivitySensitivityLevel;
	}

	declare const VcLatencySensitivitySensitivityLevel: VcLatencySensitivitySensitivityLevelConstructor;

	interface VcLicenseAssignmentFailedReason
	{
		readonly _downgradeDisallowed: String;
		readonly _hostsUnmanageableByVirtualCenterWithoutLicenseServer: String;
		readonly _inventoryNotManageableByVirtualCenter: String;
		readonly _keyEntityMismatch: String;
		readonly downgradeDisallowed: VcLicenseAssignmentFailedReason;
		readonly hostsUnmanageableByVirtualCenterWithoutLicenseServer: VcLicenseAssignmentFailedReason;
		readonly id: String;
		readonly inventoryNotManageableByVirtualCenter: VcLicenseAssignmentFailedReason;
		readonly keyEntityMismatch: VcLicenseAssignmentFailedReason;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcLicenseAssignmentFailedReason;
	}

	interface VcLicenseAssignmentFailedReasonConstructor {
		new(value?:any): VcLicenseAssignmentFailedReason;
		readonly prototype: VcLicenseAssignmentFailedReason;
	}

	declare const VcLicenseAssignmentFailedReason: VcLicenseAssignmentFailedReasonConstructor;

	interface VcLicenseAssignmentManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryAssignedLicenses(entityId?: String): VcLicenseAssignmentManagerLicenseAssignment[];
		removeAssignedLicense(entityId?: String): void;
		updateAssignedLicense(entity?: String, licenseKey?: String, entityDisplayName?: String): VcLicenseManagerLicenseInfo;
	}

	declare const VcLicenseAssignmentManager: VcLicenseAssignmentManager;

	declare class VcLicenseAssignmentManagerLicenseAssignment
	{
		assignedLicense: VcLicenseManagerLicenseInfo;
		entityDisplayName: String;
		entityId: String;
		properties: VcKeyAnyValue[];
		scope: String;

		constructor();
	}

	declare class VcLicenseAvailabilityInfo
	{
		available: Number;
		feature: VcLicenseFeatureInfo;
		total: Number;

		constructor();
	}

	declare class VcLicenseDiagnostics
	{
		lastStatusUpdate: Date;
		licenseFeatureUnknowns: String;
		licenseRequestFailures: String;
		licenseRequests: String;
		opFailureMessage: String;
		opState: VcLicenseManagerState;
		sourceLastChanged: Date;
		sourceLatency: Number;
		sourceLost: String;

		constructor();
	}

	declare class VcLicenseEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcLicenseExpiredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		feature: VcLicenseFeatureInfo;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcLicenseFeatureInfo
	{
		costUnit: String;
		dependentKey: String[];
		edition: boolean;
		expiresOn: Date;
		featureDescription: String;
		featureName: String;
		key: String;
		sourceRestriction: String;
		state: VcLicenseFeatureInfoState;

		constructor();
	}

	interface VcLicenseFeatureInfoSourceRestriction
	{
		readonly _file: String;
		readonly _served: String;
		readonly _unrestricted: String;
		readonly file: VcLicenseFeatureInfoSourceRestriction;
		readonly id: String;
		readonly name: String;
		readonly served: VcLicenseFeatureInfoSourceRestriction;
		readonly unrestricted: VcLicenseFeatureInfoSourceRestriction;
		readonly value: String;

		fromString(value?: String): VcLicenseFeatureInfoSourceRestriction;
	}

	interface VcLicenseFeatureInfoSourceRestrictionConstructor {
		new(value?:any): VcLicenseFeatureInfoSourceRestriction;
		readonly prototype: VcLicenseFeatureInfoSourceRestriction;
	}

	declare const VcLicenseFeatureInfoSourceRestriction: VcLicenseFeatureInfoSourceRestrictionConstructor;

	interface VcLicenseFeatureInfoState
	{
		readonly _disabled: String;
		readonly _enabled: String;
		readonly _optional: String;
		readonly disabled: VcLicenseFeatureInfoState;
		readonly enabled: VcLicenseFeatureInfoState;
		readonly id: String;
		readonly name: String;
		readonly optional: VcLicenseFeatureInfoState;
		readonly value: String;

		fromString(value?: String): VcLicenseFeatureInfoState;
	}

	interface VcLicenseFeatureInfoStateConstructor {
		new(value?:any): VcLicenseFeatureInfoState;
		readonly prototype: VcLicenseFeatureInfoState;
	}

	declare const VcLicenseFeatureInfoState: VcLicenseFeatureInfoStateConstructor;

	interface VcLicenseFeatureInfoUnit
	{
		readonly _cpuCore: String;
		readonly _cpuPackage: String;
		readonly _host: String;
		readonly _server: String;
		readonly _vm: String;
		readonly cpuCore: VcLicenseFeatureInfoUnit;
		readonly cpuPackage: VcLicenseFeatureInfoUnit;
		readonly host: VcLicenseFeatureInfoUnit;
		readonly id: String;
		readonly name: String;
		readonly server: VcLicenseFeatureInfoUnit;
		readonly value: String;
		readonly vm: VcLicenseFeatureInfoUnit;

		fromString(value?: String): VcLicenseFeatureInfoUnit;
	}

	interface VcLicenseFeatureInfoUnitConstructor {
		new(value?:any): VcLicenseFeatureInfoUnit;
		readonly prototype: VcLicenseFeatureInfoUnit;
	}

	declare const VcLicenseFeatureInfoUnit: VcLicenseFeatureInfoUnitConstructor;

	interface VcLicenseManager
	{
		diagnostics: VcLicenseDiagnostics;
		evaluation: VcLicenseManagerEvaluationInfo;
		featureInfo: VcLicenseFeatureInfo[];
		readonly id: String;
		licenseAssignmentManager: VcLicenseAssignmentManager;
		licensedEdition: String;
		licenses: VcLicenseManagerLicenseInfo[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		source: VcLicenseSource;
		sourceAvailable: boolean;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addLicense(licenseKey?: String, labels?: VcKeyValue[]): VcLicenseManagerLicenseInfo;
		checkLicenseFeature(host?: VcHostSystem, featureKey?: String): boolean;
		configureLicenseSource(host?: VcHostSystem, licenseSource?: VcLicenseSource): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		decodeLicense(licenseKey?: String): VcLicenseManagerLicenseInfo;
		disableFeature(host?: VcHostSystem, featureKey?: String): boolean;
		enableFeature(host?: VcHostSystem, featureKey?: String): boolean;
		queryLicenseSourceAvailability(host?: VcHostSystem): VcLicenseAvailabilityInfo[];
		queryLicenseUsage(host?: VcHostSystem): VcLicenseUsageInfo;
		querySupportedFeatures(host?: VcHostSystem): VcLicenseFeatureInfo[];
		removeLicense(licenseKey?: String): void;
		removeLicenseLabel(licenseKey?: String, labelKey?: String): void;
		setLicenseEdition(host?: VcHostSystem, featureKey?: String): void;
		updateLicense(licenseKey?: String, labels?: VcKeyValue[]): VcLicenseManagerLicenseInfo;
		updateLicenseLabel(licenseKey?: String, labelKey?: String, labelValue?: String): void;
	}

	declare const VcLicenseManager: VcLicenseManager;

	declare class VcLicenseManagerEvaluationInfo
	{
		properties: VcKeyAnyValue[];

		constructor();
	}

	declare class VcLicenseManagerLicenseInfo
	{
		costUnit: String;
		editionKey: String;
		labels: VcKeyValue[];
		licenseKey: String;
		name: String;
		properties: VcKeyAnyValue[];
		total: Number;
		used: Number;

		constructor();
	}

	interface VcLicenseManagerLicenseKey
	{
		readonly _backup: String;
		readonly _das: String;
		readonly _drs: String;
		readonly _drsPower: String;
		readonly _esxExpress: String;
		readonly _esxFull: String;
		readonly _esxHost: String;
		readonly _esxVmtn: String;
		readonly _gsxHost: String;
		readonly _iscsi: String;
		readonly _nas: String;
		readonly _san: String;
		readonly _serverHost: String;
		readonly _vc: String;
		readonly _vcExpress: String;
		readonly _vmotion: String;
		readonly _vsmp: String;
		readonly backup: VcLicenseManagerLicenseKey;
		readonly das: VcLicenseManagerLicenseKey;
		readonly drs: VcLicenseManagerLicenseKey;
		readonly drsPower: VcLicenseManagerLicenseKey;
		readonly esxExpress: VcLicenseManagerLicenseKey;
		readonly esxFull: VcLicenseManagerLicenseKey;
		readonly esxHost: VcLicenseManagerLicenseKey;
		readonly esxVmtn: VcLicenseManagerLicenseKey;
		readonly gsxHost: VcLicenseManagerLicenseKey;
		readonly id: String;
		readonly iscsi: VcLicenseManagerLicenseKey;
		readonly name: String;
		readonly nas: VcLicenseManagerLicenseKey;
		readonly san: VcLicenseManagerLicenseKey;
		readonly serverHost: VcLicenseManagerLicenseKey;
		readonly value: String;
		readonly vc: VcLicenseManagerLicenseKey;
		readonly vcExpress: VcLicenseManagerLicenseKey;
		readonly vmotion: VcLicenseManagerLicenseKey;
		readonly vsmp: VcLicenseManagerLicenseKey;

		fromString(value?: String): VcLicenseManagerLicenseKey;
	}

	interface VcLicenseManagerLicenseKeyConstructor {
		new(value?:any): VcLicenseManagerLicenseKey;
		readonly prototype: VcLicenseManagerLicenseKey;
	}

	declare const VcLicenseManagerLicenseKey: VcLicenseManagerLicenseKeyConstructor;

	interface VcLicenseManagerState
	{
		readonly _fault: String;
		readonly _initializing: String;
		readonly _marginal: String;
		readonly _normal: String;
		readonly fault: VcLicenseManagerState;
		readonly id: String;
		readonly initializing: VcLicenseManagerState;
		readonly marginal: VcLicenseManagerState;
		readonly name: String;
		readonly normal: VcLicenseManagerState;
		readonly value: String;

		fromString(value?: String): VcLicenseManagerState;
	}

	interface VcLicenseManagerStateConstructor {
		new(value?:any): VcLicenseManagerState;
		readonly prototype: VcLicenseManagerState;
	}

	declare const VcLicenseManagerState: VcLicenseManagerStateConstructor;

	declare class VcLicenseNonComplianceEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		url: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcLicenseReservationInfo
	{
		key: String;
		required: Number;
		state: VcLicenseReservationInfoState;

		constructor();
	}

	interface VcLicenseReservationInfoState
	{
		readonly _licensed: String;
		readonly _noLicense: String;
		readonly _notUsed: String;
		readonly _unlicensedUse: String;
		readonly id: String;
		readonly licensed: VcLicenseReservationInfoState;
		readonly name: String;
		readonly noLicense: VcLicenseReservationInfoState;
		readonly notUsed: VcLicenseReservationInfoState;
		readonly unlicensedUse: VcLicenseReservationInfoState;
		readonly value: String;

		fromString(value?: String): VcLicenseReservationInfoState;
	}

	interface VcLicenseReservationInfoStateConstructor {
		new(value?:any): VcLicenseReservationInfoState;
		readonly prototype: VcLicenseReservationInfoState;
	}

	declare const VcLicenseReservationInfoState: VcLicenseReservationInfoStateConstructor;

	declare class VcLicenseRestrictedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcLicenseServerAvailableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		licenseServer: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcLicenseServerSource
	{
		licenseServer: String;

		constructor();
	}

	declare class VcLicenseServerUnavailableEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		licenseServer: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcLicenseSource
	{

		constructor();
	}

	declare class VcLicenseUsageInfo
	{
		featureInfo: VcLicenseFeatureInfo[];
		reservationInfo: VcLicenseReservationInfo[];
		source: VcLicenseSource;
		sourceAvailable: boolean;

		constructor();
	}

	declare class VcLinkDiscoveryProtocolConfig
	{
		operation: String;
		protocol: String;

		constructor();
	}

	interface VcLinkDiscoveryProtocolConfigOperationType
	{
		readonly _advertise: String;
		readonly _both: String;
		readonly _listen: String;
		readonly _none: String;
		readonly advertise: VcLinkDiscoveryProtocolConfigOperationType;
		readonly both: VcLinkDiscoveryProtocolConfigOperationType;
		readonly id: String;
		readonly listen: VcLinkDiscoveryProtocolConfigOperationType;
		readonly name: String;
		readonly none: VcLinkDiscoveryProtocolConfigOperationType;
		readonly value: String;

		fromString(value?: String): VcLinkDiscoveryProtocolConfigOperationType;
	}

	interface VcLinkDiscoveryProtocolConfigOperationTypeConstructor {
		new(value?:any): VcLinkDiscoveryProtocolConfigOperationType;
		readonly prototype: VcLinkDiscoveryProtocolConfigOperationType;
	}

	declare const VcLinkDiscoveryProtocolConfigOperationType: VcLinkDiscoveryProtocolConfigOperationTypeConstructor;

	interface VcLinkDiscoveryProtocolConfigProtocolType
	{
		readonly _cdp: String;
		readonly _lldp: String;
		readonly cdp: VcLinkDiscoveryProtocolConfigProtocolType;
		readonly id: String;
		readonly lldp: VcLinkDiscoveryProtocolConfigProtocolType;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcLinkDiscoveryProtocolConfigProtocolType;
	}

	interface VcLinkDiscoveryProtocolConfigProtocolTypeConstructor {
		new(value?:any): VcLinkDiscoveryProtocolConfigProtocolType;
		readonly prototype: VcLinkDiscoveryProtocolConfigProtocolType;
	}

	declare const VcLinkDiscoveryProtocolConfigProtocolType: VcLinkDiscoveryProtocolConfigProtocolTypeConstructor;

	declare class VcLinkLayerDiscoveryProtocolInfo
	{
		chassisId: String;
		parameter: VcKeyAnyValue[];
		portId: String;
		timeToLive: Number;

		constructor();
	}

	declare class VcLinkProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	interface VcListView
	{

	}

	declare const VcListView: VcListView;

	declare class VcLocalDatastoreCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcLocalDatastoreInfo
	{
		containerId: String;
		freeSpace: Number;
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxVirtualDiskCapacity: Number;
		name: String;
		path: String;
		timestamp: Date;
		url: String;

		constructor();
	}

	declare class VcLocalizableMessage
	{
		arg: VcKeyAnyValue[];
		key: String;
		message: String;

		constructor();
	}

	interface VcLocalizationManager
	{
		catalog: VcLocalizationManagerMessageCatalog[];
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcLocalizationManager: VcLocalizationManager;

	declare class VcLocalizationManagerMessageCatalog
	{
		catalogName: String;
		catalogUri: String;
		lastModified: Date;
		locale: String;
		md5sum: String;
		moduleName: String;
		version: String;

		constructor();
	}

	declare class VcLocalizedMethodFault
	{
		fault: VcMethodFault;
		localizedMessage: String;

		constructor();
	}

	declare class VcLocalLicenseSource
	{
		licenseKeys: String;

		constructor();
	}

	declare class VcLocalTSMEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcLockerMisconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcLockerReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newDatastore: VcDatastoreEventArgument;
		oldDatastore: VcDatastoreEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcLongOption
	{
		defaultValue: Number;
		max: Number;
		min: Number;
		valueIsReadonly: boolean;

		constructor();
	}

	declare class VcLongPolicy
	{
		inherited: boolean;
		value: Number;

		constructor();
	}

	declare class VcMacAddress
	{
		negate: boolean;

		constructor();
	}

	declare class VcMacRange
	{
		address: String;
		mask: String;
		negate: boolean;

		constructor();
	}

	declare class VcManagedByInfo
	{
		extensionKey: String;
		type: String;

		constructor();
	}

	interface VcManagedEntity
	{

	}

	declare const VcManagedEntity: VcManagedEntity;

	declare class VcManagedEntityEventArgument
	{
		entity: VcManagedEntity;
		name: String;

		constructor();
	}

	interface VcManagedEntityStatus
	{
		readonly _gray: String;
		readonly _green: String;
		readonly _red: String;
		readonly _yellow: String;
		readonly gray: VcManagedEntityStatus;
		readonly green: VcManagedEntityStatus;
		readonly id: String;
		readonly name: String;
		readonly red: VcManagedEntityStatus;
		readonly value: String;
		readonly yellow: VcManagedEntityStatus;

		fromString(value?: String): VcManagedEntityStatus;
	}

	interface VcManagedEntityStatusConstructor {
		new(value?:any): VcManagedEntityStatus;
		readonly prototype: VcManagedEntityStatus;
	}

	declare const VcManagedEntityStatus: VcManagedEntityStatusConstructor;

	interface VcManagedObject
	{

	}

	declare const VcManagedObject: VcManagedObject;

	declare class VcManagedObjectReference
	{
		type: String;
		value: String;

		constructor();
	}

	interface VcMediaAnalysisManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		recognizeInstaller(mediaPath?: String, host?: VcHostSystem): VcMediaAnalysisManagerInstallerInfo;
	}

	declare const VcMediaAnalysisManager: VcMediaAnalysisManager;

	declare class VcMediaAnalysisManagerInstallerInfo
	{
		guestId: String;

		constructor();
	}

	interface VcMessageBusProxy
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcMessageBusProxy: VcMessageBusProxy;

	declare class VcMethodAction
	{
		argument: VcMethodActionArgument[];
		name: String;

		constructor();
	}

	declare class VcMethodActionArgument
	{
		value: Object;
		value_FloatValue: Number;
		value_IntValue: Number;
		value_LongValue: Number;

		constructor();
	}

	declare class VcMethodDescription
	{
		key: String;
		label: String;
		summary: String;

		constructor();
	}

	interface VcMethodFault
	{

	}

	declare const VcMethodFault: VcMethodFault;

	interface VcMethodProxyManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		registerEntityHandler(name?: VcManagedObjectReference, serviceKey?: String): void;
		registerMethodHandler(wsdlMethodName?: String, serviceKey?: String, handlerMethodName?: String): void;
		registerObjectHandler(moType?: String, serviceKey?: String): void;
		unregisterEntityHandler(name?: VcManagedObjectReference, serviceKey?: String): void;
		unregisterMethodHandler(wsdlMethodName?: String, serviceKey?: String): void;
		unregisterObjectHandler(moType?: String, serviceKey?: String): void;
	}

	declare const VcMethodProxyManager: VcMethodProxyManager;

	declare class VcMetricAlarmExpression
	{
		metric: VcPerfMetricId;
		operator: VcMetricAlarmOperator;
		red: Number;
		redInterval: Number;
		type: String;
		yellow: Number;
		yellowInterval: Number;

		constructor();
	}

	interface VcMetricAlarmOperator
	{
		readonly _isAbove: String;
		readonly _isBelow: String;
		readonly id: String;
		readonly isAbove: VcMetricAlarmOperator;
		readonly isBelow: VcMetricAlarmOperator;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcMetricAlarmOperator;
	}

	interface VcMetricAlarmOperatorConstructor {
		new(value?:any): VcMetricAlarmOperator;
		readonly prototype: VcMetricAlarmOperator;
	}

	declare const VcMetricAlarmOperator: VcMetricAlarmOperatorConstructor;

	declare class VcMigrationErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcMigrationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcMigrationHostErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dstHost: VcHostEventArgument;
		dvs: VcDvsEventArgument;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcMigrationHostWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dstHost: VcHostEventArgument;
		dvs: VcDvsEventArgument;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcMigrationResourceErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dstHost: VcHostEventArgument;
		dstPool: VcResourcePoolEventArgument;
		dvs: VcDvsEventArgument;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcMigrationResourceWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dstHost: VcHostEventArgument;
		dstPool: VcResourcePoolEventArgument;
		dvs: VcDvsEventArgument;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcMigrationWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fault: VcLocalizedMethodFault;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcMissingObject
	{
		fault: VcLocalizedMethodFault;
		obj: VcManagedObjectReference;

		constructor();
	}

	declare class VcMissingProperty
	{
		fault: VcLocalizedMethodFault;
		path: String;

		constructor();
	}

	declare class VcModeInfo
	{
		admin: String;
		browse: String;
		full: String;
		modify: String;
		read: String;
		use: String;

		constructor();
	}

	declare class VcMonthlyByDayTaskScheduler
	{
		activeTime: Date;
		day: Number;
		expireTime: Date;
		hour: Number;
		interval: Number;
		minute: Number;

		constructor();
	}

	declare class VcMonthlyByWeekdayTaskScheduler
	{
		activeTime: Date;
		expireTime: Date;
		hour: Number;
		interval: Number;
		minute: Number;
		offset: VcWeekOfMonth;
		weekday: VcDayOfWeek;

		constructor();
	}

	declare class VcMonthlyTaskScheduler
	{
		activeTime: Date;
		expireTime: Date;
		hour: Number;
		interval: Number;
		minute: Number;

		constructor();
	}

	declare class VcMtuMatchEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcMtuMismatchEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcMultipathState
	{
		readonly _active: String;
		readonly _dead: String;
		readonly _disabled: String;
		readonly _standby: String;
		readonly _unknown: String;
		readonly active: VcMultipathState;
		readonly dead: VcMultipathState;
		readonly disabled: VcMultipathState;
		readonly id: String;
		readonly name: String;
		readonly standby: VcMultipathState;
		readonly unknown: VcMultipathState;
		readonly value: String;

		fromString(value?: String): VcMultipathState;
	}

	interface VcMultipathStateConstructor {
		new(value?:any): VcMultipathState;
		readonly prototype: VcMultipathState;
	}

	declare const VcMultipathState: VcMultipathStateConstructor;

	declare class VcMultipleCertificatesVerifyFaultThumbprintData
	{
		port: Number;
		thumbprint: String;

		constructor();
	}

	declare class VcNamePasswordAuthentication
	{
		interactiveSession: boolean;
		password: String;
		username: String;

		constructor();
	}

	declare class VcNASDatastoreCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcNasDatastoreInfo
	{
		containerId: String;
		freeSpace: Number;
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxVirtualDiskCapacity: Number;
		name: String;
		nas: VcHostNasVolume;
		timestamp: Date;
		url: String;

		constructor();
	}

	declare class VcNasStorageProfile
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcNegatableExpression
	{
		negate: boolean;

		constructor();
	}

	declare class VcNetBIOSConfigInfo
	{
		mode: String;

		constructor();
	}

	interface VcNetBIOSConfigInfoMode
	{
		readonly _disabled: String;
		readonly _enabled: String;
		readonly _enabledViaDHCP: String;
		readonly _unknown: String;
		readonly disabled: VcNetBIOSConfigInfoMode;
		readonly enabled: VcNetBIOSConfigInfoMode;
		readonly enabledViaDHCP: VcNetBIOSConfigInfoMode;
		readonly id: String;
		readonly name: String;
		readonly unknown: VcNetBIOSConfigInfoMode;
		readonly value: String;

		fromString(value?: String): VcNetBIOSConfigInfoMode;
	}

	interface VcNetBIOSConfigInfoModeConstructor {
		new(value?:any): VcNetBIOSConfigInfoMode;
		readonly prototype: VcNetBIOSConfigInfoMode;
	}

	declare const VcNetBIOSConfigInfoMode: VcNetBIOSConfigInfoModeConstructor;

	declare class VcNetDhcpConfigInfo
	{
		ipv4: VcNetDhcpConfigInfoDhcpOptions;
		ipv6: VcNetDhcpConfigInfoDhcpOptions;

		constructor();
	}

	declare class VcNetDhcpConfigInfoDhcpOptions
	{
		config: VcKeyValue[];
		enable: boolean;

		constructor();
	}

	declare class VcNetDhcpConfigSpec
	{
		ipv4: VcNetDhcpConfigSpecDhcpOptionsSpec;
		ipv6: VcNetDhcpConfigSpecDhcpOptionsSpec;

		constructor();
	}

	declare class VcNetDhcpConfigSpecDhcpOptionsSpec
	{
		config: VcKeyValue[];
		enable: boolean;
		operation: String;

		constructor();
	}

	declare class VcNetDnsConfigInfo
	{
		dhcp: boolean;
		domainName: String;
		hostName: String;
		ipAddress: String[];
		searchDomain: String[];

		constructor();
	}

	declare class VcNetDnsConfigSpec
	{
		dhcp: boolean;
		domainName: String;
		hostName: String;
		ipAddress: String[];
		searchDomain: String[];

		constructor();
	}

	declare class VcNetIpConfigInfo
	{
		autoConfigurationEnabled: boolean;
		dhcp: VcNetDhcpConfigInfo;
		ipAddress: VcNetIpConfigInfoIpAddress[];

		constructor();
	}

	declare class VcNetIpConfigInfoIpAddress
	{
		ipAddress: String;
		lifetime: Date;
		origin: String;
		prefixLength: Number;
		state: String;

		constructor();
	}

	interface VcNetIpConfigInfoIpAddressOrigin
	{
		readonly _dhcp: String;
		readonly _linklayer: String;
		readonly _manual: String;
		readonly _other: String;
		readonly _random: String;
		readonly dhcp: VcNetIpConfigInfoIpAddressOrigin;
		readonly id: String;
		readonly linklayer: VcNetIpConfigInfoIpAddressOrigin;
		readonly manual: VcNetIpConfigInfoIpAddressOrigin;
		readonly name: String;
		readonly other: VcNetIpConfigInfoIpAddressOrigin;
		readonly random: VcNetIpConfigInfoIpAddressOrigin;
		readonly value: String;

		fromString(value?: String): VcNetIpConfigInfoIpAddressOrigin;
	}

	interface VcNetIpConfigInfoIpAddressOriginConstructor {
		new(value?:any): VcNetIpConfigInfoIpAddressOrigin;
		readonly prototype: VcNetIpConfigInfoIpAddressOrigin;
	}

	declare const VcNetIpConfigInfoIpAddressOrigin: VcNetIpConfigInfoIpAddressOriginConstructor;

	interface VcNetIpConfigInfoIpAddressStatus
	{
		readonly _deprecated: String;
		readonly _duplicate: String;
		readonly _inaccessible: String;
		readonly _invalid: String;
		readonly _preferred: String;
		readonly _tentative: String;
		readonly _unknown: String;
		readonly deprecated: VcNetIpConfigInfoIpAddressStatus;
		readonly duplicate: VcNetIpConfigInfoIpAddressStatus;
		readonly id: String;
		readonly inaccessible: VcNetIpConfigInfoIpAddressStatus;
		readonly invalid: VcNetIpConfigInfoIpAddressStatus;
		readonly name: String;
		readonly preferred: VcNetIpConfigInfoIpAddressStatus;
		readonly tentative: VcNetIpConfigInfoIpAddressStatus;
		readonly unknown: VcNetIpConfigInfoIpAddressStatus;
		readonly value: String;

		fromString(value?: String): VcNetIpConfigInfoIpAddressStatus;
	}

	interface VcNetIpConfigInfoIpAddressStatusConstructor {
		new(value?:any): VcNetIpConfigInfoIpAddressStatus;
		readonly prototype: VcNetIpConfigInfoIpAddressStatus;
	}

	declare const VcNetIpConfigInfoIpAddressStatus: VcNetIpConfigInfoIpAddressStatusConstructor;

	declare class VcNetIpConfigSpec
	{
		autoConfigurationEnabled: boolean;
		dhcp: VcNetDhcpConfigSpec;
		ipAddress: VcNetIpConfigSpecIpAddressSpec[];

		constructor();
	}

	declare class VcNetIpConfigSpecIpAddressSpec
	{
		ipAddress: String;
		operation: String;
		prefixLength: Number;

		constructor();
	}

	declare class VcNetIpRouteConfigInfo
	{
		ipRoute: VcNetIpRouteConfigInfoIpRoute[];

		constructor();
	}

	declare class VcNetIpRouteConfigInfoGateway
	{
		device: String;
		ipAddress: String;

		constructor();
	}

	declare class VcNetIpRouteConfigInfoIpRoute
	{
		gateway: VcNetIpRouteConfigInfoGateway;
		network: String;
		prefixLength: Number;

		constructor();
	}

	declare class VcNetIpRouteConfigSpec
	{
		ipRoute: VcNetIpRouteConfigSpecIpRouteSpec[];

		constructor();
	}

	declare class VcNetIpRouteConfigSpecGatewaySpec
	{
		device: String;
		ipAddress: String;

		constructor();
	}

	declare class VcNetIpRouteConfigSpecIpRouteSpec
	{
		gateway: VcNetIpRouteConfigSpecGatewaySpec;
		network: String;
		operation: String;
		prefixLength: Number;

		constructor();
	}

	declare class VcNetIpStackInfo
	{
		defaultRouter: VcNetIpStackInfoDefaultRouter[];
		neighbor: VcNetIpStackInfoNetToMedia[];

		constructor();
	}

	declare class VcNetIpStackInfoDefaultRouter
	{
		device: String;
		ipAddress: String;
		lifetime: Date;
		preference: String;

		constructor();
	}

	interface VcNetIpStackInfoEntryType
	{
		readonly _dynamic: String;
		readonly _invalid: String;
		readonly _manual: String;
		readonly _other: String;
		readonly dynamic: VcNetIpStackInfoEntryType;
		readonly id: String;
		readonly invalid: VcNetIpStackInfoEntryType;
		readonly manual: VcNetIpStackInfoEntryType;
		readonly name: String;
		readonly other: VcNetIpStackInfoEntryType;
		readonly value: String;

		fromString(value?: String): VcNetIpStackInfoEntryType;
	}

	interface VcNetIpStackInfoEntryTypeConstructor {
		new(value?:any): VcNetIpStackInfoEntryType;
		readonly prototype: VcNetIpStackInfoEntryType;
	}

	declare const VcNetIpStackInfoEntryType: VcNetIpStackInfoEntryTypeConstructor;

	declare class VcNetIpStackInfoNetToMedia
	{
		device: String;
		ipAddress: String;
		physicalAddress: String;
		type: String;

		constructor();
	}

	interface VcNetIpStackInfoPreference
	{
		readonly _high: String;
		readonly _low: String;
		readonly _medium: String;
		readonly _reserved: String;
		readonly high: VcNetIpStackInfoPreference;
		readonly id: String;
		readonly low: VcNetIpStackInfoPreference;
		readonly medium: VcNetIpStackInfoPreference;
		readonly name: String;
		readonly reserved: VcNetIpStackInfoPreference;
		readonly value: String;

		fromString(value?: String): VcNetIpStackInfoPreference;
	}

	interface VcNetIpStackInfoPreferenceConstructor {
		new(value?:any): VcNetIpStackInfoPreference;
		readonly prototype: VcNetIpStackInfoPreference;
	}

	declare const VcNetIpStackInfoPreference: VcNetIpStackInfoPreferenceConstructor;

	declare class VcNetStackInstanceProfile
	{
		dnsConfig: VcNetworkProfileDnsConfigProfile;
		enabled: boolean;
		ipRouteConfig: VcIpRouteProfile;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	interface VcNetwork
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		host: VcHostSystem[];
		readonly id: String;
		name: String;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		summary: VcNetworkSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;
		vm: VcVirtualMachine[];

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		destroyNetwork(): void;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcNetwork: VcNetwork;

	declare class VcNetworkBandwidthAllocationInfo
	{
		distributedVirtualPort: VcDistributedVirtualPort;
		distributedVirtualSwitch: VcDistributedVirtualSwitch;
		expandableReservation: boolean;
		inShapingPolicy: VcHostNetworkTrafficShapingPolicy;
		limit: Number;
		outShapingPolicy: VcHostNetworkTrafficShapingPolicy;
		overheadLimit: Number;
		reservation: Number;
		shares: VcSharesInfo;

		constructor();
	}

	declare class VcNetworkEventArgument
	{
		name: String;
		network: VcNetwork;

		constructor();
	}

	declare class VcNetworkPolicyProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcNetworkProfile
	{
		consoleIpRouteConfig: VcIpRouteProfile;
		dnsConfig: VcNetworkProfileDnsConfigProfile;
		dvsHostNic: VcDvsHostVNicProfile[];
		dvsServiceConsoleNic: VcDvsServiceConsoleVNicProfile[];
		dvswitch: VcDvsProfile[];
		enabled: boolean;
		hostPortGroup: VcHostPortGroupProfile[];
		ipRouteConfig: VcIpRouteProfile;
		netStackInstance: VcNetStackInstanceProfile[];
		pnic: VcPhysicalNicProfile[];
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		serviceConsolePortGroup: VcServiceConsolePortGroupProfile[];
		vmPortGroup: VcVmPortGroupProfile[];
		vswitch: VcVirtualSwitchProfile[];

		constructor();
	}

	declare class VcNetworkProfileDnsConfigProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcNetworkRollbackEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		methodName: String;
		net: VcNetworkEventArgument;
		transactionId: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcNetworkSummary
	{
		accessible: boolean;
		ipPoolId: Number;
		ipPoolName: String;
		name: String;
		network: VcNetwork;

		constructor();
	}

	declare class VcNoAccessUserEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ipAddress: String;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcNoDatastoresConfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcNoLicenseEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		feature: VcLicenseFeatureInfo;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcNoMaintenanceModeDrsRecommendationForVM
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcNonVIWorkloadDetectedOnDatastoreEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcNotEnoughResourcesToStartVmEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcNotSupportedDeviceForFTDeviceType
	{
		readonly _paraVirtualSCSIController: String;
		readonly _virtualVmxnet3: String;
		readonly id: String;
		readonly name: String;
		readonly paraVirtualSCSIController: VcNotSupportedDeviceForFTDeviceType;
		readonly value: String;
		readonly virtualVmxnet3: VcNotSupportedDeviceForFTDeviceType;

		fromString(value?: String): VcNotSupportedDeviceForFTDeviceType;
	}

	interface VcNotSupportedDeviceForFTDeviceTypeConstructor {
		new(value?:any): VcNotSupportedDeviceForFTDeviceType;
		readonly prototype: VcNotSupportedDeviceForFTDeviceType;
	}

	declare const VcNotSupportedDeviceForFTDeviceType: VcNotSupportedDeviceForFTDeviceTypeConstructor;

	declare class VcNumericRange
	{
		end: Number;
		start: Number;

		constructor();
	}

	declare class VcNumPortsProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	interface VcNumVirtualCpusIncompatibleReason
	{
		readonly _faultTolerance: String;
		readonly _recordReplay: String;
		readonly faultTolerance: VcNumVirtualCpusIncompatibleReason;
		readonly id: String;
		readonly name: String;
		readonly recordReplay: VcNumVirtualCpusIncompatibleReason;
		readonly value: String;

		fromString(value?: String): VcNumVirtualCpusIncompatibleReason;
	}

	interface VcNumVirtualCpusIncompatibleReasonConstructor {
		new(value?:any): VcNumVirtualCpusIncompatibleReason;
		readonly prototype: VcNumVirtualCpusIncompatibleReason;
	}

	declare const VcNumVirtualCpusIncompatibleReason: VcNumVirtualCpusIncompatibleReasonConstructor;

	declare class VcObjectContent
	{
		missingSet: VcMissingProperty[];
		obj: VcManagedObjectReference;
		propSet: VcDynamicProperty[];

		constructor();
	}

	declare class VcObjectSpec
	{
		obj: VcManagedObjectReference;
		selectSet: VcSelectionSpec[];
		skip: boolean;

		constructor();
	}

	declare class VcObjectUpdate
	{
		changeSet: VcPropertyChange[];
		kind: VcObjectUpdateKind;
		missingSet: VcMissingProperty[];
		obj: VcManagedObjectReference;

		constructor();
	}

	interface VcObjectUpdateKind
	{
		readonly _enter: String;
		readonly _leave: String;
		readonly _modify: String;
		readonly enter: VcObjectUpdateKind;
		readonly id: String;
		readonly leave: VcObjectUpdateKind;
		readonly modify: VcObjectUpdateKind;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcObjectUpdateKind;
	}

	interface VcObjectUpdateKindConstructor {
		new(value?:any): VcObjectUpdateKind;
		readonly prototype: VcObjectUpdateKind;
	}

	declare const VcObjectUpdateKind: VcObjectUpdateKindConstructor;

	declare class VcOnceTaskScheduler
	{
		activeTime: Date;
		expireTime: Date;
		runAt: Date;

		constructor();
	}

	interface VcOpaqueNetwork
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		host: VcHostSystem[];
		readonly id: String;
		name: String;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		summary: VcNetworkSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;
		vm: VcVirtualMachine[];

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		destroyNetwork(): void;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcOpaqueNetwork: VcOpaqueNetwork;

	declare class VcOpaqueNetworkSummary
	{
		accessible: boolean;
		ipPoolId: Number;
		ipPoolName: String;
		name: String;
		network: VcNetwork;
		opaqueNetworkId: String;
		opaqueNetworkType: String;

		constructor();
	}

	declare class VcOpaqueNetworkTargetInfo
	{
		configurationTag: String[];
		name: String;
		network: VcOpaqueNetworkSummary;
		networkReservationSupported: boolean;

		constructor();
	}

	declare class VcOptionDef
	{
		key: String;
		label: String;
		optionType: VcOptionType;
		summary: String;

		constructor();
	}

	interface VcOptionManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		setting: VcOptionValue[];
		supportedOption: VcOptionDef[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryOptions(name?: String): VcOptionValue[];
		updateOptions(changedValue?: VcOptionValue[]): void;
	}

	declare const VcOptionManager: VcOptionManager;

	declare class VcOptionProfile
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcOptionType
	{
		valueIsReadonly: boolean;

		constructor();
	}

	declare class VcOptionValue
	{
		key: String;
		value: Object;
		value_FloatValue: Number;
		value_IntValue: Number;
		value_LongValue: Number;

		constructor();
	}

	declare class VcOrAlarmExpression
	{
		expression: VcAlarmExpression[];

		constructor();
	}

	declare class VcOutOfSyncDvsHost
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostOutOfSync: VcDvsOutOfSyncHostArgument[];
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcOverheadMemoryManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		lookupVmOverheadMemory(vm?: VcVirtualMachine, host?: VcHostSystem): Number;
	}

	declare const VcOverheadMemoryManager: VcOverheadMemoryManager;

	declare class VcOvfConsumerOstNode
	{
		child: VcOvfConsumerOstNode[];
		entity: VcManagedEntity;
		id: String;
		section: VcOvfConsumerOvfSection[];
		type: String;

		constructor();
	}

	interface VcOvfConsumerOstNodeType
	{
		readonly _envelope: String;
		readonly _virtualSystem: String;
		readonly _virtualSystemCollection: String;
		readonly envelope: VcOvfConsumerOstNodeType;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly virtualSystem: VcOvfConsumerOstNodeType;
		readonly virtualSystemCollection: VcOvfConsumerOstNodeType;

		fromString(value?: String): VcOvfConsumerOstNodeType;
	}

	interface VcOvfConsumerOstNodeTypeConstructor {
		new(value?:any): VcOvfConsumerOstNodeType;
		readonly prototype: VcOvfConsumerOstNodeType;
	}

	declare const VcOvfConsumerOstNodeType: VcOvfConsumerOstNodeTypeConstructor;

	declare class VcOvfConsumerOvfSection
	{
		lineNumber: Number;
		xml: String;

		constructor();
	}

	declare class VcOvfCreateDescriptorParams
	{
		description: String;
		exportOption: String[];
		includeImageFiles: boolean;
		name: String;
		ovfFiles: VcOvfFile[];
		snapshot: VcVirtualMachineSnapshot;

		constructor();
	}

	declare class VcOvfCreateDescriptorResult
	{
		error: VcLocalizedMethodFault[];
		includeImageFiles: boolean;
		ovfDescriptor: String;
		warning: VcLocalizedMethodFault[];

		constructor();
	}

	declare class VcOvfCreateImportSpecParams
	{
		deploymentOption: String;
		diskProvisioning: String;
		entityName: String;
		hostSystem: VcHostSystem;
		importOption: String[];
		instantiationOst: VcOvfConsumerOstNode;
		ipAllocationPolicy: String;
		ipProtocol: String;
		locale: String;
		msgBundle: VcKeyValue[];
		networkMapping: VcOvfNetworkMapping[];
		propertyMapping: VcKeyValue[];
		resourceMapping: VcOvfResourceMap[];

		constructor();
	}

	interface VcOvfCreateImportSpecParamsDiskProvisioningType
	{
		readonly _eagerZeroedThick: String;
		readonly _flat: String;
		readonly _monolithicFlat: String;
		readonly _monolithicSparse: String;
		readonly _seSparse: String;
		readonly _sparse: String;
		readonly _thick: String;
		readonly _thin: String;
		readonly _twoGbMaxExtentFlat: String;
		readonly _twoGbMaxExtentSparse: String;
		readonly eagerZeroedThick: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly flat: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly id: String;
		readonly monolithicFlat: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly monolithicSparse: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly name: String;
		readonly seSparse: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly sparse: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly thick: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly thin: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly twoGbMaxExtentFlat: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly twoGbMaxExtentSparse: VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly value: String;

		fromString(value?: String): VcOvfCreateImportSpecParamsDiskProvisioningType;
	}

	interface VcOvfCreateImportSpecParamsDiskProvisioningTypeConstructor {
		new(value?:any): VcOvfCreateImportSpecParamsDiskProvisioningType;
		readonly prototype: VcOvfCreateImportSpecParamsDiskProvisioningType;
	}

	declare const VcOvfCreateImportSpecParamsDiskProvisioningType: VcOvfCreateImportSpecParamsDiskProvisioningTypeConstructor;

	declare class VcOvfCreateImportSpecResult
	{
		error: VcLocalizedMethodFault[];
		fileItem: VcOvfFileItem[];
		importSpec: VcImportSpec;
		warning: VcLocalizedMethodFault[];

		constructor();
	}

	declare class VcOvfDeploymentOption
	{
		description: String;
		key: String;
		label: String;

		constructor();
	}

	declare class VcOvfFile
	{
		capacity: Number;
		chunkSize: Number;
		compressionMethod: String;
		deviceId: String;
		path: String;
		populatedSize: Number;
		size: Number;

		constructor();
	}

	declare class VcOvfFileItem
	{
		chunkSize: Number;
		cimType: Number;
		compressionMethod: String;
		create: boolean;
		deviceId: String;
		path: String;
		size: Number;

		constructor();
	}

	interface VcOvfManager
	{
		readonly id: String;
		ovfExportOption: VcOvfOptionInfo[];
		ovfImportOption: VcOvfOptionInfo[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createDescriptor(obj?: VcManagedEntity, cdp?: VcOvfCreateDescriptorParams): VcOvfCreateDescriptorResult;
		createImportSpec(ovfDescriptor?: String, resourcePool?: VcResourcePool, datastore?: VcDatastore, cisp?: VcOvfCreateImportSpecParams): VcOvfCreateImportSpecResult;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		parseDescriptor(ovfDescriptor?: String, pdp?: VcOvfParseDescriptorParams): VcOvfParseDescriptorResult;
		validateHost(ovfDescriptor?: String, host?: VcHostSystem, vhp?: VcOvfValidateHostParams): VcOvfValidateHostResult;
	}

	declare const VcOvfManager: VcOvfManager;

	declare class VcOvfManagerCommonParams
	{
		deploymentOption: String;
		importOption: String[];
		locale: String;
		msgBundle: VcKeyValue[];

		constructor();
	}

	declare class VcOvfNetworkInfo
	{
		description: String;
		name: String;

		constructor();
	}

	declare class VcOvfNetworkMapping
	{
		name: String;
		network: VcNetwork;

		constructor();
	}

	declare class VcOvfOptionInfo
	{
		description: VcLocalizableMessage;
		option: String;

		constructor();
	}

	declare class VcOvfParseDescriptorParams
	{
		deploymentOption: String;
		importOption: String[];
		locale: String;
		msgBundle: VcKeyValue[];

		constructor();
	}

	declare class VcOvfParseDescriptorResult
	{
		annotatedOst: VcOvfConsumerOstNode;
		annotation: String;
		approximateDownloadSize: Number;
		approximateFlatDeploymentSize: Number;
		approximateSparseDeploymentSize: Number;
		defaultDeploymentOption: String;
		defaultEntityName: String;
		deploymentOption: VcOvfDeploymentOption[];
		entityName: VcKeyValue[];
		error: VcLocalizedMethodFault[];
		eula: String[];
		ipAllocationScheme: String[];
		ipProtocols: String[];
		network: VcOvfNetworkInfo[];
		productInfo: VcVAppProductInfo;
		property: VcVAppPropertyInfo[];
		virtualApp: boolean;
		warning: VcLocalizedMethodFault[];

		constructor();
	}

	declare class VcOvfResourceMap
	{
		datastore: VcDatastore;
		parent: VcResourcePool;
		resourceSpec: VcResourceConfigSpec;
		source: String;

		constructor();
	}

	declare class VcOvfValidateHostParams
	{
		deploymentOption: String;
		importOption: String[];
		locale: String;
		msgBundle: VcKeyValue[];

		constructor();
	}

	declare class VcOvfValidateHostResult
	{
		downloadSize: Number;
		error: VcLocalizedMethodFault[];
		flatDeploymentSize: Number;
		sparseDeploymentSize: Number;
		supportedDiskProvisioning: String[];
		warning: VcLocalizedMethodFault[];

		constructor();
	}

	declare class VcParaVirtualSCSIController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		hotAddRemove: boolean;
		key: Number;
		scsiCtlrUnitNumber: Number;
		sharedBus: VcVirtualSCSISharing;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcParaVirtualSCSIControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		defaultSharedIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotAddRemove: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSCSICdroms: VcIntOption;
		numSCSIDisks: VcIntOption;
		numSCSIPassthrough: VcIntOption;
		plugAndPlay: boolean;
		scsiCtlrUnitNumber: Number;
		sharing: VcVirtualSCSISharing[];
		supportedDevice: String[];
		type: String;

		constructor();
	}

	declare class VcPasswordField
	{
		value: String;

		constructor();
	}

	declare class VcPerfCompositeMetric
	{
		childEntity: VcPerfEntityMetricBase[];
		entity: VcPerfEntityMetricBase;

		constructor();
	}

	declare class VcPerfCounterInfo
	{
		associatedCounterId: Number[];
		groupInfo: VcElementDescription;
		key: Number;
		level: Number;
		nameInfo: VcElementDescription;
		perDeviceLevel: Number;
		rollupType: VcPerfSummaryType;
		statsType: VcPerfStatsType;
		unitInfo: VcElementDescription;

		constructor();
	}

	declare class VcPerfEntityMetric
	{
		entity: VcManagedObjectReference;
		sampleInfo: VcPerfSampleInfo[];
		value: VcPerfMetricSeries[];

		constructor();
	}

	declare class VcPerfEntityMetricBase
	{
		entity: VcManagedObjectReference;

		constructor();
	}

	declare class VcPerfEntityMetricCSV
	{
		entity: VcManagedObjectReference;
		sampleInfoCSV: String;
		value: VcPerfMetricSeriesCSV[];

		constructor();
	}

	interface VcPerfFormat
	{
		readonly _csv: String;
		readonly _normal: String;
		readonly csv: VcPerfFormat;
		readonly id: String;
		readonly name: String;
		readonly normal: VcPerfFormat;
		readonly value: String;

		fromString(value?: String): VcPerfFormat;
	}

	interface VcPerfFormatConstructor {
		new(value?:any): VcPerfFormat;
		readonly prototype: VcPerfFormat;
	}

	declare const VcPerfFormat: VcPerfFormatConstructor;

	declare class VcPerfInterval
	{
		enabled: boolean;
		key: Number;
		length: Number;
		level: Number;
		name: String;
		samplingPeriod: Number;

		constructor();
	}

	declare class VcPerfMetricId
	{
		counterId: Number;
		instance: String;

		constructor();
	}

	declare class VcPerfMetricIntSeries
	{
		id: VcPerfMetricId;
		value: Number[];

		constructor();
	}

	declare class VcPerfMetricSeries
	{
		id: VcPerfMetricId;

		constructor();
	}

	declare class VcPerfMetricSeriesCSV
	{
		id: VcPerfMetricId;
		value: String;

		constructor();
	}

	declare class VcPerformanceDescription
	{
		counterType: VcElementDescription[];
		statsType: VcElementDescription[];

		constructor();
	}

	interface VcPerformanceManager
	{
		description: VcPerformanceDescription;
		historicalInterval: VcPerfInterval[];
		readonly id: String;
		perfCounter: VcPerfCounterInfo[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createPerfInterval(intervalId?: VcPerfInterval): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryAvailablePerfMetric(entity?: VcManagedObjectReference, beginTime?: Date, endTime?: Date, intervalId?: Number): VcPerfMetricId[];
		queryPerf(querySpec?: VcPerfQuerySpec[]): VcPerfEntityMetricBase[];
		queryPerfComposite(querySpec?: VcPerfQuerySpec): VcPerfCompositeMetric;
		queryPerfCounter(counterId?: Number[]): VcPerfCounterInfo[];
		queryPerfCounterByLevel(level?: Number): VcPerfCounterInfo[];
		queryPerfProviderSummary(entity?: VcManagedObjectReference): VcPerfProviderSummary;
		removePerfInterval(samplePeriod?: Number): void;
		resetCounterLevelMapping(counters?: Number[]): void;
		updateCounterLevelMapping(counterLevelMap?: VcPerformanceManagerCounterLevelMapping[]): void;
		updatePerfInterval(interval?: VcPerfInterval): void;
	}

	declare const VcPerformanceManager: VcPerformanceManager;

	declare class VcPerformanceManagerCounterLevelMapping
	{
		aggregateLevel: Number;
		counterId: Number;
		perDeviceLevel: Number;

		constructor();
	}

	interface VcPerformanceManagerUnit
	{
		readonly _joule: String;
		readonly _kiloBytes: String;
		readonly _kiloBytesPerSecond: String;
		readonly _megaBytes: String;
		readonly _megaBytesPerSecond: String;
		readonly _megaHertz: String;
		readonly _microsecond: String;
		readonly _millisecond: String;
		readonly _number: String;
		readonly _percent: String;
		readonly _second: String;
		readonly _teraBytes: String;
		readonly _watt: String;
		readonly id: String;
		readonly joule: VcPerformanceManagerUnit;
		readonly kiloBytes: VcPerformanceManagerUnit;
		readonly kiloBytesPerSecond: VcPerformanceManagerUnit;
		readonly megaBytes: VcPerformanceManagerUnit;
		readonly megaBytesPerSecond: VcPerformanceManagerUnit;
		readonly megaHertz: VcPerformanceManagerUnit;
		readonly microsecond: VcPerformanceManagerUnit;
		readonly millisecond: VcPerformanceManagerUnit;
		readonly name: String;
		readonly number: VcPerformanceManagerUnit;
		readonly percent: VcPerformanceManagerUnit;
		readonly second: VcPerformanceManagerUnit;
		readonly teraBytes: VcPerformanceManagerUnit;
		readonly value: String;
		readonly watt: VcPerformanceManagerUnit;

		fromString(value?: String): VcPerformanceManagerUnit;
	}

	interface VcPerformanceManagerUnitConstructor {
		new(value?:any): VcPerformanceManagerUnit;
		readonly prototype: VcPerformanceManagerUnit;
	}

	declare const VcPerformanceManagerUnit: VcPerformanceManagerUnitConstructor;

	declare class VcPerformanceStatisticsDescription
	{
		intervals: VcPerfInterval[];

		constructor();
	}

	declare class VcPerfProviderSummary
	{
		currentSupported: boolean;
		entity: VcManagedObjectReference;
		refreshRate: Number;
		summarySupported: boolean;

		constructor();
	}

	declare class VcPerfQuerySpec
	{
		endTime: Date;
		entity: VcManagedObjectReference;
		format: String;
		intervalId: Number;
		maxSample: Number;
		metricId: VcPerfMetricId[];
		startTime: Date;

		constructor();
	}

	declare class VcPerfSampleInfo
	{
		interval: Number;
		timestamp: Date;

		constructor();
	}

	interface VcPerfStatsType
	{
		readonly _absolute: String;
		readonly _delta: String;
		readonly _rate: String;
		readonly absolute: VcPerfStatsType;
		readonly delta: VcPerfStatsType;
		readonly id: String;
		readonly name: String;
		readonly rate: VcPerfStatsType;
		readonly value: String;

		fromString(value?: String): VcPerfStatsType;
	}

	interface VcPerfStatsTypeConstructor {
		new(value?:any): VcPerfStatsType;
		readonly prototype: VcPerfStatsType;
	}

	declare const VcPerfStatsType: VcPerfStatsTypeConstructor;

	interface VcPerfSummaryType
	{
		readonly _average: String;
		readonly _latest: String;
		readonly _maximum: String;
		readonly _minimum: String;
		readonly _none: String;
		readonly _summation: String;
		readonly average: VcPerfSummaryType;
		readonly id: String;
		readonly latest: VcPerfSummaryType;
		readonly maximum: VcPerfSummaryType;
		readonly minimum: VcPerfSummaryType;
		readonly name: String;
		readonly none: VcPerfSummaryType;
		readonly summation: VcPerfSummaryType;
		readonly value: String;

		fromString(value?: String): VcPerfSummaryType;
	}

	interface VcPerfSummaryTypeConstructor {
		new(value?:any): VcPerfSummaryType;
		readonly prototype: VcPerfSummaryType;
	}

	declare const VcPerfSummaryType: VcPerfSummaryTypeConstructor;

	declare class VcPermission
	{
		entity: VcManagedEntity;
		group: boolean;
		principal: String;
		propagate: boolean;
		roleId: Number;

		constructor();
	}

	declare class VcPermissionAddedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		principal: String;
		propagate: boolean;
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcPermissionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		principal: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcPermissionProfile
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcPermissionRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		principal: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcPermissionUpdatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		group: boolean;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		principal: String;
		propagate: boolean;
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcPhysicalNic
	{
		autoNegotiateSupported: boolean;
		device: String;
		driver: String;
		fcoeConfiguration: VcFcoeConfig;
		key: String;
		linkSpeed: VcPhysicalNicLinkInfo;
		mac: String;
		pci: String;
		resourcePoolSchedulerAllowed: boolean;
		resourcePoolSchedulerDisallowedReason: String[];
		spec: VcPhysicalNicSpec;
		validLinkSpecification: VcPhysicalNicLinkInfo[];
		vmDirectPathGen2Supported: boolean;
		vmDirectPathGen2SupportedMode: String;
		wakeOnLanSupported: boolean;

		constructor();
	}

	declare class VcPhysicalNicCdpDeviceCapability
	{
		host: boolean;
		igmpEnabled: boolean;
		networkSwitch: boolean;
		repeater: boolean;
		router: boolean;
		sourceRouteBridge: boolean;
		transparentBridge: boolean;

		constructor();
	}

	declare class VcPhysicalNicCdpInfo
	{
		address: String;
		cdpVersion: Number;
		deviceCapability: VcPhysicalNicCdpDeviceCapability;
		devId: String;
		fullDuplex: boolean;
		hardwarePlatform: String;
		ipPrefix: String;
		ipPrefixLen: Number;
		location: String;
		mgmtAddr: String;
		mtu: Number;
		portId: String;
		samples: Number;
		softwareVersion: String;
		systemName: String;
		systemOID: String;
		timeout: Number;
		ttl: Number;
		vlan: Number;

		constructor();
	}

	declare class VcPhysicalNicConfig
	{
		device: String;
		spec: VcPhysicalNicSpec;

		constructor();
	}

	declare class VcPhysicalNicHint
	{
		vlanId: Number;

		constructor();
	}

	declare class VcPhysicalNicHintInfo
	{
		connectedSwitchPort: VcPhysicalNicCdpInfo;
		device: String;
		lldpInfo: VcLinkLayerDiscoveryProtocolInfo;
		network: VcPhysicalNicNameHint[];
		subnet: VcPhysicalNicIpHint[];

		constructor();
	}

	declare class VcPhysicalNicIpHint
	{
		ipSubnet: String;
		vlanId: Number;

		constructor();
	}

	declare class VcPhysicalNicLinkInfo
	{
		duplex: boolean;
		speedMb: Number;

		constructor();
	}

	declare class VcPhysicalNicNameHint
	{
		network: String;
		vlanId: Number;

		constructor();
	}

	declare class VcPhysicalNicProfile
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	interface VcPhysicalNicResourcePoolSchedulerDisallowedReason
	{
		readonly _hardwareUnsupported: String;
		readonly _userOptOut: String;
		readonly hardwareUnsupported: VcPhysicalNicResourcePoolSchedulerDisallowedReason;
		readonly id: String;
		readonly name: String;
		readonly userOptOut: VcPhysicalNicResourcePoolSchedulerDisallowedReason;
		readonly value: String;

		fromString(value?: String): VcPhysicalNicResourcePoolSchedulerDisallowedReason;
	}

	interface VcPhysicalNicResourcePoolSchedulerDisallowedReasonConstructor {
		new(value?:any): VcPhysicalNicResourcePoolSchedulerDisallowedReason;
		readonly prototype: VcPhysicalNicResourcePoolSchedulerDisallowedReason;
	}

	declare const VcPhysicalNicResourcePoolSchedulerDisallowedReason: VcPhysicalNicResourcePoolSchedulerDisallowedReasonConstructor;

	declare class VcPhysicalNicSpec
	{
		ip: VcHostIpConfig;
		linkSpeed: VcPhysicalNicLinkInfo;

		constructor();
	}

	interface VcPhysicalNicVmDirectPathGen2SupportedMode
	{
		readonly _cdpt: String;
		readonly _upt: String;
		readonly cdpt: VcPhysicalNicVmDirectPathGen2SupportedMode;
		readonly id: String;
		readonly name: String;
		readonly upt: VcPhysicalNicVmDirectPathGen2SupportedMode;
		readonly value: String;

		fromString(value?: String): VcPhysicalNicVmDirectPathGen2SupportedMode;
	}

	interface VcPhysicalNicVmDirectPathGen2SupportedModeConstructor {
		new(value?:any): VcPhysicalNicVmDirectPathGen2SupportedMode;
		readonly prototype: VcPhysicalNicVmDirectPathGen2SupportedMode;
	}

	declare const VcPhysicalNicVmDirectPathGen2SupportedMode: VcPhysicalNicVmDirectPathGen2SupportedModeConstructor;

	declare class VcPlacementAction
	{
		relocateSpec: VcVirtualMachineRelocateSpec;
		target: VcManagedObjectReference;
		targetHost: VcHostSystem;
		type: String;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcPlacementAffinityRule
	{
		keys: String[];
		ruleScope: String;
		ruleType: String;
		vms: VcVirtualMachine[];

		constructor();
	}

	interface VcPlacementAffinityRuleRuleScope
	{
		readonly _cluster: String;
		readonly _datastore: String;
		readonly _host: String;
		readonly _storagePod: String;
		readonly cluster: VcPlacementAffinityRuleRuleScope;
		readonly datastore: VcPlacementAffinityRuleRuleScope;
		readonly host: VcPlacementAffinityRuleRuleScope;
		readonly id: String;
		readonly name: String;
		readonly storagePod: VcPlacementAffinityRuleRuleScope;
		readonly value: String;

		fromString(value?: String): VcPlacementAffinityRuleRuleScope;
	}

	interface VcPlacementAffinityRuleRuleScopeConstructor {
		new(value?:any): VcPlacementAffinityRuleRuleScope;
		readonly prototype: VcPlacementAffinityRuleRuleScope;
	}

	declare const VcPlacementAffinityRuleRuleScope: VcPlacementAffinityRuleRuleScopeConstructor;

	interface VcPlacementAffinityRuleRuleType
	{
		readonly _affinity: String;
		readonly _antiAffinity: String;
		readonly _softAffinity: String;
		readonly _softAntiAffinity: String;
		readonly affinity: VcPlacementAffinityRuleRuleType;
		readonly antiAffinity: VcPlacementAffinityRuleRuleType;
		readonly id: String;
		readonly name: String;
		readonly softAffinity: VcPlacementAffinityRuleRuleType;
		readonly softAntiAffinity: VcPlacementAffinityRuleRuleType;
		readonly value: String;

		fromString(value?: String): VcPlacementAffinityRuleRuleType;
	}

	interface VcPlacementAffinityRuleRuleTypeConstructor {
		new(value?:any): VcPlacementAffinityRuleRuleType;
		readonly prototype: VcPlacementAffinityRuleRuleType;
	}

	declare const VcPlacementAffinityRuleRuleType: VcPlacementAffinityRuleRuleTypeConstructor;

	declare class VcPlacementRankResult
	{
		candidate: VcClusterComputeResource;
		faults: VcLocalizedMethodFault[];
		key: String;
		reservedSpaceMB: Number;
		totalSpaceMB: Number;
		usedSpaceMB: Number;
		utilization: Number;

		constructor();
	}

	declare class VcPlacementRankSpec
	{
		clusters: VcClusterComputeResource[];
		placementRankByVm: VcStorageDrsPlacementRankVmSpec[];
		rules: VcPlacementAffinityRule[];
		specs: VcPlacementSpec[];

		constructor();
	}

	declare class VcPlacementResult
	{
		drsFault: VcClusterDrsFaults;
		recommendations: VcClusterRecommendation[];

		constructor();
	}

	declare class VcPlacementSpec
	{
		cloneName: String;
		cloneSpec: VcVirtualMachineCloneSpec;
		configSpec: VcVirtualMachineConfigSpec;
		datastores: VcDatastore[];
		disallowPrerequisiteMoves: boolean;
		hosts: VcHostSystem[];
		key: String;
		placementType: String;
		priority: VcVirtualMachineMovePriority;
		relocateSpec: VcVirtualMachineRelocateSpec;
		rules: VcClusterRuleInfo[];
		storagePods: VcStoragePod[];
		vm: VcVirtualMachine;

		constructor();
	}

	interface VcPlacementSpecPlacementType
	{
		readonly _clone: String;
		readonly _create: String;
		readonly _reconfigure: String;
		readonly _relocate: String;
		readonly clone: VcPlacementSpecPlacementType;
		readonly create: VcPlacementSpecPlacementType;
		readonly id: String;
		readonly name: String;
		readonly reconfigure: VcPlacementSpecPlacementType;
		readonly relocate: VcPlacementSpecPlacementType;
		readonly value: String;

		fromString(value?: String): VcPlacementSpecPlacementType;
	}

	interface VcPlacementSpecPlacementTypeConstructor {
		new(value?:any): VcPlacementSpecPlacementType;
		readonly prototype: VcPlacementSpecPlacementType;
	}

	declare const VcPlacementSpecPlacementType: VcPlacementSpecPlacementTypeConstructor;

	interface VcPlugin
	{
		readonly allClusterComputeResources: VcClusterComputeResource[];
		readonly allComputeResources: VcComputeResource[];
		readonly allDatacenterFolders: VcFolder[];
		readonly allDatacenters: VcDatacenter[];
		readonly allDatastoreFolders: VcFolder[];
		readonly allDatastores: VcDatastore[];
		readonly allDistributedVirtualPortgroups: VcDistributedVirtualPortgroup[];
		readonly allHostFolders: VcFolder[];
		readonly allHostSystems: VcHostSystem[];
		readonly allNetworkFolders: VcFolder[];
		readonly allNetworks: VcNetwork[];
		readonly allResourcePools: VcResourcePool[];
		readonly allSdkConnections: VcSdkConnection[];
		readonly allTasks: VcTask[];
		readonly allVimHosts: VcSdkConnection[];
		readonly allVirtualApps: VcVirtualApp[];
		readonly allVirtualMachines: VcVirtualMachine[];
		readonly allVirtualMachineSnapshots: VcVirtualMachineSnapshot[];
		readonly allVmFolders: VcFolder[];
		readonly vimHosts: VcSdkConnection[];

		convertToVimManagedObject(managedObjectHolder?: Object, object?: VcManagedObjectReference): Object;
		createCustomizationPasswordFromCredentials(credentials?: Credential, encrypted?: boolean): VcCustomizationPassword;
		currentTime(host?: VcSdkConnection): Date;
		deepClone(o?: Object): Object;
		findSdkConnectionForUUID(uuid?: String): VcSdkConnection;
		getAllClusterComputeResources(additionalPropertyFilters?: String[], query?: String): VcClusterComputeResource[];
		getAllComputeResources(additionalPropertyFilters?: String[], query?: String): VcComputeResource[];
		getAllDatacenterFolders(additionalPropertyFilters?: String[], query?: String): VcFolder[];
		getAllDatacenters(additionalPropertyFilters?: String[], query?: String): VcDatacenter[];
		getAllDatastoreFolders(additionalPropertyFilters?: String[], query?: String): VcFolder[];
		getAllDatastores(additionalPropertyFilters?: String[], query?: String): VcDatastore[];
		getAllDistributedVirtualPortgroups(additionalPropertyFilters?: String[], query?: String): VcDistributedVirtualPortgroup[];
		getAllHostFolders(additionalPropertyFilters?: String[], query?: String): VcFolder[];
		getAllHostSystems(additionalPropertyFilters?: String[], query?: String): VcHostSystem[];
		getAllNetworkFolders(additionalPropertyFilters?: String[], query?: String): VcFolder[];
		getAllNetworks(additionalPropertyFilters?: String[], query?: String): VcNetwork[];
		getAllRegisteredInstances(): String[];
		getAllResourcePools(additionalPropertyFilters?: String[], query?: String): VcResourcePool[];
		getAllTasks(additionalPropertyFilters?: String[], query?: String): VcTask[];
		getAllVirtualApps(additionalPropertyFilters?: String[], query?: String): VcVirtualApp[];
		getAllVirtualMachines(additionalPropertyFilters?: String[], query?: String): VcVirtualMachine[];
		getAllVirtualMachineSnapshots(additionalPropertyFilters?: String[], query?: String): VcVirtualMachineSnapshot[];
		getAllVmFolders(additionalPropertyFilters?: String[], query?: String): VcFolder[];
		getExtensionKey(): String;
		getManagedObjectsForIds(sdkType?: String, ids?: String[]): VcManagedObject[];
		getManagedObjectsForTypesAndIds(sdkTypes?: String[], ids?: String[]): VcManagedObject[];
		getManagedObjectsForURIs(uriStrings?: String): VcManagedObject[];
		getProvisionedSpace(datastore?: VcDatastore): Number;
		getRegisteredInstanceProperties(host?: String): Properties;
		importOvf(ovfUri?: String, hostSystem?: VcHostSystem, importFolder?: VcFolder, vmName?: String, networks?: VcOvfNetworkMapping[], datastore?: VcDatastore): VcVirtualMachine;
		refreshObjects(obj?: Object): Object;
		registerExtensionForAddress(host?: VcSdkConnection, address?: String): VcExtension;
		registerVCenterServerInstance(enabled?: boolean, hostName?: String, port?: Number, path?: String, sessionPerUser?: boolean, userName?: String, password?: String, domain?: String): VcSdkConnection;
		toManagedObject(factoryHolder?: VcManagedObject, object?: VcManagedObjectReference): VcManagedObject;
		toManagedObjectRef(object?: VcManagedObject): VcManagedObjectReference;
		unregisterExtension(host?: VcSdkConnection, key?: String): void;
		unregisterVCenterServerInstance(host?: String): void;
		updateVCenterServerInstance(host?: String, enabled?: boolean, hostName?: String, port?: Number, path?: String, sessionPerUser?: boolean, userName?: String, password?: String, domain?: String): void;
		validateConnection(hostName?: String, port?: Number, path?: String, userName?: String, password?: String): void;
	}

	declare const VcPlugin: VcPlugin;

	declare class VcPnicUplinkProfile
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcPodDiskLocator
	{
		diskBackingInfo: VcVirtualDeviceBackingInfo;
		diskId: Number;
		diskMoveType: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
	}

	declare class VcPodStorageDrsEntry
	{
		actionHistory: VcClusterActionHistory[];
		drsFault: VcClusterDrsFaults[];
		recommendation: VcClusterRecommendation[];
		storageDrsConfig: VcStorageDrsConfigInfo;

		constructor();
	}

	declare class VcPolicyOption
	{
		id: String;
		parameter: VcKeyAnyValue[];

		constructor();
	}

	interface VcPortGroupConnecteeType
	{
		readonly _host: String;
		readonly _systemManagement: String;
		readonly _unknown: String;
		readonly _virtualMachine: String;
		readonly host: VcPortGroupConnecteeType;
		readonly id: String;
		readonly name: String;
		readonly systemManagement: VcPortGroupConnecteeType;
		readonly unknown: VcPortGroupConnecteeType;
		readonly value: String;
		readonly virtualMachine: VcPortGroupConnecteeType;

		fromString(value?: String): VcPortGroupConnecteeType;
	}

	interface VcPortGroupConnecteeTypeConstructor {
		new(value?:any): VcPortGroupConnecteeType;
		readonly prototype: VcPortGroupConnecteeType;
	}

	declare const VcPortGroupConnecteeType: VcPortGroupConnecteeTypeConstructor;

	declare class VcPortGroupProfile
	{
		enabled: boolean;
		key: String;
		name: String;
		networkPolicy: VcNetworkPolicyProfile;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		vlan: VcVlanProfile;
		vswitch: VcVirtualSwitchSelectionProfile;

		constructor();
	}

	declare class VcPosixUserSearchResult
	{
		fullName: String;
		group: boolean;
		id: Number;
		principal: String;
		shellAccess: boolean;

		constructor();
	}

	interface VcPoweredOnCloneNotSupportedUnsupportedOperation
	{
		readonly _snapshotCreate: String;
		readonly _snapshotRemove: String;
		readonly id: String;
		readonly name: String;
		readonly snapshotCreate: VcPoweredOnCloneNotSupportedUnsupportedOperation;
		readonly snapshotRemove: VcPoweredOnCloneNotSupportedUnsupportedOperation;
		readonly value: String;

		fromString(value?: String): VcPoweredOnCloneNotSupportedUnsupportedOperation;
	}

	interface VcPoweredOnCloneNotSupportedUnsupportedOperationConstructor {
		new(value?:any): VcPoweredOnCloneNotSupportedUnsupportedOperation;
		readonly prototype: VcPoweredOnCloneNotSupportedUnsupportedOperation;
	}

	declare const VcPoweredOnCloneNotSupportedUnsupportedOperation: VcPoweredOnCloneNotSupportedUnsupportedOperationConstructor;

	declare class VcPowerSystemCapability
	{
		availablePolicy: VcHostPowerPolicy[];

		constructor();
	}

	declare class VcPowerSystemInfo
	{
		currentPolicy: VcHostPowerPolicy;

		constructor();
	}

	declare class VcPreCallbackResult
	{
		currentResult: VcPreCallbackResultResult;
		extensionKey: String;
		fault: VcLocalizedMethodFault;
		instanceId: String;
		percentDone: Number;

		constructor();
	}

	interface VcPreCallbackResultResult
	{
		readonly _BlockOperation: String;
		readonly _ContinueWithOperation: String;
		readonly BlockOperation: VcPreCallbackResultResult;
		readonly ContinueWithOperation: VcPreCallbackResultResult;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcPreCallbackResultResult;
	}

	interface VcPreCallbackResultResultConstructor {
		new(value?:any): VcPreCallbackResultResult;
		readonly prototype: VcPreCallbackResultResult;
	}

	declare const VcPreCallbackResultResult: VcPreCallbackResultResultConstructor;

	declare class VcPrivilegeAvailability
	{
		isGranted: boolean;
		privId: String;

		constructor();
	}

	declare class VcPrivilegePolicyDef
	{
		createPrivilege: String;
		deletePrivilege: String;
		readPrivilege: String;
		updatePrivilege: String;

		constructor();
	}

	declare class VcProductComponentInfo
	{
		id: String;
		name: String;
		release: Number;
		version: String;

		constructor();
	}

	interface VcProfile
	{
		complianceStatus: String;
		config: VcProfileConfigInfo;
		createdTime: Date;
		description: VcProfileDescription;
		entity: VcManagedEntity[];
		readonly id: String;
		modifiedTime: Date;
		name: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		associateProfile(entity?: VcManagedEntity[]): void;
		checkProfileCompliance_Task(entity?: VcManagedEntity[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyProfile(): void;
		dissociateProfile(entity?: VcManagedEntity[]): void;
		exportProfile(): String;
		retrieveDescription(): VcProfileDescription;
	}

	declare const VcProfile: VcProfile;

	declare class VcProfileApplyProfileElement
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcProfileApplyProfileProperty
	{
		array: boolean;
		profile: VcApplyProfile[];
		propertyName: String;

		constructor();
	}

	declare class VcProfileAssociatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcProfileChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcProfileComplianceManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		checkCompliance_Task(profile?: VcProfile[], entity?: VcManagedEntity[]): VcTask;
		clearComplianceStatus(profile?: VcProfile[], entity?: VcManagedEntity[]): void;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryComplianceStatus(profile?: VcProfile[], entity?: VcManagedEntity[]): VcComplianceResult[];
		queryExpressionMetadata(expressionName?: String[], profile?: VcProfile): VcProfileExpressionMetadata[];
	}

	declare const VcProfileComplianceManager: VcProfileComplianceManager;

	declare class VcProfileCompositeExpression
	{
		displayName: String;
		expressionName: String[];
		id: String;
		negated: boolean;
		operator: String;

		constructor();
	}

	declare class VcProfileCompositePolicyOptionMetadata
	{
		id: VcExtendedElementDescription;
		option: String[];
		parameter: VcProfileParameterMetadata[];

		constructor();
	}

	declare class VcProfileConfigInfo
	{
		annotation: String;
		enabled: boolean;
		name: String;

		constructor();
	}

	declare class VcProfileCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcProfileCreateSpec
	{
		annotation: String;
		enabled: boolean;
		name: String;

		constructor();
	}

	declare class VcProfileDeferredPolicyOptionParameter
	{
		inputPath: VcProfilePropertyPath;
		parameter: VcKeyAnyValue[];

		constructor();
	}

	declare class VcProfileDescription
	{
		section: VcProfileDescriptionSection[];

		constructor();
	}

	declare class VcProfileDescriptionSection
	{
		description: VcExtendedElementDescription;
		message: VcLocalizableMessage[];

		constructor();
	}

	declare class VcProfileDissociatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcProfileEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcProfileEventArgument
	{
		name: String;
		profile: VcProfile;

		constructor();
	}

	declare class VcProfileExecuteError
	{
		message: VcLocalizableMessage;
		path: VcProfilePropertyPath;

		constructor();
	}

	declare class VcProfileExecuteResult
	{
		configSpec: VcHostConfigSpec;
		error: VcProfileExecuteError[];
		inapplicablePath: String[];
		requireInput: VcProfileDeferredPolicyOptionParameter[];
		status: String;

		constructor();
	}

	interface VcProfileExecuteResultStatus
	{
		readonly _error: String;
		readonly _needInput: String;
		readonly _success: String;
		readonly error: VcProfileExecuteResultStatus;
		readonly id: String;
		readonly name: String;
		readonly needInput: VcProfileExecuteResultStatus;
		readonly success: VcProfileExecuteResultStatus;
		readonly value: String;

		fromString(value?: String): VcProfileExecuteResultStatus;
	}

	interface VcProfileExecuteResultStatusConstructor {
		new(value?:any): VcProfileExecuteResultStatus;
		readonly prototype: VcProfileExecuteResultStatus;
	}

	declare const VcProfileExecuteResultStatus: VcProfileExecuteResultStatusConstructor;

	declare class VcProfileExpression
	{
		displayName: String;
		id: String;
		negated: boolean;

		constructor();
	}

	declare class VcProfileExpressionMetadata
	{
		expressionId: VcExtendedElementDescription;
		parameter: VcProfileParameterMetadata[];

		constructor();
	}

	interface VcProfileManager
	{
		readonly id: String;
		profile: VcProfile[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createProfile(createSpec?: VcProfileCreateSpec): VcProfile;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		findAssociatedProfile(entity?: VcManagedEntity): VcProfile[];
		queryPolicyMetadata(policyName?: String[], profile?: VcProfile): VcProfilePolicyMetadata[];
	}

	declare const VcProfileManager: VcProfileManager;

	declare class VcProfileMetadata
	{
		description: VcExtendedDescription;
		key: String;
		profileCategory: String;
		profileComponent: String;
		profileTypeName: String;
		sortSpec: VcProfileMetadataProfileSortSpec[];

		constructor();
	}

	declare class VcProfileMetadataProfileSortSpec
	{
		parameter: String;
		policyId: String;

		constructor();
	}

	interface VcProfileNumericComparator
	{
		readonly _equal: String;
		readonly _greaterThan: String;
		readonly _greaterThanEqual: String;
		readonly _lessThan: String;
		readonly _lessThanEqual: String;
		readonly _notEqual: String;
		readonly equal: VcProfileNumericComparator;
		readonly greaterThan: VcProfileNumericComparator;
		readonly greaterThanEqual: VcProfileNumericComparator;
		readonly id: String;
		readonly lessThan: VcProfileNumericComparator;
		readonly lessThanEqual: VcProfileNumericComparator;
		readonly name: String;
		readonly notEqual: VcProfileNumericComparator;
		readonly value: String;

		fromString(value?: String): VcProfileNumericComparator;
	}

	interface VcProfileNumericComparatorConstructor {
		new(value?:any): VcProfileNumericComparator;
		readonly prototype: VcProfileNumericComparator;
	}

	declare const VcProfileNumericComparator: VcProfileNumericComparatorConstructor;

	declare class VcProfileParameterMetadata
	{
		defaultValue: Object;
		defaultValue_FloatValue: Number;
		defaultValue_IntValue: Number;
		defaultValue_LongValue: Number;
		id: VcExtendedElementDescription;
		optional: boolean;
		type: String;

		constructor();
	}

	declare class VcProfilePolicy
	{
		id: String;
		policyOption: VcPolicyOption;

		constructor();
	}

	declare class VcProfilePolicyMetadata
	{
		id: VcExtendedElementDescription;
		possibleOption: VcProfilePolicyOptionMetadata[];

		constructor();
	}

	declare class VcProfilePolicyOptionMetadata
	{
		id: VcExtendedElementDescription;
		parameter: VcProfileParameterMetadata[];

		constructor();
	}

	declare class VcProfileProfileStructure
	{
		child: VcProfileProfileStructureProperty[];
		mapping: VcHostProfileMapping[];
		profileTypeName: String;

		constructor();
	}

	declare class VcProfileProfileStructureProperty
	{
		array: boolean;
		element: VcProfileProfileStructure;
		propertyName: String;

		constructor();
	}

	declare class VcProfilePropertyPath
	{
		parameterId: String;
		policyId: String;
		profilePath: String;

		constructor();
	}

	declare class VcProfileReferenceHostChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		referenceHost: VcHostSystem;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcProfileRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		profile: VcProfileEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcProfileSerializedCreateSpec
	{
		annotation: String;
		enabled: boolean;
		name: String;
		profileConfigString: String;

		constructor();
	}

	declare class VcProfileSimpleExpression
	{
		displayName: String;
		expressionType: String;
		id: String;
		negated: boolean;
		parameter: VcKeyAnyValue[];

		constructor();
	}

	declare class VcProfileUpdateFailedUpdateFailure
	{
		errMsg: VcLocalizableMessage;
		profilePath: VcProfilePropertyPath;

		constructor();
	}

	declare class VcPropertyChange
	{
		name: String;
		op: VcPropertyChangeOp;
		val: Object;
		val_FloatValue: Number;
		val_IntValue: Number;
		val_LongValue: Number;

		constructor();
	}

	interface VcPropertyChangeOp
	{
		readonly _add: String;
		readonly _assign: String;
		readonly _indirectRemove: String;
		readonly _remove: String;
		readonly add: VcPropertyChangeOp;
		readonly assign: VcPropertyChangeOp;
		readonly id: String;
		readonly indirectRemove: VcPropertyChangeOp;
		readonly name: String;
		readonly remove: VcPropertyChangeOp;
		readonly value: String;

		fromString(value?: String): VcPropertyChangeOp;
	}

	interface VcPropertyChangeOpConstructor {
		new(value?:any): VcPropertyChangeOp;
		readonly prototype: VcPropertyChangeOp;
	}

	declare const VcPropertyChangeOp: VcPropertyChangeOpConstructor;

	interface VcPropertyCollector
	{
		filter: VcPropertyFilter[];
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		cancelRetrievePropertiesEx(token?: String): void;
		cancelWaitForUpdates(): void;
		checkForUpdates(version?: String): VcUpdateSet;
		continueRetrievePropertiesEx(token?: String): VcRetrieveResult;
		createFilter(spec?: VcPropertyFilterSpec, partialUpdates?: boolean): VcPropertyFilter;
		createPropertyCollector(): VcPropertyCollector;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyPropertyCollector(): void;
		retrieveProperties(specSet?: VcPropertyFilterSpec[]): VcObjectContent[];
		retrievePropertiesEx(specSet?: VcPropertyFilterSpec[], options?: VcRetrieveOptions): VcRetrieveResult;
		waitForUpdates(version?: String): VcUpdateSet;
		waitForUpdatesEx(version?: String, options?: VcWaitOptions): VcUpdateSet;
	}

	declare const VcPropertyCollector: VcPropertyCollector;

	interface VcPropertyFilter
	{
		readonly id: String;
		partialUpdates: boolean;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		spec: VcPropertyFilterSpec;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyPropertyFilter(): void;
	}

	declare const VcPropertyFilter: VcPropertyFilter;

	declare class VcPropertyFilterSpec
	{
		objectSet: VcObjectSpec[];
		propSet: VcPropertySpec[];
		reportMissingObjectsInResults: boolean;

		constructor();
	}

	declare class VcPropertyFilterUpdate
	{
		filter: VcPropertyFilter;
		missingSet: VcMissingObject[];
		objectSet: VcObjectUpdate[];

		constructor();
	}

	declare class VcPropertySpec
	{
		all: boolean;
		pathSet: String[];
		type: String;

		constructor();
	}

	interface VcQuiesceMode
	{
		readonly _application: String;
		readonly _filesystem: String;
		readonly _none: String;
		readonly application: VcQuiesceMode;
		readonly filesystem: VcQuiesceMode;
		readonly id: String;
		readonly name: String;
		readonly none: VcQuiesceMode;
		readonly value: String;

		fromString(value?: String): VcQuiesceMode;
	}

	interface VcQuiesceModeConstructor {
		new(value?:any): VcQuiesceMode;
		readonly prototype: VcQuiesceMode;
	}

	declare const VcQuiesceMode: VcQuiesceModeConstructor;

	interface VcRangeComparator
	{
		readonly _any: String;
		readonly _inRange: String;
		readonly _outRange: String;
		readonly any: VcRangeComparator;
		readonly id: String;
		readonly inRange: VcRangeComparator;
		readonly name: String;
		readonly outRange: VcRangeComparator;
		readonly value: String;

		fromString(value?: String): VcRangeComparator;
	}

	interface VcRangeComparatorConstructor {
		new(value?:any): VcRangeComparator;
		readonly prototype: VcRangeComparator;
	}

	declare const VcRangeComparator: VcRangeComparatorConstructor;

	interface VcRecommendationReasonCode
	{
		readonly _antiAffin: String;
		readonly _balanceDatastoreIOLoad: String;
		readonly _balanceDatastoreIOPSReservation: String;
		readonly _balanceDatastoreSpaceUsage: String;
		readonly _balanceNetworkBandwidthUsage: String;
		readonly _checkResource: String;
		readonly _colocateCommunicatingVM: String;
		readonly _datastoreMaint: String;
		readonly _datastoreSpaceOutage: String;
		readonly _enterStandby: String;
		readonly _fairnessCpuAvg: String;
		readonly _fairnessMemAvg: String;
		readonly _hostMaint: String;
		readonly _increaseAllocation: String;
		readonly _increaseCapacity: String;
		readonly _iolbDisabledInternal: String;
		readonly _jointAffin: String;
		readonly _networkBandwidthReservation: String;
		readonly _powerOnVm: String;
		readonly _powerSaving: String;
		readonly _reservationCpu: String;
		readonly _reservationMem: String;
		readonly _storagePlacement: String;
		readonly _unreservedCapacity: String;
		readonly _virtualDiskAntiAffin: String;
		readonly _virtualDiskJointAffin: String;
		readonly _vmHostHardAffinity: String;
		readonly _vmHostSoftAffinity: String;
		readonly _xvmotionPlacement: String;
		readonly antiAffin: VcRecommendationReasonCode;
		readonly balanceDatastoreIOLoad: VcRecommendationReasonCode;
		readonly balanceDatastoreIOPSReservation: VcRecommendationReasonCode;
		readonly balanceDatastoreSpaceUsage: VcRecommendationReasonCode;
		readonly balanceNetworkBandwidthUsage: VcRecommendationReasonCode;
		readonly checkResource: VcRecommendationReasonCode;
		readonly colocateCommunicatingVM: VcRecommendationReasonCode;
		readonly datastoreMaint: VcRecommendationReasonCode;
		readonly datastoreSpaceOutage: VcRecommendationReasonCode;
		readonly enterStandby: VcRecommendationReasonCode;
		readonly fairnessCpuAvg: VcRecommendationReasonCode;
		readonly fairnessMemAvg: VcRecommendationReasonCode;
		readonly hostMaint: VcRecommendationReasonCode;
		readonly id: String;
		readonly increaseAllocation: VcRecommendationReasonCode;
		readonly increaseCapacity: VcRecommendationReasonCode;
		readonly iolbDisabledInternal: VcRecommendationReasonCode;
		readonly jointAffin: VcRecommendationReasonCode;
		readonly name: String;
		readonly networkBandwidthReservation: VcRecommendationReasonCode;
		readonly powerOnVm: VcRecommendationReasonCode;
		readonly powerSaving: VcRecommendationReasonCode;
		readonly reservationCpu: VcRecommendationReasonCode;
		readonly reservationMem: VcRecommendationReasonCode;
		readonly storagePlacement: VcRecommendationReasonCode;
		readonly unreservedCapacity: VcRecommendationReasonCode;
		readonly value: String;
		readonly virtualDiskAntiAffin: VcRecommendationReasonCode;
		readonly virtualDiskJointAffin: VcRecommendationReasonCode;
		readonly vmHostHardAffinity: VcRecommendationReasonCode;
		readonly vmHostSoftAffinity: VcRecommendationReasonCode;
		readonly xvmotionPlacement: VcRecommendationReasonCode;

		fromString(value?: String): VcRecommendationReasonCode;
	}

	interface VcRecommendationReasonCodeConstructor {
		new(value?:any): VcRecommendationReasonCode;
		readonly prototype: VcRecommendationReasonCode;
	}

	declare const VcRecommendationReasonCode: VcRecommendationReasonCodeConstructor;

	interface VcRecommendationType
	{
		readonly _V1: String;
		readonly id: String;
		readonly name: String;
		readonly V1: VcRecommendationType;
		readonly value: String;

		fromString(value?: String): VcRecommendationType;
	}

	interface VcRecommendationTypeConstructor {
		new(value?:any): VcRecommendationType;
		readonly prototype: VcRecommendationType;
	}

	declare const VcRecommendationType: VcRecommendationTypeConstructor;

	declare class VcRecoveryEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		dvsUuid: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostName: String;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		userName: String;
		vm: VcVmEventArgument;
		vnic: String;

		constructor();
	}

	declare class VcRecurrentTaskScheduler
	{
		activeTime: Date;
		expireTime: Date;
		interval: Number;

		constructor();
	}

	declare class VcRemoteTSMEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcReplicationConfigSpec
	{
		destination: String;
		disk: VcReplicationInfoDiskSettings[];
		generation: Number;
		netCompressionEnabled: boolean;
		oppUpdatesEnabled: boolean;
		paused: boolean;
		port: Number;
		quiesceGuestEnabled: boolean;
		rpo: Number;
		vmReplicationId: String;

		constructor();
	}

	interface VcReplicationDiskConfigFaultReasonForFault
	{
		readonly _diskNotFound: String;
		readonly _diskTypeNotSupported: String;
		readonly _duplicateDiskReplicationId: String;
		readonly _invalidDiskKey: String;
		readonly _invalidDiskReplicationId: String;
		readonly _invalidPersistentFilePath: String;
		readonly _reconfigureDiskReplicationIdNotAllowed: String;
		readonly diskNotFound: VcReplicationDiskConfigFaultReasonForFault;
		readonly diskTypeNotSupported: VcReplicationDiskConfigFaultReasonForFault;
		readonly duplicateDiskReplicationId: VcReplicationDiskConfigFaultReasonForFault;
		readonly id: String;
		readonly invalidDiskKey: VcReplicationDiskConfigFaultReasonForFault;
		readonly invalidDiskReplicationId: VcReplicationDiskConfigFaultReasonForFault;
		readonly invalidPersistentFilePath: VcReplicationDiskConfigFaultReasonForFault;
		readonly name: String;
		readonly reconfigureDiskReplicationIdNotAllowed: VcReplicationDiskConfigFaultReasonForFault;
		readonly value: String;

		fromString(value?: String): VcReplicationDiskConfigFaultReasonForFault;
	}

	interface VcReplicationDiskConfigFaultReasonForFaultConstructor {
		new(value?:any): VcReplicationDiskConfigFaultReasonForFault;
		readonly prototype: VcReplicationDiskConfigFaultReasonForFault;
	}

	declare const VcReplicationDiskConfigFaultReasonForFault: VcReplicationDiskConfigFaultReasonForFaultConstructor;

	declare class VcReplicationInfoDiskSettings
	{
		diskReplicationId: String;
		key: Number;

		constructor();
	}

	interface VcReplicationVmConfigFaultReasonForFault
	{
		readonly _cannotRetrieveVmReplicationConfiguration: String;
		readonly _incompatibleHwVersion: String;
		readonly _invalidDestinationIpAddress: String;
		readonly _invalidDestinationPort: String;
		readonly _invalidExtraVmOptions: String;
		readonly _invalidGenerationNumber: String;
		readonly _invalidPriorConfiguration: String;
		readonly _invalidVmReplicationId: String;
		readonly _outOfBoundsRpoValue: String;
		readonly _reconfigureVmReplicationIdNotAllowed: String;
		readonly _replicationAlreadyEnabled: String;
		readonly _replicationConfigurationFailed: String;
		readonly _replicationNotEnabled: String;
		readonly _staleGenerationNumber: String;
		readonly cannotRetrieveVmReplicationConfiguration: VcReplicationVmConfigFaultReasonForFault;
		readonly id: String;
		readonly incompatibleHwVersion: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidDestinationIpAddress: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidDestinationPort: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidExtraVmOptions: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidGenerationNumber: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidPriorConfiguration: VcReplicationVmConfigFaultReasonForFault;
		readonly invalidVmReplicationId: VcReplicationVmConfigFaultReasonForFault;
		readonly name: String;
		readonly outOfBoundsRpoValue: VcReplicationVmConfigFaultReasonForFault;
		readonly reconfigureVmReplicationIdNotAllowed: VcReplicationVmConfigFaultReasonForFault;
		readonly replicationAlreadyEnabled: VcReplicationVmConfigFaultReasonForFault;
		readonly replicationConfigurationFailed: VcReplicationVmConfigFaultReasonForFault;
		readonly replicationNotEnabled: VcReplicationVmConfigFaultReasonForFault;
		readonly staleGenerationNumber: VcReplicationVmConfigFaultReasonForFault;
		readonly value: String;

		fromString(value?: String): VcReplicationVmConfigFaultReasonForFault;
	}

	interface VcReplicationVmConfigFaultReasonForFaultConstructor {
		new(value?:any): VcReplicationVmConfigFaultReasonForFault;
		readonly prototype: VcReplicationVmConfigFaultReasonForFault;
	}

	declare const VcReplicationVmConfigFaultReasonForFault: VcReplicationVmConfigFaultReasonForFaultConstructor;

	interface VcReplicationVmFaultReasonForFault
	{
		readonly _invalidInstanceId: String;
		readonly _invalidState: String;
		readonly _notConfigured: String;
		readonly _offlineReplicating: String;
		readonly _poweredOff: String;
		readonly _poweredOn: String;
		readonly _suspended: String;
		readonly id: String;
		readonly invalidInstanceId: VcReplicationVmFaultReasonForFault;
		readonly invalidState: VcReplicationVmFaultReasonForFault;
		readonly name: String;
		readonly notConfigured: VcReplicationVmFaultReasonForFault;
		readonly offlineReplicating: VcReplicationVmFaultReasonForFault;
		readonly poweredOff: VcReplicationVmFaultReasonForFault;
		readonly poweredOn: VcReplicationVmFaultReasonForFault;
		readonly suspended: VcReplicationVmFaultReasonForFault;
		readonly value: String;

		fromString(value?: String): VcReplicationVmFaultReasonForFault;
	}

	interface VcReplicationVmFaultReasonForFaultConstructor {
		new(value?:any): VcReplicationVmFaultReasonForFault;
		readonly prototype: VcReplicationVmFaultReasonForFault;
	}

	declare const VcReplicationVmFaultReasonForFault: VcReplicationVmFaultReasonForFaultConstructor;

	interface VcReplicationVmInProgressFaultActivity
	{
		readonly _delta: String;
		readonly _fullSync: String;
		readonly delta: VcReplicationVmInProgressFaultActivity;
		readonly fullSync: VcReplicationVmInProgressFaultActivity;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcReplicationVmInProgressFaultActivity;
	}

	interface VcReplicationVmInProgressFaultActivityConstructor {
		new(value?:any): VcReplicationVmInProgressFaultActivity;
		readonly prototype: VcReplicationVmInProgressFaultActivity;
	}

	declare const VcReplicationVmInProgressFaultActivity: VcReplicationVmInProgressFaultActivityConstructor;

	declare class VcReplicationVmProgressInfo
	{
		bytesToTransfer: Number;
		bytesTransferred: Number;
		checksumComparedBytes: Number;
		checksumTotalBytes: Number;
		progress: Number;

		constructor();
	}

	interface VcReplicationVmState
	{
		readonly _active: String;
		readonly _error: String;
		readonly _idle: String;
		readonly _none: String;
		readonly _paused: String;
		readonly _syncing: String;
		readonly active: VcReplicationVmState;
		readonly error: VcReplicationVmState;
		readonly id: String;
		readonly idle: VcReplicationVmState;
		readonly name: String;
		readonly none: VcReplicationVmState;
		readonly paused: VcReplicationVmState;
		readonly syncing: VcReplicationVmState;
		readonly value: String;

		fromString(value?: String): VcReplicationVmState;
	}

	interface VcReplicationVmStateConstructor {
		new(value?:any): VcReplicationVmState;
		readonly prototype: VcReplicationVmState;
	}

	declare const VcReplicationVmState: VcReplicationVmStateConstructor;

	declare class VcResourceAllocationInfo
	{
		expandableReservation: boolean;
		limit: Number;
		overheadLimit: Number;
		reservation: Number;
		shares: VcSharesInfo;

		constructor();
	}

	declare class VcResourceAllocationOption
	{
		sharesOption: VcSharesOption;

		constructor();
	}

	declare class VcResourceConfigOption
	{
		cpuAllocationOption: VcResourceAllocationOption;
		memoryAllocationOption: VcResourceAllocationOption;

		constructor();
	}

	declare class VcResourceConfigSpec
	{
		changeVersion: String;
		cpuAllocation: VcResourceAllocationInfo;
		entity: VcManagedEntity;
		lastModified: Date;
		memoryAllocation: VcResourceAllocationInfo;
		networkBandwidthAllocation: VcNetworkBandwidthAllocationInfo[];

		constructor();
	}

	interface VcResourcePlanningManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		estimateDatabaseSize(dbSizeParam?: VcDatabaseSizeParam): VcDatabaseSizeEstimate;
	}

	declare const VcResourcePlanningManager: VcResourcePlanningManager;

	interface VcResourcePool
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		childConfiguration: VcResourceConfigSpec[];
		config: VcResourceConfigSpec;
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		readonly id: String;
		name: String;
		overallStatus: VcManagedEntityStatus;
		owner: VcComputeResource;
		parent: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		resourcePool: VcResourcePool[];
		readonly resourcePool_ResourcePool: ResourcePool[];
		readonly resourcePool_VirtualApp: VirtualApp[];
		runtime: VcResourcePoolRuntimeInfo;
		readonly sdkConnection: VcSdkConnection;
		summary: VcResourcePoolSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;
		vm: VcVirtualMachine[];

		createChildVM_Task(config?: VcVirtualMachineConfigSpec, host?: VcHostSystem): VcTask;
		createResourcePool(name?: String, spec?: VcResourceConfigSpec): VcResourcePool;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVApp(name?: String, resSpec?: VcResourceConfigSpec, configSpec?: VcVAppConfigSpec, vmFolder?: VcFolder): VcVirtualApp;
		destroy_Task(): VcTask;
		destroyChildren(): void;
		importVApp(spec?: VcImportSpec, folder?: VcFolder, host?: VcHostSystem): VcHttpNfcLease;
		moveIntoResourcePool(list?: VcManagedEntity[]): void;
		queryResourceConfigOption(): VcResourceConfigOption;
		refreshRuntime(): void;
		registerChildVM_Task(path?: String, name?: String, host?: VcHostSystem): VcTask;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
		updateChildResourceConfiguration(spec?: VcResourceConfigSpec[]): void;
		updateConfig(name?: String, config?: VcResourceConfigSpec): void;
	}

	declare const VcResourcePool: VcResourcePool;

	declare class VcResourcePoolCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		parent: VcResourcePoolEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcResourcePoolDestroyedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcResourcePoolEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcResourcePoolEventArgument
	{
		name: String;
		resourcePool: VcResourcePool;

		constructor();
	}

	declare class VcResourcePoolMovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newParent: VcResourcePoolEventArgument;
		oldParent: VcResourcePoolEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcResourcePoolQuickStats
	{
		balloonedMemory: Number;
		compressedMemory: Number;
		consumedOverheadMemory: Number;
		distributedCpuEntitlement: Number;
		distributedMemoryEntitlement: Number;
		guestMemoryUsage: Number;
		hostMemoryUsage: Number;
		overallCpuDemand: Number;
		overallCpuUsage: Number;
		overheadMemory: Number;
		privateMemory: Number;
		sharedMemory: Number;
		staticCpuEntitlement: Number;
		staticMemoryEntitlement: Number;
		swappedMemory: Number;

		constructor();
	}

	declare class VcResourcePoolReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcResourcePoolResourceUsage
	{
		maxUsage: Number;
		overallUsage: Number;
		reservationUsed: Number;
		reservationUsedForVm: Number;
		unreservedForPool: Number;
		unreservedForVm: Number;

		constructor();
	}

	declare class VcResourcePoolRuntimeInfo
	{
		cpu: VcResourcePoolResourceUsage;
		memory: VcResourcePoolResourceUsage;
		overallStatus: VcManagedEntityStatus;

		constructor();
	}

	declare class VcResourcePoolSummary
	{
		config: VcResourceConfigSpec;
		configuredMemoryMB: Number;
		name: String;
		quickStats: VcResourcePoolQuickStats;
		runtime: VcResourcePoolRuntimeInfo;

		constructor();
	}

	interface VcResourceType
	{
		readonly _cpu: String;
		readonly _memory: String;
		readonly cpu: VcResourceType;
		readonly id: String;
		readonly memory: VcResourceType;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcResourceType;
	}

	interface VcResourceTypeConstructor {
		new(value?:any): VcResourceType;
		readonly prototype: VcResourceType;
	}

	declare const VcResourceType: VcResourceTypeConstructor;

	declare class VcResourceViolatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		resourcePool: VcResourcePoolEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcRetrieveOptions
	{
		maxObjects: Number;

		constructor();
	}

	declare class VcRetrieveResult
	{
		objects: VcObjectContent[];
		token: String;

		constructor();
	}

	declare class VcRoleAddedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		privilegeList: String[];
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcRoleEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcRoleEventArgument
	{
		name: String;
		roleId: Number;

		constructor();
	}

	declare class VcRoleRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcRoleUpdatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		privilegeList: String[];
		role: VcRoleEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcRollbackEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		hostName: String;
		key: Number;
		methodName: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcRunScriptAction
	{
		script: String;

		constructor();
	}

	declare class VcSAMLTokenAuthentication
	{
		interactiveSession: boolean;
		token: String;
		username: String;

		constructor();
	}

	declare class VcScheduledHardwareUpgradeInfo
	{
		fault: VcLocalizedMethodFault;
		scheduledHardwareUpgradeStatus: String;
		upgradePolicy: String;
		versionKey: String;

		constructor();
	}

	interface VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy
	{
		readonly _always: String;
		readonly _never: String;
		readonly _onSoftPowerOff: String;
		readonly always: VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
		readonly id: String;
		readonly name: String;
		readonly never: VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
		readonly onSoftPowerOff: VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
		readonly value: String;

		fromString(value?: String): VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
	}

	interface VcScheduledHardwareUpgradeInfoHardwareUpgradePolicyConstructor {
		new(value?:any): VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
		readonly prototype: VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
	}

	declare const VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy: VcScheduledHardwareUpgradeInfoHardwareUpgradePolicyConstructor;

	interface VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus
	{
		readonly _failed: String;
		readonly _none: String;
		readonly _pending: String;
		readonly _success: String;
		readonly failed: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly id: String;
		readonly name: String;
		readonly none: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly pending: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly success: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly value: String;

		fromString(value?: String): VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
	}

	interface VcScheduledHardwareUpgradeInfoHardwareUpgradeStatusConstructor {
		new(value?:any): VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly prototype: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
	}

	declare const VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus: VcScheduledHardwareUpgradeInfoHardwareUpgradeStatusConstructor;

	interface VcScheduledTask
	{
		availableField: VcCustomFieldDef[];
		readonly id: String;
		info: VcScheduledTaskInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		reconfigureScheduledTask(spec?: VcScheduledTaskSpec): void;
		removeScheduledTask(): void;
		runScheduledTask(): void;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcScheduledTask: VcScheduledTask;

	declare class VcScheduledTaskCompletedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcScheduledTaskCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcScheduledTaskDescription
	{
		action: VcTypeDescription[];
		dayOfWeek: VcElementDescription[];
		schedulerInfo: VcScheduledTaskDetail[];
		state: VcElementDescription[];
		weekOfMonth: VcElementDescription[];

		constructor();
	}

	declare class VcScheduledTaskDetail
	{
		frequency: String;
		key: String;
		label: String;
		summary: String;

		constructor();
	}

	declare class VcScheduledTaskEmailCompletedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		to: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcScheduledTaskEmailFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		scheduledTask: VcScheduledTaskEventArgument;
		to: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcScheduledTaskEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcScheduledTaskEventArgument
	{
		name: String;
		scheduledTask: VcScheduledTask;

		constructor();
	}

	declare class VcScheduledTaskFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcScheduledTaskInfo
	{
		action: VcAction;
		activeTask: VcTask;
		description: String;
		enabled: boolean;
		entity: VcManagedEntity;
		error: VcLocalizedMethodFault;
		lastModifiedTime: Date;
		lastModifiedUser: String;
		name: String;
		nextRunTime: Date;
		notification: String;
		prevRunTime: Date;
		progress: Number;
		result: Object;
		result_FloatValue: Number;
		result_IntValue: Number;
		result_LongValue: Number;
		scheduledTask: VcScheduledTask;
		scheduler: VcTaskScheduler;
		state: VcTaskInfoState;
		taskObject: VcManagedObjectReference;

		constructor();
	}

	interface VcScheduledTaskManager
	{
		description: VcScheduledTaskDescription;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		scheduledTask: VcScheduledTask[];
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createObjectScheduledTask(obj?: VcManagedObjectReference, spec?: VcScheduledTaskSpec): VcScheduledTask;
		createScheduledTask(entity?: VcManagedEntity, spec?: VcScheduledTaskSpec): VcScheduledTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		retrieveEntityScheduledTask(entity?: VcManagedEntity): VcScheduledTask[];
		retrieveObjectScheduledTask(obj?: VcManagedObjectReference): VcScheduledTask[];
	}

	declare const VcScheduledTaskManager: VcScheduledTaskManager;

	declare class VcScheduledTaskReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcScheduledTaskRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcScheduledTaskSpec
	{
		action: VcAction;
		description: String;
		enabled: boolean;
		name: String;
		notification: String;
		scheduler: VcTaskScheduler;

		constructor();
	}

	declare class VcScheduledTaskStartedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		entity: VcManagedEntityEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		scheduledTask: VcScheduledTaskEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcScsiLun
	{
		alternateName: VcScsiLunDurableName[];
		canonicalName: String;
		capabilities: VcScsiLunCapabilities;
		descriptor: VcScsiLunDescriptor[];
		deviceName: String;
		deviceType: String;
		displayName: String;
		durableName: VcScsiLunDurableName;
		key: String;
		lunType: String;
		model: String;
		operationalState: String[];
		protocolEndpoint: boolean;
		queueDepth: Number;
		revision: String;
		scsiLevel: Number;
		serialNumber: String;
		standardInquiry: Number[];
		uuid: String;
		vendor: String;
		vStorageSupport: String;

		constructor();
	}

	declare class VcScsiLunCapabilities
	{
		updateDisplayNameSupported: boolean;

		constructor();
	}

	declare class VcScsiLunDescriptor
	{
		id: String;
		quality: String;

		constructor();
	}

	interface VcScsiLunDescriptorQuality
	{
		readonly _highQuality: String;
		readonly _lowQuality: String;
		readonly _mediumQuality: String;
		readonly _unknownQuality: String;
		readonly highQuality: VcScsiLunDescriptorQuality;
		readonly id: String;
		readonly lowQuality: VcScsiLunDescriptorQuality;
		readonly mediumQuality: VcScsiLunDescriptorQuality;
		readonly name: String;
		readonly unknownQuality: VcScsiLunDescriptorQuality;
		readonly value: String;

		fromString(value?: String): VcScsiLunDescriptorQuality;
	}

	interface VcScsiLunDescriptorQualityConstructor {
		new(value?:any): VcScsiLunDescriptorQuality;
		readonly prototype: VcScsiLunDescriptorQuality;
	}

	declare const VcScsiLunDescriptorQuality: VcScsiLunDescriptorQualityConstructor;

	declare class VcScsiLunDurableName
	{
		data: Number[];
		namespace: String;
		namespaceId: Number;

		constructor();
	}

	interface VcScsiLunState
	{
		readonly _degraded: String;
		readonly _error: String;
		readonly _lostCommunication: String;
		readonly _off: String;
		readonly _ok: String;
		readonly _quiesced: String;
		readonly _timeout: String;
		readonly _unknownState: String;
		readonly degraded: VcScsiLunState;
		readonly error: VcScsiLunState;
		readonly id: String;
		readonly lostCommunication: VcScsiLunState;
		readonly name: String;
		readonly off: VcScsiLunState;
		readonly ok: VcScsiLunState;
		readonly quiesced: VcScsiLunState;
		readonly timeout: VcScsiLunState;
		readonly unknownState: VcScsiLunState;
		readonly value: String;

		fromString(value?: String): VcScsiLunState;
	}

	interface VcScsiLunStateConstructor {
		new(value?:any): VcScsiLunState;
		readonly prototype: VcScsiLunState;
	}

	declare const VcScsiLunState: VcScsiLunStateConstructor;

	interface VcScsiLunType
	{
		readonly _cdrom: String;
		readonly _communications: String;
		readonly _disk: String;
		readonly _enclosure: String;
		readonly _mediaChanger: String;
		readonly _opticalDevice: String;
		readonly _printer: String;
		readonly _processor: String;
		readonly _scanner: String;
		readonly _storageArrayController: String;
		readonly _tape: String;
		readonly _unknown: String;
		readonly _worm: String;
		readonly cdrom: VcScsiLunType;
		readonly communications: VcScsiLunType;
		readonly disk: VcScsiLunType;
		readonly enclosure: VcScsiLunType;
		readonly id: String;
		readonly mediaChanger: VcScsiLunType;
		readonly name: String;
		readonly opticalDevice: VcScsiLunType;
		readonly printer: VcScsiLunType;
		readonly processor: VcScsiLunType;
		readonly scanner: VcScsiLunType;
		readonly storageArrayController: VcScsiLunType;
		readonly tape: VcScsiLunType;
		readonly unknown: VcScsiLunType;
		readonly value: String;
		readonly worm: VcScsiLunType;

		fromString(value?: String): VcScsiLunType;
	}

	interface VcScsiLunTypeConstructor {
		new(value?:any): VcScsiLunType;
		readonly prototype: VcScsiLunType;
	}

	declare const VcScsiLunType: VcScsiLunTypeConstructor;

	interface VcScsiLunVStorageSupportStatus
	{
		readonly _vStorageSupported: String;
		readonly _vStorageUnknown: String;
		readonly _vStorageUnsupported: String;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vStorageSupported: VcScsiLunVStorageSupportStatus;
		readonly vStorageUnknown: VcScsiLunVStorageSupportStatus;
		readonly vStorageUnsupported: VcScsiLunVStorageSupportStatus;

		fromString(value?: String): VcScsiLunVStorageSupportStatus;
	}

	interface VcScsiLunVStorageSupportStatusConstructor {
		new(value?:any): VcScsiLunVStorageSupportStatus;
		readonly prototype: VcScsiLunVStorageSupportStatus;
	}

	declare const VcScsiLunVStorageSupportStatus: VcScsiLunVStorageSupportStatusConstructor;

	interface VcSdkConnection
	{
		readonly about: VcAboutInfo;
		readonly aboutInfo: VcAboutInfo;
		readonly accountManager: VcHostLocalAccountManager;
		readonly alarmManager: VcAlarmManager;
		readonly allClusterComputeResources: VcClusterComputeResource[];
		readonly allComputeResources: VcComputeResource[];
		readonly allDatacenterFolders: VcFolder[];
		readonly allDatacenters: VcDatacenter[];
		readonly allDatastoreFolders: VcFolder[];
		readonly allDatastores: VcDatastore[];
		readonly allDistributedVirtualPortgroups: VcDistributedVirtualPortgroup[];
		readonly allHostfolders: VcFolder[];
		readonly allHostSystems: VcHostSystem[];
		readonly allNetworkFolders: VcFolder[];
		readonly allNetworks: VcNetwork[];
		readonly allResourcePools: VcResourcePool[];
		readonly allTasks: VcTask[];
		readonly allVirtualApps: VcVirtualApp[];
		readonly allVirtualMachines: VcVirtualMachine[];
		readonly allVirtualMachineSnapshots: VcVirtualMachineSnapshot[];
		readonly allVmFolders: VcFolder[];
		readonly authorizationManager: VcAuthorizationManager;
		readonly clusterProfileManager: VcClusterProfileManager;
		readonly complianceManager: VcProfileComplianceManager;
		readonly customFieldsManager: VcCustomFieldsManager;
		readonly customizationSpecManager: VcCustomizationSpecManager;
		readonly diagnosticManager: VcDiagnosticManager;
		readonly dvSwitchManager: VcDistributedVirtualSwitchManager;
		readonly eventManager: VcEventManager;
		readonly extensionManager: VcExtensionManager;
		readonly fileManager: VcFileManager;
		readonly guestOperationsManager: VcGuestOperationsManager;
		readonly hostLocalAccountManager: VcHostLocalAccountManager;
		readonly hostProfileManager: VcHostProfileManager;
		readonly ipPoolManager: VcIpPoolManager;
		readonly licenseManager: VcLicenseManager;
		readonly localizationManager: VcLocalizationManager;
		readonly optionManager: VcOptionManager;
		readonly ovfManager: VcOvfManager;
		readonly perfManager: VcPerformanceManager;
		readonly performanceManager: VcPerformanceManager;
		readonly propertyCollector: VcPropertyCollector;
		readonly rootFolder: VcFolder;
		readonly scheduledTaskManager: VcScheduledTaskManager;
		readonly searchIndex: VcSearchIndex;
		readonly serviceInstance: VcServiceInstance;
		readonly sessionManager: VcSessionManager;
		readonly setting: VcOptionManager;
		readonly snmpSystem: VcHostSnmpSystem;
		readonly storageResourceManager: VcStorageResourceManager;
		readonly taskManager: VcTaskManager;
		readonly userDirectory: VcUserDirectory;
		readonly viewManager: VcViewManager;
		readonly virtualDiskManager: VcVirtualDiskManager;
		readonly virtualizationManger: VcVirtualizationManager;
		readonly vmCompatibilityChecker: VcVirtualMachineCompatibilityChecker;
		readonly vmProvisioningChecker: VcVirtualMachineProvisioningChecker;

		executeQuery(xQuery?: String): String;
		getAllClusterComputeResources(additionalPropertyFilters?: String[], query?: String): VcClusterComputeResource[];
		getAllComputeResources(additionalPropertyFilters?: String[], query?: String): VcComputeResource[];
		getAllDatacenterFolders(additionalPropertyFilters?: String[], query?: String): VcFolder[];
		getAllDatacenters(additionalPropertyFilters?: String[], query?: String): VcDatacenter[];
		getAllDatastoreFolders(additionalPropertyFilters?: String[], query?: String): VcFolder[];
		getAllDatastores(additionalPropertyFilters?: String[], query?: String): VcDatastore[];
		getAllDistributedVirtualPortgroups(additionalPropertyFilters?: String[], query?: String): VcDistributedVirtualPortgroup[];
		getAllHostFolders(additionalPropertyFilters?: String[], query?: String): VcFolder[];
		getAllHostSystems(additionalPropertyFilters?: String[], query?: String): VcHostSystem[];
		getAllManagedObjects(sdkType?: String, additionalPropertyFilters?: String[], query?: String): VcManagedObject[];
		getAllNetworkFolders(additionalPropertyFilters?: String[], query?: String): VcFolder[];
		getAllNetworks(additionalPropertyFilters?: String[], query?: String): VcNetwork[];
		getAllResourcePools(additionalPropertyFilters?: String[], query?: String): VcResourcePool[];
		getAllTasks(additionalPropertyFilters?: String[], query?: String): VcTask[];
		getAllVirtualApps(additionalPropertyFilters?: String[], query?: String): VcVirtualApp[];
		getAllVirtualMachines(additionalPropertyFilters?: String[], query?: String): VcVirtualMachine[];
		getAllVirtualMachineSnapshots(additionalPropertyFilters?: String[], query?: String): VcVirtualMachineSnapshot[];
		getAllVmFolders(additionalPropertyFilters?: String[], query?: String): VcFolder[];
		isInventoryServiceAvailable(): String;
	}

	declare const VcSdkConnection: VcSdkConnection;

	interface VcSearchIndex
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		findAllByDnsName(datacenter?: VcDatacenter, dnsName?: String, vmSearch?: boolean): VcManagedEntity[];
		findAllByIp(datacenter?: VcDatacenter, ip?: String, vmSearch?: boolean): VcManagedEntity[];
		findAllByUuid(datacenter?: VcDatacenter, uuid?: String, vmSearch?: boolean, instanceUuid?: boolean): VcManagedEntity[];
		findByDatastorePath(datacenter?: VcDatacenter, path?: String): VcVirtualMachine;
		findByDnsName(datacenter?: VcDatacenter, dnsName?: String, vmSearch?: boolean): VcManagedEntity;
		findByInventoryPath(inventoryPath?: String): VcManagedEntity;
		findByIp(datacenter?: VcDatacenter, ip?: String, vmSearch?: boolean): VcManagedEntity;
		findByUuid(datacenter?: VcDatacenter, uuid?: String, vmSearch?: boolean, instanceUuid?: boolean): VcManagedEntity;
		findChild(entity?: VcManagedEntity, name?: String): VcManagedEntity;
	}

	declare const VcSearchIndex: VcSearchIndex;

	declare class VcSecurityProfile
	{
		enabled: boolean;
		permission: VcPermissionProfile[];
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcSelectionSet
	{

		constructor();
	}

	declare class VcSelectionSpec
	{
		name: String;

		constructor();
	}

	declare class VcSendEmailAction
	{
		body: String;
		ccList: String;
		subject: String;
		toList: String;

		constructor();
	}

	declare class VcSendSNMPAction
	{

		constructor();
	}

	declare class VcServerLicenseExpiredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		product: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcServerStartedSessionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcServiceConsolePortGroupProfile
	{
		enabled: boolean;
		ipConfig: VcIpAddressProfile;
		key: String;
		name: String;
		networkPolicy: VcNetworkPolicyProfile;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		vlan: VcVlanProfile;
		vswitch: VcVirtualSwitchSelectionProfile;

		constructor();
	}

	declare class VcServiceConsoleReservationInfo
	{
		serviceConsoleReserved: Number;
		serviceConsoleReservedCfg: Number;
		unreserved: Number;

		constructor();
	}

	declare class VcServiceContent
	{
		about: VcAboutInfo;
		accountManager: VcHostLocalAccountManager;
		alarmManager: VcAlarmManager;
		authorizationManager: VcAuthorizationManager;
		certificateManager: VcCertificateManager;
		clusterProfileManager: VcClusterProfileManager;
		complianceManager: VcProfileComplianceManager;
		customFieldsManager: VcCustomFieldsManager;
		customizationSpecManager: VcCustomizationSpecManager;
		datastoreNamespaceManager: VcDatastoreNamespaceManager;
		diagnosticManager: VcDiagnosticManager;
		dvSwitchManager: VcDistributedVirtualSwitchManager;
		eventManager: VcEventManager;
		extensionManager: VcExtensionManager;
		fileManager: VcFileManager;
		guestOperationsManager: VcGuestOperationsManager;
		hookManager: VcHookManager;
		hostProfileManager: VcHostProfileManager;
		ioFilterManager: VcIoFilterManager;
		ipPoolManager: VcIpPoolManager;
		licenseManager: VcLicenseManager;
		localizationManager: VcLocalizationManager;
		overheadMemoryManager: VcOverheadMemoryManager;
		ovfManager: VcOvfManager;
		perfManager: VcPerformanceManager;
		propertyCollector: VcPropertyCollector;
		rootFolder: VcFolder;
		scheduledTaskManager: VcScheduledTaskManager;
		searchIndex: VcSearchIndex;
		serviceManager: VcServiceManager;
		sessionManager: VcSessionManager;
		setting: VcOptionManager;
		snmpSystem: VcHostSnmpSystem;
		storageResourceManager: VcStorageResourceManager;
		taskManager: VcTaskManager;
		userDirectory: VcUserDirectory;
		viewManager: VcViewManager;
		virtualDiskManager: VcVirtualDiskManager;
		virtualizationManager: VcVirtualizationManager;
		vmCompatibilityChecker: VcVirtualMachineCompatibilityChecker;
		vmProvisioningChecker: VcVirtualMachineProvisioningChecker;

		constructor();
	}

	declare class VcServiceInfo
	{
		description: String;
		enabled: boolean;
		location: String;
		serviceKey: String;

		constructor();
	}

	interface VcServiceInstance
	{

	}

	declare const VcServiceInstance: VcServiceInstance;

	declare class VcServiceLocator
	{
		credential: VcServiceLocatorCredential;
		instanceUuid: String;
		sslThumbprint: String;
		url: String;

		constructor();
	}

	declare class VcServiceLocatorCredential
	{

		constructor();
	}

	declare class VcServiceLocatorNamePassword
	{
		password: String;
		username: String;

		constructor();
	}

	declare class VcServiceLocatorSAMLCredential
	{
		token: String;

		constructor();
	}

	interface VcServiceManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		service: VcServiceManagerServiceInfo[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryServiceList(serviceName?: String, location?: String[]): VcServiceManagerServiceInfo[];
	}

	declare const VcServiceManager: VcServiceManager;

	declare class VcServiceManagerServiceInfo
	{
		description: String;
		location: String[];
		service: VcManagedObjectReference;
		serviceName: String;

		constructor();
	}

	declare class VcServiceProfile
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcSeSparseVirtualDiskSpec
	{
		adapterType: String;
		capacityKb: Number;
		diskType: String;
		grainSizeKb: Number;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
	}

	declare class VcSessionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcSessionManager
	{
		currentSession: VcUserSession;
		defaultLocale: String;
		readonly id: String;
		message: String;
		messageLocaleList: String[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		sessionList: VcUserSession[];
		supportedLocaleList: String[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		acquireCloneTicket(): String;
		acquireGenericServiceTicket(spec?: VcSessionManagerServiceRequestSpec): VcSessionManagerGenericServiceTicket;
		acquireLocalTicket(userName?: String): VcSessionManagerLocalTicket;
		cloneSession(cloneTicket?: String): VcUserSession;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		impersonateUser(userName?: String, locale?: String): VcUserSession;
		login(userName?: String, password?: String, locale?: String): VcUserSession;
		loginBySSPI(base64Token?: String, locale?: String): VcUserSession;
		loginByToken(locale?: String): VcUserSession;
		loginExtensionByCertificate(extensionKey?: String, locale?: String): VcUserSession;
		loginExtensionBySubjectName(extensionKey?: String, locale?: String): VcUserSession;
		logout(): void;
		sessionIsActive(sessionID?: String, userName?: String): boolean;
		setLocale(locale?: String): void;
		terminateSession(sessionId?: String[]): void;
		updateServiceMessage(message?: String): void;
	}

	declare const VcSessionManager: VcSessionManager;

	declare class VcSessionManagerGenericServiceTicket
	{
		hostName: String;
		id: String;
		sslThumbprint: String;

		constructor();
	}

	declare class VcSessionManagerHttpServiceRequestSpec
	{
		method: String;
		url: String;

		constructor();
	}

	interface VcSessionManagerHttpServiceRequestSpecMethod
	{
		readonly _httpConnect: String;
		readonly _httpDelete: String;
		readonly _httpGet: String;
		readonly _httpHead: String;
		readonly _httpOptions: String;
		readonly _httpPost: String;
		readonly _httpPut: String;
		readonly _httpTrace: String;
		readonly httpConnect: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpDelete: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpGet: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpHead: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpOptions: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpPost: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpPut: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly httpTrace: VcSessionManagerHttpServiceRequestSpecMethod;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcSessionManagerHttpServiceRequestSpecMethod;
	}

	interface VcSessionManagerHttpServiceRequestSpecMethodConstructor {
		new(value?:any): VcSessionManagerHttpServiceRequestSpecMethod;
		readonly prototype: VcSessionManagerHttpServiceRequestSpecMethod;
	}

	declare const VcSessionManagerHttpServiceRequestSpecMethod: VcSessionManagerHttpServiceRequestSpecMethodConstructor;

	declare class VcSessionManagerLocalTicket
	{
		passwordFilePath: String;
		userName: String;

		constructor();
	}

	declare class VcSessionManagerServiceRequestSpec
	{

		constructor();
	}

	declare class VcSessionManagerVmomiServiceRequestSpec
	{
		method: String;

		constructor();
	}

	declare class VcSessionTerminatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sessionId: String;
		terminatedUsername: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcSharesInfo
	{
		level: VcSharesLevel;
		shares: Number;

		constructor();
	}

	interface VcSharesLevel
	{
		readonly _custom: String;
		readonly _high: String;
		readonly _low: String;
		readonly _normal: String;
		readonly custom: VcSharesLevel;
		readonly high: VcSharesLevel;
		readonly id: String;
		readonly low: VcSharesLevel;
		readonly name: String;
		readonly normal: VcSharesLevel;
		readonly value: String;

		fromString(value?: String): VcSharesLevel;
	}

	interface VcSharesLevelConstructor {
		new(value?:any): VcSharesLevel;
		readonly prototype: VcSharesLevel;
	}

	declare const VcSharesLevel: VcSharesLevelConstructor;

	declare class VcSharesOption
	{
		defaultLevel: VcSharesLevel;
		sharesOption: VcIntOption;

		constructor();
	}

	interface VcSimpleCommand
	{
		encodingType: VcSimpleCommandEncoding;
		entity: VcServiceManagerServiceInfo;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		executeSimpleCommand(arguments?: String[]): String;
	}

	declare const VcSimpleCommand: VcSimpleCommand;

	interface VcSimpleCommandEncoding
	{
		readonly _CSV: String;
		readonly _HEX: String;
		readonly _STRING: String;
		readonly CSV: VcSimpleCommandEncoding;
		readonly HEX: VcSimpleCommandEncoding;
		readonly id: String;
		readonly name: String;
		readonly STRING: VcSimpleCommandEncoding;
		readonly value: String;

		fromString(value?: String): VcSimpleCommandEncoding;
	}

	interface VcSimpleCommandEncodingConstructor {
		new(value?:any): VcSimpleCommandEncoding;
		readonly prototype: VcSimpleCommandEncoding;
	}

	declare const VcSimpleCommandEncoding: VcSimpleCommandEncodingConstructor;

	declare class VcSingleIp
	{
		address: String;
		negate: boolean;

		constructor();
	}

	declare class VcSingleMac
	{
		address: String;
		negate: boolean;

		constructor();
	}

	interface VcSlpDiscoveryMethod
	{
		readonly _slpAutoMulticast: String;
		readonly _slpAutoUnicast: String;
		readonly _slpDhcp: String;
		readonly _slpManual: String;
		readonly id: String;
		readonly name: String;
		readonly slpAutoMulticast: VcSlpDiscoveryMethod;
		readonly slpAutoUnicast: VcSlpDiscoveryMethod;
		readonly slpDhcp: VcSlpDiscoveryMethod;
		readonly slpManual: VcSlpDiscoveryMethod;
		readonly value: String;

		fromString(value?: String): VcSlpDiscoveryMethod;
	}

	interface VcSlpDiscoveryMethodConstructor {
		new(value?:any): VcSlpDiscoveryMethod;
		readonly prototype: VcSlpDiscoveryMethod;
	}

	declare const VcSlpDiscoveryMethod: VcSlpDiscoveryMethodConstructor;

	declare class VcSSPIAuthentication
	{
		interactiveSession: boolean;
		sspiToken: String;

		constructor();
	}

	declare class VcStateAlarmExpression
	{
		operator: VcStateAlarmOperator;
		red: String;
		statePath: String;
		type: String;
		yellow: String;

		constructor();
	}

	interface VcStateAlarmOperator
	{
		readonly _isEqual: String;
		readonly _isUnequal: String;
		readonly id: String;
		readonly isEqual: VcStateAlarmOperator;
		readonly isUnequal: VcStateAlarmOperator;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcStateAlarmOperator;
	}

	interface VcStateAlarmOperatorConstructor {
		new(value?:any): VcStateAlarmOperator;
		readonly prototype: VcStateAlarmOperator;
	}

	declare const VcStateAlarmOperator: VcStateAlarmOperatorConstructor;

	declare class VcStaticRouteProfile
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcStorageDrsAutomationConfig
	{
		ioLoadBalanceAutomationMode: String;
		policyEnforcementAutomationMode: String;
		ruleEnforcementAutomationMode: String;
		spaceLoadBalanceAutomationMode: String;
		vmEvacuationAutomationMode: String;

		constructor();
	}

	declare class VcStorageDrsConfigInfo
	{
		podConfig: VcStorageDrsPodConfigInfo;
		vmConfig: VcStorageDrsVmConfigInfo[];

		constructor();
	}

	declare class VcStorageDrsConfigSpec
	{
		podConfigSpec: VcStorageDrsPodConfigSpec;
		vmConfigSpec: VcStorageDrsVmConfigSpec[];

		constructor();
	}

	declare class VcStorageDrsIoLoadBalanceConfig
	{
		ioLatencyThreshold: Number;
		ioLoadImbalanceThreshold: Number;
		reservableIopsThreshold: Number;
		reservablePercentThreshold: Number;
		reservableThresholdMode: String;

		constructor();
	}

	declare class VcStorageDrsOptionSpec
	{
		operation: VcArrayUpdateOperation;
		option: VcOptionValue;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcStorageDrsPlacementRankVmSpec
	{
		vmClusters: VcClusterComputeResource[];
		vmPlacementSpec: VcPlacementSpec;

		constructor();
	}

	declare class VcStorageDrsPodConfigInfo
	{
		automationOverrides: VcStorageDrsAutomationConfig;
		defaultIntraVmAffinity: boolean;
		defaultVmBehavior: String;
		enabled: boolean;
		ioLoadBalanceConfig: VcStorageDrsIoLoadBalanceConfig;
		ioLoadBalanceEnabled: boolean;
		loadBalanceInterval: Number;
		option: VcOptionValue[];
		rule: VcClusterRuleInfo[];
		spaceLoadBalanceConfig: VcStorageDrsSpaceLoadBalanceConfig;

		constructor();
	}

	interface VcStorageDrsPodConfigInfoBehavior
	{
		readonly _automated: String;
		readonly _manual: String;
		readonly automated: VcStorageDrsPodConfigInfoBehavior;
		readonly id: String;
		readonly manual: VcStorageDrsPodConfigInfoBehavior;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcStorageDrsPodConfigInfoBehavior;
	}

	interface VcStorageDrsPodConfigInfoBehaviorConstructor {
		new(value?:any): VcStorageDrsPodConfigInfoBehavior;
		readonly prototype: VcStorageDrsPodConfigInfoBehavior;
	}

	declare const VcStorageDrsPodConfigInfoBehavior: VcStorageDrsPodConfigInfoBehaviorConstructor;

	declare class VcStorageDrsPodConfigSpec
	{
		automationOverrides: VcStorageDrsAutomationConfig;
		defaultIntraVmAffinity: boolean;
		defaultVmBehavior: String;
		enabled: boolean;
		ioLoadBalanceConfig: VcStorageDrsIoLoadBalanceConfig;
		ioLoadBalanceEnabled: boolean;
		loadBalanceInterval: Number;
		option: VcStorageDrsOptionSpec[];
		rule: VcClusterRuleSpec[];
		spaceLoadBalanceConfig: VcStorageDrsSpaceLoadBalanceConfig;

		constructor();
	}

	declare class VcStorageDrsPodSelectionSpec
	{
		initialVmConfig: VcVmPodConfigForPlacement[];
		storagePod: VcStoragePod;

		constructor();
	}

	declare class VcStorageDrsSpaceLoadBalanceConfig
	{
		freeSpaceThresholdGB: Number;
		minSpaceUtilizationDifference: Number;
		spaceThresholdMode: String;
		spaceUtilizationThreshold: Number;

		constructor();
	}

	interface VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode
	{
		readonly _freeSpace: String;
		readonly _utilization: String;
		readonly freeSpace: VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
		readonly id: String;
		readonly name: String;
		readonly utilization: VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
		readonly value: String;

		fromString(value?: String): VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
	}

	interface VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdModeConstructor {
		new(value?:any): VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
		readonly prototype: VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
	}

	declare const VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode: VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdModeConstructor;

	declare class VcStorageDrsVmConfigInfo
	{
		behavior: String;
		enabled: boolean;
		intraVmAffinity: boolean;
		intraVmAntiAffinity: VcVirtualDiskAntiAffinityRuleSpec;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcStorageDrsVmConfigSpec
	{
		info: VcStorageDrsVmConfigInfo;
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcStorageIOAllocationInfo
	{
		limit: Number;
		reservation: Number;
		shares: VcSharesInfo;

		constructor();
	}

	declare class VcStorageIOAllocationOption
	{
		limitOption: VcLongOption;
		sharesOption: VcSharesOption;

		constructor();
	}

	declare class VcStorageIORMConfigOption
	{
		congestionThresholdOption: VcIntOption;
		enabledOption: VcBoolOption;
		reservationEnabledOption: VcBoolOption;
		statsCollectionEnabledOption: VcBoolOption;

		constructor();
	}

	declare class VcStorageIORMConfigSpec
	{
		congestionThreshold: Number;
		congestionThresholdMode: String;
		enabled: boolean;
		percentOfPeakThroughput: Number;
		reservableIopsThreshold: Number;
		reservationEnabled: boolean;
		statsAggregationDisabled: boolean;
		statsCollectionEnabled: boolean;

		constructor();
	}

	declare class VcStorageIORMInfo
	{
		congestionThreshold: Number;
		congestionThresholdMode: String;
		enabled: boolean;
		percentOfPeakThroughput: Number;
		reservableIopsThreshold: Number;
		reservationEnabled: boolean;
		statsAggregationDisabled: boolean;
		statsCollectionEnabled: boolean;

		constructor();
	}

	interface VcStorageIORMThresholdMode
	{
		readonly _automatic: String;
		readonly _manual: String;
		readonly automatic: VcStorageIORMThresholdMode;
		readonly id: String;
		readonly manual: VcStorageIORMThresholdMode;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcStorageIORMThresholdMode;
	}

	interface VcStorageIORMThresholdModeConstructor {
		new(value?:any): VcStorageIORMThresholdMode;
		readonly prototype: VcStorageIORMThresholdMode;
	}

	declare const VcStorageIORMThresholdMode: VcStorageIORMThresholdModeConstructor;

	declare class VcStorageMigrationAction
	{
		destination: VcDatastore;
		ioLatencyDstBefore: Number;
		ioLatencySrcBefore: Number;
		relocateSpec: VcVirtualMachineRelocateSpec;
		sizeTransferred: Number;
		source: VcDatastore;
		spaceUtilDstAfter: Number;
		spaceUtilDstBefore: Number;
		spaceUtilSrcAfter: Number;
		spaceUtilSrcBefore: Number;
		target: VcManagedObjectReference;
		type: String;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcStoragePerformanceSummary
	{
		datastoreReadIops: Number[];
		datastoreReadLatency: Number[];
		datastoreVmLatency: Number[];
		datastoreWriteIops: Number[];
		datastoreWriteLatency: Number[];
		interval: Number;
		percentile: Number[];
		siocActivityDuration: Number;

		constructor();
	}

	declare class VcStoragePlacementAction
	{
		destination: VcDatastore;
		ioLatencyBefore: Number;
		relocateSpec: VcVirtualMachineRelocateSpec;
		spaceDemandAfter: Number;
		spaceDemandBefore: Number;
		spaceUtilAfter: Number;
		spaceUtilBefore: Number;
		target: VcManagedObjectReference;
		type: String;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcStoragePlacementResult
	{
		drsFault: VcClusterDrsFaults;
		recommendations: VcClusterRecommendation[];
		task: VcTask;

		constructor();
	}

	declare class VcStoragePlacementSpec
	{
		cloneName: String;
		cloneSpec: VcVirtualMachineCloneSpec;
		configSpec: VcVirtualMachineConfigSpec;
		disallowPrerequisiteMoves: boolean;
		folder: VcFolder;
		host: VcHostSystem;
		podSelectionSpec: VcStorageDrsPodSelectionSpec;
		priority: VcVirtualMachineMovePriority;
		relocateSpec: VcVirtualMachineRelocateSpec;
		resourceLeaseDurationSec: Number;
		resourcePool: VcResourcePool;
		type: String;
		vm: VcVirtualMachine;

		constructor();
	}

	interface VcStoragePlacementSpecPlacementType
	{
		readonly _clone: String;
		readonly _create: String;
		readonly _reconfigure: String;
		readonly _relocate: String;
		readonly clone: VcStoragePlacementSpecPlacementType;
		readonly create: VcStoragePlacementSpecPlacementType;
		readonly id: String;
		readonly name: String;
		readonly reconfigure: VcStoragePlacementSpecPlacementType;
		readonly relocate: VcStoragePlacementSpecPlacementType;
		readonly value: String;

		fromString(value?: String): VcStoragePlacementSpecPlacementType;
	}

	interface VcStoragePlacementSpecPlacementTypeConstructor {
		new(value?:any): VcStoragePlacementSpecPlacementType;
		readonly prototype: VcStoragePlacementSpecPlacementType;
	}

	declare const VcStoragePlacementSpecPlacementType: VcStoragePlacementSpecPlacementTypeConstructor;

	interface VcStoragePod
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		childEntity: VcManagedEntity[];
		childType: String[];
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		readonly id: String;
		name: String;
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		podStorageDrsEntry: VcPodStorageDrsEntry;
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		summary: VcStoragePodSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addStandaloneHost_Task(spec?: VcHostConnectSpec, compResSpec?: VcComputeResourceConfigSpec, addConnected?: boolean, license?: String): VcTask;
		createCluster(name?: String, spec?: VcClusterConfigSpec): VcClusterComputeResource;
		createClusterEx(name?: String, spec?: VcClusterConfigSpecEx): VcClusterComputeResource;
		createDatacenter(name?: String): VcDatacenter;
		createDVS_Task(spec?: VcDVSCreateSpec): VcTask;
		createFolder(name?: String): VcFolder;
		createStoragePod(name?: String): VcStoragePod;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVM_Task(config?: VcVirtualMachineConfigSpec, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		destroy_Task(): VcTask;
		moveIntoFolder_Task(list?: VcManagedEntity[]): VcTask;
		registerVM_Task(path?: String, name?: String, asTemplate?: boolean, pool?: VcResourcePool, host?: VcHostSystem): VcTask;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
		unregisterAndDestroy_Task(): VcTask;
	}

	declare const VcStoragePod: VcStoragePod;

	declare class VcStoragePodSummary
	{
		capacity: Number;
		freeSpace: Number;
		name: String;

		constructor();
	}

	declare class VcStorageProfile
	{
		enabled: boolean;
		nasStorage: VcNasStorageProfile[];
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcStorageRequirement
	{
		datastore: VcDatastore;
		freeSpaceRequiredInKb: Number;

		constructor();
	}

	interface VcStorageResourceManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		applyStorageDrsRecommendation_Task(key?: String[]): VcTask;
		applyStorageDrsRecommendationToPod_Task(pod?: VcStoragePod, key?: String): VcTask;
		cancelStorageDrsRecommendation(key?: String[]): void;
		configureDatastoreIORM_Task(datastore?: VcDatastore, spec?: VcStorageIORMConfigSpec): VcTask;
		configureStorageDrsForPod_Task(pod?: VcStoragePod, spec?: VcStorageDrsConfigSpec, modify?: boolean): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryDatastorePerformanceSummary(datastore?: VcDatastore): VcStoragePerformanceSummary[];
		queryIORMConfigOption(host?: VcHostSystem): VcStorageIORMConfigOption;
		recommendDatastores(storageSpec?: VcStoragePlacementSpec): VcStoragePlacementResult;
		refreshStorageDrsRecommendation(pod?: VcStoragePod): void;
	}

	declare const VcStorageResourceManager: VcStorageResourceManager;

	declare class VcStorageResourceManagerStorageProfileStatistics
	{
		profileId: String;
		totalSpaceMB: Number;
		usedSpaceMB: Number;

		constructor();
	}

	declare class VcStringExpression
	{
		negate: boolean;
		value: String;

		constructor();
	}

	declare class VcStringOption
	{
		defaultValue: String;
		validCharacters: String;
		valueIsReadonly: boolean;

		constructor();
	}

	declare class VcStringPolicy
	{
		inherited: boolean;
		value: String;

		constructor();
	}

	declare class VcTag
	{
		key: String;

		constructor();
	}

	interface VcTask
	{
		availableField: VcCustomFieldDef[];
		readonly id: String;
		info: VcTaskInfo;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		cancelTask(): void;
		createEndOfTaskTrigger(timeout?: Number): Trigger;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		setCustomValue(key?: String, value?: String): void;
		setTaskDescription(description?: VcLocalizableMessage): void;
		setTaskState(state?: VcTaskInfoState, result?: Object, fault?: VcMethodFault): void;
		updateProgress(percentDone?: Number): void;
	}

	declare const VcTask: VcTask;

	declare class VcTaskDescription
	{
		methodInfo: VcElementDescription[];
		reason: VcTypeDescription[];
		state: VcElementDescription[];

		constructor();
	}

	declare class VcTaskEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		info: VcTaskInfo;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcTaskFilterSpec
	{
		activationId: String[];
		alarm: VcAlarm;
		entity: VcTaskFilterSpecByEntity;
		eventChainId: Number[];
		parentTaskKey: String[];
		rootTaskKey: String[];
		scheduledTask: VcScheduledTask;
		state: VcTaskInfoState[];
		tag: String[];
		time: VcTaskFilterSpecByTime;
		userName: VcTaskFilterSpecByUsername;

		constructor();
	}

	declare class VcTaskFilterSpecByEntity
	{
		entity: VcManagedEntity;
		recursion: VcTaskFilterSpecRecursionOption;

		constructor();
	}

	declare class VcTaskFilterSpecByTime
	{
		beginTime: Date;
		endTime: Date;
		timeType: VcTaskFilterSpecTimeOption;

		constructor();
	}

	declare class VcTaskFilterSpecByUsername
	{
		systemUser: boolean;
		userList: String[];

		constructor();
	}

	interface VcTaskFilterSpecRecursionOption
	{
		readonly _all: String;
		readonly _children: String;
		readonly _self: String;
		readonly all: VcTaskFilterSpecRecursionOption;
		readonly children: VcTaskFilterSpecRecursionOption;
		readonly id: String;
		readonly name: String;
		readonly self: VcTaskFilterSpecRecursionOption;
		readonly value: String;

		fromString(value?: String): VcTaskFilterSpecRecursionOption;
	}

	interface VcTaskFilterSpecRecursionOptionConstructor {
		new(value?:any): VcTaskFilterSpecRecursionOption;
		readonly prototype: VcTaskFilterSpecRecursionOption;
	}

	declare const VcTaskFilterSpecRecursionOption: VcTaskFilterSpecRecursionOptionConstructor;

	interface VcTaskFilterSpecTimeOption
	{
		readonly _completedTime: String;
		readonly _queuedTime: String;
		readonly _startedTime: String;
		readonly completedTime: VcTaskFilterSpecTimeOption;
		readonly id: String;
		readonly name: String;
		readonly queuedTime: VcTaskFilterSpecTimeOption;
		readonly startedTime: VcTaskFilterSpecTimeOption;
		readonly value: String;

		fromString(value?: String): VcTaskFilterSpecTimeOption;
	}

	interface VcTaskFilterSpecTimeOptionConstructor {
		new(value?:any): VcTaskFilterSpecTimeOption;
		readonly prototype: VcTaskFilterSpecTimeOption;
	}

	declare const VcTaskFilterSpecTimeOption: VcTaskFilterSpecTimeOptionConstructor;

	interface VcTaskHistoryCollector
	{
		filter: Object;
		readonly id: String;
		latestPage: VcTaskInfo[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroyCollector(): void;
		readNextTasks(maxCount?: Number): VcTaskInfo[];
		readPreviousTasks(maxCount?: Number): VcTaskInfo[];
		resetCollector(): void;
		rewindCollector(): void;
		setCollectorPageSize(maxCount?: Number): void;
	}

	declare const VcTaskHistoryCollector: VcTaskHistoryCollector;

	declare class VcTaskInfo
	{
		activationId: String;
		cancelable: boolean;
		cancelled: boolean;
		changeTag: String;
		completeTime: Date;
		description: VcLocalizableMessage;
		descriptionId: String;
		entity: VcManagedEntity;
		entityName: String;
		error: VcLocalizedMethodFault;
		eventChainId: Number;
		key: String;
		locked: VcManagedEntity[];
		name: String;
		parentTaskKey: String;
		progress: Number;
		queueTime: Date;
		reason: VcTaskReason;
		result: Object;
		result_FloatValue: Number;
		result_IntValue: Number;
		result_LongValue: Number;
		rootTaskKey: String;
		startTime: Date;
		state: VcTaskInfoState;
		task: VcTask;

		constructor();
	}

	interface VcTaskInfoState
	{
		readonly _error: String;
		readonly _queued: String;
		readonly _running: String;
		readonly _success: String;
		readonly error: VcTaskInfoState;
		readonly id: String;
		readonly name: String;
		readonly queued: VcTaskInfoState;
		readonly running: VcTaskInfoState;
		readonly success: VcTaskInfoState;
		readonly value: String;

		fromString(value?: String): VcTaskInfoState;
	}

	interface VcTaskInfoStateConstructor {
		new(value?:any): VcTaskInfoState;
		readonly prototype: VcTaskInfoState;
	}

	declare const VcTaskInfoState: VcTaskInfoStateConstructor;

	interface VcTaskManager
	{
		description: VcTaskDescription;
		readonly id: String;
		maxCollector: Number;
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createCollectorForTasks(filter?: VcTaskFilterSpec): VcTaskHistoryCollector;
		createTask(obj?: VcManagedObjectReference, taskTypeId?: String, initiatedBy?: String, cancelable?: boolean, parentTaskKey?: String, activationId?: String): VcTaskInfo;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcTaskManager: VcTaskManager;

	declare class VcTaskReason
	{

		constructor();
	}

	declare class VcTaskReasonAlarm
	{
		alarm: VcAlarm;
		alarmName: String;
		entity: VcManagedEntity;
		entityName: String;

		constructor();
	}

	declare class VcTaskReasonSchedule
	{
		name: String;
		scheduledTask: VcScheduledTask;

		constructor();
	}

	declare class VcTaskReasonSystem
	{

		constructor();
	}

	declare class VcTaskReasonUser
	{
		userName: String;

		constructor();
	}

	declare class VcTaskScheduler
	{
		activeTime: Date;
		expireTime: Date;

		constructor();
	}

	declare class VcTaskTimeoutEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		info: VcTaskInfo;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcTeamingMatchEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcTeamingMisMatchEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcTemplateBeingUpgradedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		legacyTemplate: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcTemplateConfigFileInfo
	{
		configVersion: Number;
		fileSize: Number;
		modification: Date;
		owner: String;
		path: String;

		constructor();
	}

	declare class VcTemplateConfigFileQuery
	{
		details: VcVmConfigFileQueryFlags;
		filter: VcVmConfigFileQueryFilter;

		constructor();
	}

	declare class VcTemplateUpgradedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		legacyTemplate: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcTemplateUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		legacyTemplate: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcTemplateUpgradeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		legacyTemplate: String;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcTestletFaultSeverity
	{
		readonly _catastrophic: String;
		readonly _critical: String;
		readonly _informative: String;
		readonly _minor: String;
		readonly _serious: String;
		readonly catastrophic: VcTestletFaultSeverity;
		readonly critical: VcTestletFaultSeverity;
		readonly id: String;
		readonly informative: VcTestletFaultSeverity;
		readonly minor: VcTestletFaultSeverity;
		readonly name: String;
		readonly serious: VcTestletFaultSeverity;
		readonly value: String;

		fromString(value?: String): VcTestletFaultSeverity;
	}

	interface VcTestletFaultSeverityConstructor {
		new(value?:any): VcTestletFaultSeverity;
		readonly prototype: VcTestletFaultSeverity;
	}

	declare const VcTestletFaultSeverity: VcTestletFaultSeverityConstructor;

	interface VcThirdPartyLicenseAssignmentFailedReason
	{
		readonly _licenseAssignmentFailed: String;
		readonly _moduleNotInstalled: String;
		readonly id: String;
		readonly licenseAssignmentFailed: VcThirdPartyLicenseAssignmentFailedReason;
		readonly moduleNotInstalled: VcThirdPartyLicenseAssignmentFailedReason;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcThirdPartyLicenseAssignmentFailedReason;
	}

	interface VcThirdPartyLicenseAssignmentFailedReasonConstructor {
		new(value?:any): VcThirdPartyLicenseAssignmentFailedReason;
		readonly prototype: VcThirdPartyLicenseAssignmentFailedReason;
	}

	declare const VcThirdPartyLicenseAssignmentFailedReason: VcThirdPartyLicenseAssignmentFailedReasonConstructor;

	declare class VcTicketedSessionAuthentication
	{
		interactiveSession: boolean;
		ticket: String;

		constructor();
	}

	declare class VcTimedOutHostOperationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcToolsConfigInfo
	{
		afterPowerOn: boolean;
		afterResume: boolean;
		beforeGuestReboot: boolean;
		beforeGuestShutdown: boolean;
		beforeGuestStandby: boolean;
		lastInstallInfo: VcToolsConfigInfoToolsLastInstallInfo;
		pendingCustomization: String;
		syncTimeWithHost: boolean;
		toolsUpgradePolicy: String;
		toolsVersion: Number;
		upgradeRebootPredict: boolean;

		constructor();
	}

	declare class VcToolsConfigInfoToolsLastInstallInfo
	{
		counter: Number;
		fault: VcLocalizedMethodFault;

		constructor();
	}

	declare class VcTraversalSpec
	{
		name: String;
		path: String;
		selectSet: VcSelectionSpec[];
		skip: boolean;
		type: String;

		constructor();
	}

	declare class VcTypeDescription
	{
		key: String;
		label: String;
		summary: String;

		constructor();
	}

	declare class VcUnattendedInstallSpec
	{
		guestId: String;
		mediaPath: String;

		constructor();
	}

	declare class VcUnattendedRedHatInstallSpec
	{
		guestId: String;
		hwClockUTC: boolean;
		mediaPath: String;
		productKey: String;
		rootPassword: VcCustomizationPassword;
		timeZone: String;
		userName: String;
		userPassword: String;

		constructor();
	}

	declare class VcUnattendedWindowsInstallSpec
	{
		adminFullName: String;
		adminPassword: String;
		guestId: String;
		mediaPath: String;
		productKey: String;
		timeZone: String;

		constructor();
	}

	declare class VcUnlicensedVirtualMachinesEvent
	{
		available: Number;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		unlicensed: Number;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUnlicensedVirtualMachinesFoundEvent
	{
		available: Number;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUpdatedAgentBeingRestartedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUpdateSet
	{
		filterSet: VcPropertyFilterUpdate[];
		truncated: boolean;
		version: String;

		constructor();
	}

	declare class VcUpdateVirtualMachineFilesResult
	{
		failedVmFile: VcUpdateVirtualMachineFilesResultFailedVmFileInfo[];

		constructor();
	}

	declare class VcUpdateVirtualMachineFilesResultFailedVmFileInfo
	{
		fault: VcLocalizedMethodFault;
		vmFile: String;

		constructor();
	}

	declare class VcUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcUpgradePolicy
	{
		readonly _manual: String;
		readonly _upgradeAtPowerCycle: String;
		readonly id: String;
		readonly manual: VcUpgradePolicy;
		readonly name: String;
		readonly upgradeAtPowerCycle: VcUpgradePolicy;
		readonly value: String;

		fromString(value?: String): VcUpgradePolicy;
	}

	interface VcUpgradePolicyConstructor {
		new(value?:any): VcUpgradePolicy;
		readonly prototype: VcUpgradePolicy;
	}

	declare const VcUpgradePolicy: VcUpgradePolicyConstructor;

	declare class VcUplinkPortMtuNotSupportEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUplinkPortMtuSupportEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUplinkPortVlanTrunkedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUplinkPortVlanUntrunkedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		healthResult: VcHostMemberHealthCheckResult;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		switchUuid: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUsbScanCodeSpec
	{
		keyEvents: VcUsbScanCodeSpecKeyEvent[];

		constructor();
	}

	declare class VcUsbScanCodeSpecKeyEvent
	{
		modifiers: VcUsbScanCodeSpecModifierType;
		usbHidCode: Number;

		constructor();
	}

	declare class VcUsbScanCodeSpecModifierType
	{
		leftAlt: boolean;
		leftControl: boolean;
		leftGui: boolean;
		leftShift: boolean;
		rightAlt: boolean;
		rightControl: boolean;
		rightGui: boolean;
		rightShift: boolean;

		constructor();
	}

	declare class VcUserAssignedToGroup
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		group: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userLogin: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcUserDirectory
	{
		domainList: String[];
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		retrieveUserGroups(domain?: String, searchStr?: String, belongsToGroup?: String, belongsToUser?: String, exactMatch?: boolean, findUsers?: boolean, findGroups?: boolean): VcUserSearchResult[];
	}

	declare const VcUserDirectory: VcUserDirectory;

	declare class VcUserGroupProfile
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcUserInputRequiredParameterMetadata
	{
		id: VcExtendedElementDescription;
		parameter: VcProfileParameterMetadata[];
		userInputParameter: VcProfileParameterMetadata[];

		constructor();
	}

	declare class VcUserLoginSessionEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ipAddress: String;
		key: Number;
		locale: String;
		net: VcNetworkEventArgument;
		sessionId: String;
		userAgent: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUserLogoutSessionEvent
	{
		callCount: Number;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		ipAddress: String;
		key: Number;
		loginTime: Date;
		net: VcNetworkEventArgument;
		sessionId: String;
		userAgent: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUserPasswordChanged
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userLogin: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUserProfile
	{
		enabled: boolean;
		key: String;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcUserSearchResult
	{
		fullName: String;
		group: boolean;
		principal: String;

		constructor();
	}

	declare class VcUserSession
	{
		callCount: Number;
		extensionSession: boolean;
		fullName: String;
		ipAddress: String;
		key: String;
		lastActiveTime: Date;
		locale: String;
		loginTime: Date;
		messageLocale: String;
		userAgent: String;
		userName: String;

		constructor();
	}

	declare class VcUserUnassignedFromGroup
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		group: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userLogin: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcUserUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcValidateMigrationTestType
	{
		readonly _compatibilityTests: String;
		readonly _diskAccessibilityTests: String;
		readonly _resourceTests: String;
		readonly _sourceTests: String;
		readonly compatibilityTests: VcValidateMigrationTestType;
		readonly diskAccessibilityTests: VcValidateMigrationTestType;
		readonly id: String;
		readonly name: String;
		readonly resourceTests: VcValidateMigrationTestType;
		readonly sourceTests: VcValidateMigrationTestType;
		readonly value: String;

		fromString(value?: String): VcValidateMigrationTestType;
	}

	interface VcValidateMigrationTestTypeConstructor {
		new(value?:any): VcValidateMigrationTestType;
		readonly prototype: VcValidateMigrationTestType;
	}

	declare const VcValidateMigrationTestType: VcValidateMigrationTestTypeConstructor;

	interface VcVAppAutoStartAction
	{
		readonly _guestShutdown: String;
		readonly _none: String;
		readonly _powerOff: String;
		readonly _powerOn: String;
		readonly _suspend: String;
		readonly guestShutdown: VcVAppAutoStartAction;
		readonly id: String;
		readonly name: String;
		readonly none: VcVAppAutoStartAction;
		readonly powerOff: VcVAppAutoStartAction;
		readonly powerOn: VcVAppAutoStartAction;
		readonly suspend: VcVAppAutoStartAction;
		readonly value: String;

		fromString(value?: String): VcVAppAutoStartAction;
	}

	interface VcVAppAutoStartActionConstructor {
		new(value?:any): VcVAppAutoStartAction;
		readonly prototype: VcVAppAutoStartAction;
	}

	declare const VcVAppAutoStartAction: VcVAppAutoStartActionConstructor;

	declare class VcVAppCloneSpec
	{
		host: VcHostSystem;
		location: VcDatastore;
		networkMapping: VcVAppCloneSpecNetworkMappingPair[];
		property: VcKeyValue[];
		provisioning: String;
		resourceMapping: VcVAppCloneSpecResourceMap[];
		resourceSpec: VcResourceConfigSpec;
		vmFolder: VcFolder;

		constructor();
	}

	declare class VcVAppCloneSpecNetworkMappingPair
	{
		destination: VcNetwork;
		source: VcNetwork;

		constructor();
	}

	interface VcVAppCloneSpecProvisioningType
	{
		readonly _sameAsSource: String;
		readonly _thick: String;
		readonly _thin: String;
		readonly id: String;
		readonly name: String;
		readonly sameAsSource: VcVAppCloneSpecProvisioningType;
		readonly thick: VcVAppCloneSpecProvisioningType;
		readonly thin: VcVAppCloneSpecProvisioningType;
		readonly value: String;

		fromString(value?: String): VcVAppCloneSpecProvisioningType;
	}

	interface VcVAppCloneSpecProvisioningTypeConstructor {
		new(value?:any): VcVAppCloneSpecProvisioningType;
		readonly prototype: VcVAppCloneSpecProvisioningType;
	}

	declare const VcVAppCloneSpecProvisioningType: VcVAppCloneSpecProvisioningTypeConstructor;

	declare class VcVAppCloneSpecResourceMap
	{
		location: VcDatastore;
		parent: VcResourcePool;
		resourceSpec: VcResourceConfigSpec;
		source: VcManagedEntity;

		constructor();
	}

	declare class VcVAppConfigInfo
	{
		annotation: String;
		entityConfig: VcVAppEntityConfigInfo[];
		eula: String[];
		installBootRequired: boolean;
		installBootStopDelay: Number;
		instanceUuid: String;
		ipAssignment: VcVAppIPAssignmentInfo;
		managedBy: VcManagedByInfo;
		ovfEnvironmentTransport: String[];
		ovfSection: VcVAppOvfSectionInfo[];
		product: VcVAppProductInfo[];
		property: VcVAppPropertyInfo[];

		constructor();
	}

	declare class VcVAppConfigSpec
	{
		annotation: String;
		entityConfig: VcVAppEntityConfigInfo[];
		eula: String[];
		installBootRequired: boolean;
		installBootStopDelay: Number;
		instanceUuid: String;
		ipAssignment: VcVAppIPAssignmentInfo;
		managedBy: VcManagedByInfo;
		ovfEnvironmentTransport: String[];
		ovfSection: VcVAppOvfSectionSpec[];
		product: VcVAppProductSpec[];
		property: VcVAppPropertySpec[];

		constructor();
	}

	declare class VcVAppEntityConfigInfo
	{
		destroyWithParent: boolean;
		key: VcManagedEntity;
		startAction: String;
		startDelay: Number;
		startOrder: Number;
		stopAction: String;
		stopDelay: Number;
		tag: String;
		waitingForGuest: boolean;

		constructor();
	}

	declare class VcVAppIPAssignmentInfo
	{
		ipAllocationPolicy: String;
		ipProtocol: String;
		supportedAllocationScheme: String[];
		supportedIpProtocol: String[];

		constructor();
	}

	interface VcVAppIPAssignmentInfoAllocationSchemes
	{
		readonly _dhcp: String;
		readonly _ovfenv: String;
		readonly dhcp: VcVAppIPAssignmentInfoAllocationSchemes;
		readonly id: String;
		readonly name: String;
		readonly ovfenv: VcVAppIPAssignmentInfoAllocationSchemes;
		readonly value: String;

		fromString(value?: String): VcVAppIPAssignmentInfoAllocationSchemes;
	}

	interface VcVAppIPAssignmentInfoAllocationSchemesConstructor {
		new(value?:any): VcVAppIPAssignmentInfoAllocationSchemes;
		readonly prototype: VcVAppIPAssignmentInfoAllocationSchemes;
	}

	declare const VcVAppIPAssignmentInfoAllocationSchemes: VcVAppIPAssignmentInfoAllocationSchemesConstructor;

	interface VcVAppIPAssignmentInfoIpAllocationPolicy
	{
		readonly _dhcpPolicy: String;
		readonly _fixedAllocatedPolicy: String;
		readonly _fixedPolicy: String;
		readonly _transientPolicy: String;
		readonly dhcpPolicy: VcVAppIPAssignmentInfoIpAllocationPolicy;
		readonly fixedAllocatedPolicy: VcVAppIPAssignmentInfoIpAllocationPolicy;
		readonly fixedPolicy: VcVAppIPAssignmentInfoIpAllocationPolicy;
		readonly id: String;
		readonly name: String;
		readonly transientPolicy: VcVAppIPAssignmentInfoIpAllocationPolicy;
		readonly value: String;

		fromString(value?: String): VcVAppIPAssignmentInfoIpAllocationPolicy;
	}

	interface VcVAppIPAssignmentInfoIpAllocationPolicyConstructor {
		new(value?:any): VcVAppIPAssignmentInfoIpAllocationPolicy;
		readonly prototype: VcVAppIPAssignmentInfoIpAllocationPolicy;
	}

	declare const VcVAppIPAssignmentInfoIpAllocationPolicy: VcVAppIPAssignmentInfoIpAllocationPolicyConstructor;

	interface VcVAppIPAssignmentInfoProtocols
	{
		readonly _IPv4: String;
		readonly _IPv6: String;
		readonly id: String;
		readonly IPv4: VcVAppIPAssignmentInfoProtocols;
		readonly IPv6: VcVAppIPAssignmentInfoProtocols;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVAppIPAssignmentInfoProtocols;
	}

	interface VcVAppIPAssignmentInfoProtocolsConstructor {
		new(value?:any): VcVAppIPAssignmentInfoProtocols;
		readonly prototype: VcVAppIPAssignmentInfoProtocols;
	}

	declare const VcVAppIPAssignmentInfoProtocols: VcVAppIPAssignmentInfoProtocolsConstructor;

	declare class VcVAppOvfSectionInfo
	{
		atEnvelopeLevel: boolean;
		contents: String;
		key: Number;
		namespace: String;
		type: String;

		constructor();
	}

	declare class VcVAppOvfSectionSpec
	{
		info: VcVAppOvfSectionInfo;
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcVAppProductInfo
	{
		appUrl: String;
		classId: String;
		fullVersion: String;
		instanceId: String;
		key: Number;
		name: String;
		productUrl: String;
		vendor: String;
		vendorUrl: String;
		version: String;

		constructor();
	}

	declare class VcVAppProductSpec
	{
		info: VcVAppProductInfo;
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcVAppPropertyInfo
	{
		category: String;
		classId: String;
		defaultValue: String;
		description: String;
		id: String;
		instanceId: String;
		key: Number;
		label: String;
		type: String;
		typeReference: String;
		userConfigurable: boolean;
		value: String;

		constructor();
	}

	declare class VcVAppPropertySpec
	{
		info: VcVAppPropertyInfo;
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcVasaProviderContainerSpec
	{
		deleted: boolean;
		scId: String;
		vasaProviderInfo: VcVimVasaProviderInfo[];

		constructor();
	}

	declare class VcVASAStorageArray
	{
		modelId: String;
		name: String;
		uuid: String;
		vendorId: String;

		constructor();
	}

	declare class VcVcAgentUninstalledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVcAgentUninstallFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVcAgentUpgradedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVcAgentUpgradeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcVFlashModuleNotSupportedReason
	{
		readonly _CacheBlockSizeNotSupported: String;
		readonly _CacheConsistencyTypeNotSupported: String;
		readonly _CacheModeNotSupported: String;
		readonly _CacheReservationNotSupported: String;
		readonly _DiskSizeNotSupported: String;
		readonly CacheBlockSizeNotSupported: VcVFlashModuleNotSupportedReason;
		readonly CacheConsistencyTypeNotSupported: VcVFlashModuleNotSupportedReason;
		readonly CacheModeNotSupported: VcVFlashModuleNotSupportedReason;
		readonly CacheReservationNotSupported: VcVFlashModuleNotSupportedReason;
		readonly DiskSizeNotSupported: VcVFlashModuleNotSupportedReason;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVFlashModuleNotSupportedReason;
	}

	interface VcVFlashModuleNotSupportedReasonConstructor {
		new(value?:any): VcVFlashModuleNotSupportedReason;
		readonly prototype: VcVFlashModuleNotSupportedReason;
	}

	declare const VcVFlashModuleNotSupportedReason: VcVFlashModuleNotSupportedReasonConstructor;

	interface VcView
	{

	}

	declare const VcView: VcView;

	interface VcViewManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		viewList: VcView[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createContainerView(container?: VcManagedEntity, type?: String[], recursive?: boolean): VcContainerView;
		createInventoryView(): VcInventoryView;
		createListView(obj?: VcManagedObjectReference[]): VcListView;
		createListViewFromView(view?: VcView): VcListView;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcViewManager: VcViewManager;

	declare class VcVimAccountPasswordChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVimVasaProvider
	{
		name: String;
		selfSignedCertificate: String;
		url: String;

		constructor();
	}

	declare class VcVimVasaProviderInfo
	{
		arrayState: VcVimVasaProviderStatePerArray[];
		provider: VcVimVasaProvider;

		constructor();
	}

	declare class VcVimVasaProviderStatePerArray
	{
		active: boolean;
		arrayId: String;
		priority: Number;

		constructor();
	}

	declare class VcVirtualAHCIController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualAHCIControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSATACdroms: VcIntOption;
		numSATADisks: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
	}

	interface VcVirtualApp
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		childConfiguration: VcResourceConfigSpec[];
		childLink: VcVirtualAppLinkInfo[];
		config: VcResourceConfigSpec;
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		readonly id: String;
		name: String;
		network: VcNetwork[];
		overallStatus: VcManagedEntityStatus;
		owner: VcComputeResource;
		parent: VcManagedEntity;
		parentFolder: VcFolder;
		parentVApp: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		resourcePool: VcResourcePool[];
		readonly resourcePool_ResourcePool: ResourcePool[];
		readonly resourcePool_VirtualApp: VirtualApp[];
		runtime: VcResourcePoolRuntimeInfo;
		readonly sdkConnection: VcSdkConnection;
		summary: VcResourcePoolSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		vAppConfig: VcVAppConfigInfo;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;
		vm: VcVirtualMachine[];

		cloneVApp_Task(name?: String, target?: VcResourcePool, spec?: VcVAppCloneSpec): VcTask;
		createChildVM_Task(config?: VcVirtualMachineConfigSpec, host?: VcHostSystem): VcTask;
		createResourcePool(name?: String, spec?: VcResourceConfigSpec): VcResourcePool;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVApp(name?: String, resSpec?: VcResourceConfigSpec, configSpec?: VcVAppConfigSpec, vmFolder?: VcFolder): VcVirtualApp;
		destroy_Task(): VcTask;
		destroyChildren(): void;
		exportVApp(): VcHttpNfcLease;
		importVApp(spec?: VcImportSpec, folder?: VcFolder, host?: VcHostSystem): VcHttpNfcLease;
		moveIntoResourcePool(list?: VcManagedEntity[]): void;
		powerOffVApp_Task(force?: boolean): VcTask;
		powerOnVApp_Task(): VcTask;
		queryResourceConfigOption(): VcResourceConfigOption;
		refreshRuntime(): void;
		registerChildVM_Task(path?: String, name?: String, host?: VcHostSystem): VcTask;
		reload(): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
		suspendVApp_Task(): VcTask;
		unregisterVApp_Task(): VcTask;
		updateChildResourceConfiguration(spec?: VcResourceConfigSpec[]): void;
		updateConfig(name?: String, config?: VcResourceConfigSpec): void;
		updateLinkedChildren(addChangeSet?: VcVirtualAppLinkInfo[], removeSet?: VcManagedEntity[]): void;
		updateVAppConfig(spec?: VcVAppConfigSpec): void;
	}

	declare const VcVirtualApp: VcVirtualApp;

	declare class VcVirtualAppImportSpec
	{
		child: VcImportSpec[];
		entityConfig: VcVAppEntityConfigInfo;
		instantiationOst: VcOvfConsumerOstNode;
		name: String;
		resourcePoolSpec: VcResourceConfigSpec;
		vAppConfigSpec: VcVAppConfigSpec;

		constructor();
	}

	declare class VcVirtualAppLinkInfo
	{
		destroyWithParent: boolean;
		key: VcManagedEntity;

		constructor();
	}

	declare class VcVirtualAppSummary
	{
		config: VcResourceConfigSpec;
		configuredMemoryMB: Number;
		installBootRequired: boolean;
		instanceUuid: String;
		name: String;
		product: VcVAppProductInfo;
		quickStats: VcResourcePoolQuickStats;
		runtime: VcResourcePoolRuntimeInfo;
		suspended: boolean;
		vAppState: VcVirtualAppVAppState;

		constructor();
	}

	interface VcVirtualAppVAppState
	{
		readonly _started: String;
		readonly _starting: String;
		readonly _stopped: String;
		readonly _stopping: String;
		readonly id: String;
		readonly name: String;
		readonly started: VcVirtualAppVAppState;
		readonly starting: VcVirtualAppVAppState;
		readonly stopped: VcVirtualAppVAppState;
		readonly stopping: VcVirtualAppVAppState;
		readonly value: String;

		fromString(value?: String): VcVirtualAppVAppState;
	}

	interface VcVirtualAppVAppStateConstructor {
		new(value?:any): VcVirtualAppVAppState;
		readonly prototype: VcVirtualAppVAppState;
	}

	declare const VcVirtualAppVAppState: VcVirtualAppVAppStateConstructor;

	declare class VcVirtualBusLogicController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		hotAddRemove: boolean;
		key: Number;
		scsiCtlrUnitNumber: Number;
		sharedBus: VcVirtualSCSISharing;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualBusLogicControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		defaultSharedIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotAddRemove: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSCSICdroms: VcIntOption;
		numSCSIDisks: VcIntOption;
		numSCSIPassthrough: VcIntOption;
		plugAndPlay: boolean;
		scsiCtlrUnitNumber: Number;
		sharing: VcVirtualSCSISharing[];
		supportedDevice: String[];
		type: String;

		constructor();
	}

	declare class VcVirtualCdrom
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualCdromAtapiBackingInfo
	{
		description: String;
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualCdromAtapiBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualCdromIsoBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		fileName: String;

		constructor();
	}

	declare class VcVirtualCdromIsoBackingOption
	{
		fileNameExtensions: VcChoiceOption;
		type: String;

		constructor();
	}

	declare class VcVirtualCdromOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualCdromPassthroughBackingInfo
	{
		description: String;
		deviceName: String;
		exclusive: boolean;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualCdromPassthroughBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		exclusive: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualCdromRemoteAtapiBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualCdromRemoteAtapiBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualCdromRemotePassthroughBackingInfo
	{
		deviceName: String;
		exclusive: boolean;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualCdromRemotePassthroughBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		exclusive: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
	}

	declare class VcVirtualDevice
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualDeviceBackingInfo
	{

		constructor();
	}

	declare class VcVirtualDeviceBackingOption
	{
		type: String;

		constructor();
	}

	declare class VcVirtualDeviceBusSlotInfo
	{

		constructor();
	}

	declare class VcVirtualDeviceBusSlotOption
	{
		type: String;

		constructor();
	}

	declare class VcVirtualDeviceConfigSpec
	{
		device: VcVirtualDevice;
		fileOperation: VcVirtualDeviceConfigSpecFileOperation;
		operation: VcVirtualDeviceConfigSpecOperation;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
	}

	interface VcVirtualDeviceConfigSpecFileOperation
	{
		readonly _create: String;
		readonly _destroy: String;
		readonly _replace: String;
		readonly create: VcVirtualDeviceConfigSpecFileOperation;
		readonly destroy: VcVirtualDeviceConfigSpecFileOperation;
		readonly id: String;
		readonly name: String;
		readonly replace: VcVirtualDeviceConfigSpecFileOperation;
		readonly value: String;

		fromString(value?: String): VcVirtualDeviceConfigSpecFileOperation;
	}

	interface VcVirtualDeviceConfigSpecFileOperationConstructor {
		new(value?:any): VcVirtualDeviceConfigSpecFileOperation;
		readonly prototype: VcVirtualDeviceConfigSpecFileOperation;
	}

	declare const VcVirtualDeviceConfigSpecFileOperation: VcVirtualDeviceConfigSpecFileOperationConstructor;

	interface VcVirtualDeviceConfigSpecOperation
	{
		readonly _add: String;
		readonly _edit: String;
		readonly _remove: String;
		readonly add: VcVirtualDeviceConfigSpecOperation;
		readonly edit: VcVirtualDeviceConfigSpecOperation;
		readonly id: String;
		readonly name: String;
		readonly remove: VcVirtualDeviceConfigSpecOperation;
		readonly value: String;

		fromString(value?: String): VcVirtualDeviceConfigSpecOperation;
	}

	interface VcVirtualDeviceConfigSpecOperationConstructor {
		new(value?:any): VcVirtualDeviceConfigSpecOperation;
		readonly prototype: VcVirtualDeviceConfigSpecOperation;
	}

	declare const VcVirtualDeviceConfigSpecOperation: VcVirtualDeviceConfigSpecOperationConstructor;

	declare class VcVirtualDeviceConnectInfo
	{
		allowGuestControl: boolean;
		connected: boolean;
		startConnected: boolean;
		status: String;

		constructor();
	}

	interface VcVirtualDeviceConnectInfoStatus
	{
		readonly _ok: String;
		readonly _recoverableError: String;
		readonly _unrecoverableError: String;
		readonly _untried: String;
		readonly id: String;
		readonly name: String;
		readonly ok: VcVirtualDeviceConnectInfoStatus;
		readonly recoverableError: VcVirtualDeviceConnectInfoStatus;
		readonly unrecoverableError: VcVirtualDeviceConnectInfoStatus;
		readonly untried: VcVirtualDeviceConnectInfoStatus;
		readonly value: String;

		fromString(value?: String): VcVirtualDeviceConnectInfoStatus;
	}

	interface VcVirtualDeviceConnectInfoStatusConstructor {
		new(value?:any): VcVirtualDeviceConnectInfoStatus;
		readonly prototype: VcVirtualDeviceConnectInfoStatus;
	}

	declare const VcVirtualDeviceConnectInfoStatus: VcVirtualDeviceConnectInfoStatusConstructor;

	declare class VcVirtualDeviceConnectOption
	{
		allowGuestControl: VcBoolOption;
		startConnected: VcBoolOption;

		constructor();
	}

	declare class VcVirtualDeviceDeviceBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualDeviceDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualDeviceFileBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		fileName: String;

		constructor();
	}

	declare class VcVirtualDeviceFileBackingOption
	{
		fileNameExtensions: VcChoiceOption;
		type: String;

		constructor();
	}

	interface VcVirtualDeviceFileExtension
	{
		readonly _dsk: String;
		readonly _flp: String;
		readonly _iso: String;
		readonly _rdm: String;
		readonly _vmdk: String;
		readonly dsk: VcVirtualDeviceFileExtension;
		readonly flp: VcVirtualDeviceFileExtension;
		readonly id: String;
		readonly iso: VcVirtualDeviceFileExtension;
		readonly name: String;
		readonly rdm: VcVirtualDeviceFileExtension;
		readonly value: String;
		readonly vmdk: VcVirtualDeviceFileExtension;

		fromString(value?: String): VcVirtualDeviceFileExtension;
	}

	interface VcVirtualDeviceFileExtensionConstructor {
		new(value?:any): VcVirtualDeviceFileExtension;
		readonly prototype: VcVirtualDeviceFileExtension;
	}

	declare const VcVirtualDeviceFileExtension: VcVirtualDeviceFileExtensionConstructor;

	declare class VcVirtualDeviceOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualDevicePciBusSlotInfo
	{
		pciSlotNumber: Number;

		constructor();
	}

	declare class VcVirtualDevicePipeBackingInfo
	{
		pipeName: String;

		constructor();
	}

	declare class VcVirtualDevicePipeBackingOption
	{
		type: String;

		constructor();
	}

	declare class VcVirtualDeviceRemoteDeviceBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualDeviceRemoteDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualDeviceURIBackingInfo
	{
		direction: String;
		proxyURI: String;
		serviceURI: String;

		constructor();
	}

	declare class VcVirtualDeviceURIBackingOption
	{
		directions: VcChoiceOption;
		type: String;

		constructor();
	}

	interface VcVirtualDeviceURIBackingOptionDirection
	{
		readonly _client: String;
		readonly _server: String;
		readonly client: VcVirtualDeviceURIBackingOptionDirection;
		readonly id: String;
		readonly name: String;
		readonly server: VcVirtualDeviceURIBackingOptionDirection;
		readonly value: String;

		fromString(value?: String): VcVirtualDeviceURIBackingOptionDirection;
	}

	interface VcVirtualDeviceURIBackingOptionDirectionConstructor {
		new(value?:any): VcVirtualDeviceURIBackingOptionDirection;
		readonly prototype: VcVirtualDeviceURIBackingOptionDirection;
	}

	declare const VcVirtualDeviceURIBackingOptionDirection: VcVirtualDeviceURIBackingOptionDirectionConstructor;

	declare class VcVirtualDisk
	{
		backing: VcVirtualDeviceBackingInfo;
		capacityInBytes: Number;
		capacityInKB: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		diskObjectId: String;
		iofilter: String[];
		key: Number;
		shares: VcSharesInfo;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		storageIOAllocation: VcStorageIOAllocationInfo;
		unitNumber: Number;
		vFlashCacheConfigInfo: VcVirtualDiskVFlashCacheConfigInfo;

		constructor();
	}

	interface VcVirtualDiskAdapterType
	{
		readonly _busLogic: String;
		readonly _ide: String;
		readonly _lsiLogic: String;
		readonly busLogic: VcVirtualDiskAdapterType;
		readonly id: String;
		readonly ide: VcVirtualDiskAdapterType;
		readonly lsiLogic: VcVirtualDiskAdapterType;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualDiskAdapterType;
	}

	interface VcVirtualDiskAdapterTypeConstructor {
		new(value?:any): VcVirtualDiskAdapterType;
		readonly prototype: VcVirtualDiskAdapterType;
	}

	declare const VcVirtualDiskAdapterType: VcVirtualDiskAdapterTypeConstructor;

	declare class VcVirtualDiskAntiAffinityRuleSpec
	{
		diskId: Number[];
		enabled: boolean;
		inCompliance: boolean;
		key: Number;
		mandatory: boolean;
		name: String;
		ruleUuid: String;
		status: VcManagedEntityStatus;
		userCreated: boolean;

		constructor();
	}

	interface VcVirtualDiskCompatibilityMode
	{
		readonly _physicalMode: String;
		readonly _virtualMode: String;
		readonly id: String;
		readonly name: String;
		readonly physicalMode: VcVirtualDiskCompatibilityMode;
		readonly value: String;
		readonly virtualMode: VcVirtualDiskCompatibilityMode;

		fromString(value?: String): VcVirtualDiskCompatibilityMode;
	}

	interface VcVirtualDiskCompatibilityModeConstructor {
		new(value?:any): VcVirtualDiskCompatibilityMode;
		readonly prototype: VcVirtualDiskCompatibilityMode;
	}

	declare const VcVirtualDiskCompatibilityMode: VcVirtualDiskCompatibilityModeConstructor;

	declare class VcVirtualDiskConfigSpec
	{
		device: VcVirtualDevice;
		diskMoveType: String;
		fileOperation: VcVirtualDeviceConfigSpecFileOperation;
		migrateCache: boolean;
		operation: VcVirtualDeviceConfigSpecOperation;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
	}

	interface VcVirtualDiskDeltaDiskFormat
	{
		readonly _nativeFormat: String;
		readonly _redoLogFormat: String;
		readonly _seSparseFormat: String;
		readonly id: String;
		readonly name: String;
		readonly nativeFormat: VcVirtualDiskDeltaDiskFormat;
		readonly redoLogFormat: VcVirtualDiskDeltaDiskFormat;
		readonly seSparseFormat: VcVirtualDiskDeltaDiskFormat;
		readonly value: String;

		fromString(value?: String): VcVirtualDiskDeltaDiskFormat;
	}

	interface VcVirtualDiskDeltaDiskFormatConstructor {
		new(value?:any): VcVirtualDiskDeltaDiskFormat;
		readonly prototype: VcVirtualDiskDeltaDiskFormat;
	}

	declare const VcVirtualDiskDeltaDiskFormat: VcVirtualDiskDeltaDiskFormatConstructor;

	declare class VcVirtualDiskDeltaDiskFormatsSupported
	{
		datastoreType: String;
		deltaDiskFormat: VcChoiceOption;

		constructor();
	}

	interface VcVirtualDiskDeltaDiskFormatVariant
	{
		readonly _vmfsSparseVariant: String;
		readonly _vsanSparseVariant: String;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmfsSparseVariant: VcVirtualDiskDeltaDiskFormatVariant;
		readonly vsanSparseVariant: VcVirtualDiskDeltaDiskFormatVariant;

		fromString(value?: String): VcVirtualDiskDeltaDiskFormatVariant;
	}

	interface VcVirtualDiskDeltaDiskFormatVariantConstructor {
		new(value?:any): VcVirtualDiskDeltaDiskFormatVariant;
		readonly prototype: VcVirtualDiskDeltaDiskFormatVariant;
	}

	declare const VcVirtualDiskDeltaDiskFormatVariant: VcVirtualDiskDeltaDiskFormatVariantConstructor;

	declare class VcVirtualDiskFlatVer1BackingInfo
	{
		backingObjectId: String;
		contentId: String;
		datastore: VcDatastore;
		diskMode: String;
		fileName: String;
		parent: VcVirtualDiskFlatVer1BackingInfo;
		split: boolean;
		writeThrough: boolean;

		constructor();
	}

	declare class VcVirtualDiskFlatVer1BackingOption
	{
		diskMode: VcChoiceOption;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		split: VcBoolOption;
		type: String;
		writeThrough: VcBoolOption;

		constructor();
	}

	declare class VcVirtualDiskFlatVer2BackingInfo
	{
		backingObjectId: String;
		changeId: String;
		contentId: String;
		datastore: VcDatastore;
		deltaDiskFormat: String;
		deltaDiskFormatVariant: String;
		deltaGrainSize: Number;
		digestEnabled: boolean;
		diskMode: String;
		eagerlyScrub: boolean;
		fileName: String;
		parent: VcVirtualDiskFlatVer2BackingInfo;
		sharing: String;
		split: boolean;
		thinProvisioned: boolean;
		uuid: String;
		writeThrough: boolean;

		constructor();
	}

	declare class VcVirtualDiskFlatVer2BackingOption
	{
		deltaDiskFormat: VcChoiceOption;
		deltaDiskFormatsSupported: VcVirtualDiskDeltaDiskFormatsSupported[];
		diskMode: VcChoiceOption;
		eagerlyScrub: VcBoolOption;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		hotGrowable: boolean;
		split: VcBoolOption;
		thinProvisioned: VcBoolOption;
		type: String;
		uuid: boolean;
		writeThrough: VcBoolOption;

		constructor();
	}

	declare class VcVirtualDiskId
	{
		diskId: Number;
		vm: VcVirtualMachine;

		constructor();
	}

	interface VcVirtualDiskManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		copyVirtualDisk_Task(sourceName?: String, sourceDatacenter?: VcDatacenter, destName?: String, destDatacenter?: VcDatacenter, destSpec?: VcVirtualDiskSpec, force?: boolean): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVirtualDisk_Task(name?: String, datacenter?: VcDatacenter, spec?: VcVirtualDiskSpec): VcTask;
		defragmentVirtualDisk_Task(name?: String, datacenter?: VcDatacenter): VcTask;
		deleteVirtualDisk_Task(name?: String, datacenter?: VcDatacenter): VcTask;
		eagerZeroVirtualDisk_Task(name?: String, datacenter?: VcDatacenter): VcTask;
		extendVirtualDisk_Task(name?: String, datacenter?: VcDatacenter, newCapacityKb?: Number, eagerZero?: boolean): VcTask;
		importUnmanagedSnapshot(vdisk?: String, datacenter?: VcDatacenter, vvolId?: String): void;
		inflateVirtualDisk_Task(name?: String, datacenter?: VcDatacenter): VcTask;
		moveVirtualDisk_Task(sourceName?: String, sourceDatacenter?: VcDatacenter, destName?: String, destDatacenter?: VcDatacenter, force?: boolean, profile?: VcVirtualMachineProfileSpec[]): VcTask;
		queryVirtualDiskFragmentation(name?: String, datacenter?: VcDatacenter): Number;
		queryVirtualDiskGeometry(name?: String, datacenter?: VcDatacenter): VcHostDiskDimensionsChs;
		queryVirtualDiskUuid(name?: String, datacenter?: VcDatacenter): String;
		setVirtualDiskUuid(name?: String, datacenter?: VcDatacenter, uuid?: String): void;
		shrinkVirtualDisk_Task(name?: String, datacenter?: VcDatacenter, copy?: boolean): VcTask;
		zeroFillVirtualDisk_Task(name?: String, datacenter?: VcDatacenter): VcTask;
	}

	declare const VcVirtualDiskManager: VcVirtualDiskManager;

	interface VcVirtualDiskMode
	{
		readonly _append: String;
		readonly _independent_nonpersistent: String;
		readonly _independent_persistent: String;
		readonly _nonpersistent: String;
		readonly _persistent: String;
		readonly _undoable: String;
		readonly append: VcVirtualDiskMode;
		readonly id: String;
		readonly independent_nonpersistent: VcVirtualDiskMode;
		readonly independent_persistent: VcVirtualDiskMode;
		readonly name: String;
		readonly nonpersistent: VcVirtualDiskMode;
		readonly persistent: VcVirtualDiskMode;
		readonly undoable: VcVirtualDiskMode;
		readonly value: String;

		fromString(value?: String): VcVirtualDiskMode;
	}

	interface VcVirtualDiskModeConstructor {
		new(value?:any): VcVirtualDiskMode;
		readonly prototype: VcVirtualDiskMode;
	}

	declare const VcVirtualDiskMode: VcVirtualDiskModeConstructor;

	declare class VcVirtualDiskOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		capacityInKB: VcLongOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		ioAllocationOption: VcStorageIOAllocationOption;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;
		vFlashCacheConfigOption: VcVirtualDiskOptionVFlashCacheConfigOption;

		constructor();
	}

	declare class VcVirtualDiskOptionVFlashCacheConfigOption
	{
		blockSizeInKB: VcLongOption;
		cacheConsistencyType: VcChoiceOption;
		cacheMode: VcChoiceOption;
		reservationInMB: VcLongOption;

		constructor();
	}

	declare class VcVirtualDiskPartitionedRawDiskVer2BackingInfo
	{
		changeId: String;
		descriptorFileName: String;
		deviceName: String;
		partition: Number[];
		sharing: String;
		useAutoDetect: boolean;
		uuid: String;

		constructor();
	}

	declare class VcVirtualDiskPartitionedRawDiskVer2BackingOption
	{
		autoDetectAvailable: VcBoolOption;
		descriptorFileNameExtensions: VcChoiceOption;
		type: String;
		uuid: boolean;

		constructor();
	}

	declare class VcVirtualDiskRawDiskMappingVer1BackingInfo
	{
		backingObjectId: String;
		changeId: String;
		compatibilityMode: String;
		contentId: String;
		datastore: VcDatastore;
		deltaDiskFormat: String;
		deltaGrainSize: Number;
		deviceName: String;
		diskMode: String;
		fileName: String;
		lunUuid: String;
		parent: VcVirtualDiskRawDiskMappingVer1BackingInfo;
		sharing: String;
		uuid: String;

		constructor();
	}

	declare class VcVirtualDiskRawDiskMappingVer1BackingOption
	{
		autoDetectAvailable: VcBoolOption;
		compatibilityMode: VcChoiceOption;
		descriptorFileNameExtensions: VcChoiceOption;
		diskMode: VcChoiceOption;
		type: String;
		uuid: boolean;

		constructor();
	}

	declare class VcVirtualDiskRawDiskVer2BackingInfo
	{
		changeId: String;
		descriptorFileName: String;
		deviceName: String;
		sharing: String;
		useAutoDetect: boolean;
		uuid: String;

		constructor();
	}

	declare class VcVirtualDiskRawDiskVer2BackingOption
	{
		autoDetectAvailable: VcBoolOption;
		descriptorFileNameExtensions: VcChoiceOption;
		type: String;
		uuid: boolean;

		constructor();
	}

	declare class VcVirtualDiskSeSparseBackingInfo
	{
		backingObjectId: String;
		changeId: String;
		contentId: String;
		datastore: VcDatastore;
		deltaDiskFormat: String;
		digestEnabled: boolean;
		diskMode: String;
		fileName: String;
		grainSize: Number;
		parent: VcVirtualDiskSeSparseBackingInfo;
		uuid: String;
		writeThrough: boolean;

		constructor();
	}

	declare class VcVirtualDiskSeSparseBackingOption
	{
		deltaDiskFormatsSupported: VcVirtualDiskDeltaDiskFormatsSupported[];
		diskMode: VcChoiceOption;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		hotGrowable: boolean;
		type: String;
		uuid: boolean;
		writeThrough: VcBoolOption;

		constructor();
	}

	interface VcVirtualDiskSharing
	{
		readonly _sharingMultiWriter: String;
		readonly _sharingNone: String;
		readonly id: String;
		readonly name: String;
		readonly sharingMultiWriter: VcVirtualDiskSharing;
		readonly sharingNone: VcVirtualDiskSharing;
		readonly value: String;

		fromString(value?: String): VcVirtualDiskSharing;
	}

	interface VcVirtualDiskSharingConstructor {
		new(value?:any): VcVirtualDiskSharing;
		readonly prototype: VcVirtualDiskSharing;
	}

	declare const VcVirtualDiskSharing: VcVirtualDiskSharingConstructor;

	declare class VcVirtualDiskSparseVer1BackingInfo
	{
		backingObjectId: String;
		contentId: String;
		datastore: VcDatastore;
		diskMode: String;
		fileName: String;
		parent: VcVirtualDiskSparseVer1BackingInfo;
		spaceUsedInKB: Number;
		split: boolean;
		writeThrough: boolean;

		constructor();
	}

	declare class VcVirtualDiskSparseVer1BackingOption
	{
		diskModes: VcChoiceOption;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		split: VcBoolOption;
		type: String;
		writeThrough: VcBoolOption;

		constructor();
	}

	declare class VcVirtualDiskSparseVer2BackingInfo
	{
		backingObjectId: String;
		changeId: String;
		contentId: String;
		datastore: VcDatastore;
		diskMode: String;
		fileName: String;
		parent: VcVirtualDiskSparseVer2BackingInfo;
		spaceUsedInKB: Number;
		split: boolean;
		uuid: String;
		writeThrough: boolean;

		constructor();
	}

	declare class VcVirtualDiskSparseVer2BackingOption
	{
		diskMode: VcChoiceOption;
		fileNameExtensions: VcChoiceOption;
		growable: boolean;
		hotGrowable: boolean;
		split: VcBoolOption;
		type: String;
		uuid: boolean;
		writeThrough: VcBoolOption;

		constructor();
	}

	declare class VcVirtualDiskSpec
	{
		adapterType: String;
		diskType: String;

		constructor();
	}

	interface VcVirtualDiskType
	{
		readonly _delta: String;
		readonly _eagerZeroedThick: String;
		readonly _flatMonolithic: String;
		readonly _preallocated: String;
		readonly _raw: String;
		readonly _rdm: String;
		readonly _rdmp: String;
		readonly _seSparse: String;
		readonly _sparse2Gb: String;
		readonly _sparseMonolithic: String;
		readonly _thick: String;
		readonly _thick2Gb: String;
		readonly _thin: String;
		readonly delta: VcVirtualDiskType;
		readonly eagerZeroedThick: VcVirtualDiskType;
		readonly flatMonolithic: VcVirtualDiskType;
		readonly id: String;
		readonly name: String;
		readonly preallocated: VcVirtualDiskType;
		readonly raw: VcVirtualDiskType;
		readonly rdm: VcVirtualDiskType;
		readonly rdmp: VcVirtualDiskType;
		readonly seSparse: VcVirtualDiskType;
		readonly sparse2Gb: VcVirtualDiskType;
		readonly sparseMonolithic: VcVirtualDiskType;
		readonly thick: VcVirtualDiskType;
		readonly thick2Gb: VcVirtualDiskType;
		readonly thin: VcVirtualDiskType;
		readonly value: String;

		fromString(value?: String): VcVirtualDiskType;
	}

	interface VcVirtualDiskTypeConstructor {
		new(value?:any): VcVirtualDiskType;
		readonly prototype: VcVirtualDiskType;
	}

	declare const VcVirtualDiskType: VcVirtualDiskTypeConstructor;

	declare class VcVirtualDiskVFlashCacheConfigInfo
	{
		blockSizeInKB: Number;
		cacheConsistencyType: String;
		cacheMode: String;
		reservationInMB: Number;
		vFlashModule: String;

		constructor();
	}

	interface VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType
	{
		readonly _strong: String;
		readonly _weak: String;
		readonly id: String;
		readonly name: String;
		readonly strong: VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType;
		readonly value: String;
		readonly weak: VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType;

		fromString(value?: String): VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType;
	}

	interface VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyTypeConstructor {
		new(value?:any): VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType;
		readonly prototype: VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType;
	}

	declare const VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType: VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyTypeConstructor;

	interface VcVirtualDiskVFlashCacheConfigInfoCacheMode
	{
		readonly _write_back: String;
		readonly _write_thru: String;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly write_back: VcVirtualDiskVFlashCacheConfigInfoCacheMode;
		readonly write_thru: VcVirtualDiskVFlashCacheConfigInfoCacheMode;

		fromString(value?: String): VcVirtualDiskVFlashCacheConfigInfoCacheMode;
	}

	interface VcVirtualDiskVFlashCacheConfigInfoCacheModeConstructor {
		new(value?:any): VcVirtualDiskVFlashCacheConfigInfoCacheMode;
		readonly prototype: VcVirtualDiskVFlashCacheConfigInfoCacheMode;
	}

	declare const VcVirtualDiskVFlashCacheConfigInfoCacheMode: VcVirtualDiskVFlashCacheConfigInfoCacheModeConstructor;

	declare class VcVirtualE1000
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
	}

	declare class VcVirtualE1000e
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
	}

	declare class VcVirtualE1000eOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
	}

	declare class VcVirtualE1000Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
	}

	declare class VcVirtualEnsoniq1371
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualEnsoniq1371Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualEthernetCard
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
	}

	declare class VcVirtualEthernetCardDistributedVirtualPortBackingInfo
	{
		port: VcDistributedVirtualSwitchPortConnection;

		constructor();
	}

	declare class VcVirtualEthernetCardDVPortBackingOption
	{
		type: String;

		constructor();
	}

	declare class VcVirtualEthernetCardLegacyNetworkBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualEthernetCardLegacyNetworkBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	interface VcVirtualEthernetCardLegacyNetworkDeviceName
	{
		readonly _bridged: String;
		readonly _hostonly: String;
		readonly _nat: String;
		readonly bridged: VcVirtualEthernetCardLegacyNetworkDeviceName;
		readonly hostonly: VcVirtualEthernetCardLegacyNetworkDeviceName;
		readonly id: String;
		readonly name: String;
		readonly nat: VcVirtualEthernetCardLegacyNetworkDeviceName;
		readonly value: String;

		fromString(value?: String): VcVirtualEthernetCardLegacyNetworkDeviceName;
	}

	interface VcVirtualEthernetCardLegacyNetworkDeviceNameConstructor {
		new(value?:any): VcVirtualEthernetCardLegacyNetworkDeviceName;
		readonly prototype: VcVirtualEthernetCardLegacyNetworkDeviceName;
	}

	declare const VcVirtualEthernetCardLegacyNetworkDeviceName: VcVirtualEthernetCardLegacyNetworkDeviceNameConstructor;

	interface VcVirtualEthernetCardMacType
	{
		readonly _assigned: String;
		readonly _generated: String;
		readonly _manual: String;
		readonly assigned: VcVirtualEthernetCardMacType;
		readonly generated: VcVirtualEthernetCardMacType;
		readonly id: String;
		readonly manual: VcVirtualEthernetCardMacType;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualEthernetCardMacType;
	}

	interface VcVirtualEthernetCardMacTypeConstructor {
		new(value?:any): VcVirtualEthernetCardMacType;
		readonly prototype: VcVirtualEthernetCardMacType;
	}

	declare const VcVirtualEthernetCardMacType: VcVirtualEthernetCardMacTypeConstructor;

	declare class VcVirtualEthernetCardNetworkBackingInfo
	{
		deviceName: String;
		inPassthroughMode: boolean;
		network: VcNetwork;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualEthernetCardNetworkBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualEthernetCardOpaqueNetworkBackingInfo
	{
		opaqueNetworkId: String;
		opaqueNetworkType: String;

		constructor();
	}

	declare class VcVirtualEthernetCardOpaqueNetworkBackingOption
	{
		type: String;

		constructor();
	}

	declare class VcVirtualEthernetCardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
	}

	declare class VcVirtualEthernetCardResourceAllocation
	{
		limit: Number;
		reservation: Number;
		share: VcSharesInfo;

		constructor();
	}

	declare class VcVirtualFloppy
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualFloppyDeviceBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualFloppyDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualFloppyImageBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		fileName: String;

		constructor();
	}

	declare class VcVirtualFloppyImageBackingOption
	{
		fileNameExtensions: VcChoiceOption;
		type: String;

		constructor();
	}

	declare class VcVirtualFloppyOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualFloppyRemoteDeviceBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualFloppyRemoteDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualHardware
	{
		device: VcVirtualDevice[];
		memoryMB: Number;
		numCoresPerSocket: Number;
		numCPU: Number;
		virtualICH7MPresent: boolean;
		virtualSMCPresent: boolean;

		constructor();
	}

	declare class VcVirtualHardwareOption
	{
		deviceListReadonly: boolean;
		hwVersion: Number;
		licensingLimit: String[];
		memoryMB: VcLongOption;
		numCoresPerSocket: VcIntOption;
		numCPU: Number[];
		numCpuReadonly: boolean;
		numIDEControllers: VcIntOption;
		numPCIControllers: VcIntOption;
		numPS2Controllers: VcIntOption;
		numSIOControllers: VcIntOption;
		numSupportedWwnNodes: VcIntOption;
		numSupportedWwnPorts: VcIntOption;
		numUSBControllers: VcIntOption;
		numUSBXHCIControllers: VcIntOption;
		resourceConfigOption: VcResourceConfigOption;
		virtualDeviceOption: VcVirtualDeviceOption[];

		constructor();
	}

	declare class VcVirtualHdAudioCard
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualHdAudioCardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualIDEController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualIDEControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numIDECdroms: VcIntOption;
		numIDEDisks: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
	}

	interface VcVirtualizationManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcVirtualizationManager: VcVirtualizationManager;

	declare class VcVirtualKeyboard
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualKeyboardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualLsiLogicController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		hotAddRemove: boolean;
		key: Number;
		scsiCtlrUnitNumber: Number;
		sharedBus: VcVirtualSCSISharing;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualLsiLogicControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		defaultSharedIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotAddRemove: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSCSICdroms: VcIntOption;
		numSCSIDisks: VcIntOption;
		numSCSIPassthrough: VcIntOption;
		plugAndPlay: boolean;
		scsiCtlrUnitNumber: Number;
		sharing: VcVirtualSCSISharing[];
		supportedDevice: String[];
		type: String;

		constructor();
	}

	declare class VcVirtualLsiLogicSASController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		hotAddRemove: boolean;
		key: Number;
		scsiCtlrUnitNumber: Number;
		sharedBus: VcVirtualSCSISharing;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualLsiLogicSASControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		defaultSharedIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotAddRemove: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSCSICdroms: VcIntOption;
		numSCSIDisks: VcIntOption;
		numSCSIPassthrough: VcIntOption;
		plugAndPlay: boolean;
		scsiCtlrUnitNumber: Number;
		sharing: VcVirtualSCSISharing[];
		supportedDevice: String[];
		type: String;

		constructor();
	}

	interface VcVirtualMachine
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		capability: VcVirtualMachineCapability;
		config: VcVirtualMachineConfigInfo;
		configIssue: VcEvent[];
		configLocked: boolean;
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		datastore: VcDatastore[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		environmentBrowser: VcEnvironmentBrowser;
		guest: VcGuestInfo;
		guestHeartbeatStatus: VcManagedEntityStatus;
		guestInstallManager: VcCustomizationGuestInstallManager;
		readonly id: String;
		layout: VcVirtualMachineFileLayout;
		layoutEx: VcVirtualMachineFileLayoutEx;
		name: String;
		network: VcNetwork[];
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		parentVApp: VcManagedEntity;
		permission: VcPermission[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		resourceConfig: VcResourceConfigSpec;
		resourcePool: VcResourcePool;
		rootSnapshot: VcVirtualMachineSnapshot[];
		runtime: VcVirtualMachineRuntimeInfo;
		readonly sdkConnection: VcSdkConnection;
		snapshot: VcVirtualMachineSnapshotInfo;
		storage: VcVirtualMachineStorageInfo;
		summary: VcVirtualMachineSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		acquireMksTicket(): VcVirtualMachineMksTicket;
		acquireTicket(ticketType?: String): VcVirtualMachineTicket;
		answerVM(questionId?: String, answerChoice?: String): void;
		checkCustomizationSpec(spec?: VcCustomizationSpec): void;
		cloneVM_Task(folder?: VcFolder, name?: String, spec?: VcVirtualMachineCloneSpec): VcTask;
		consolidateVMDisks_Task(): VcTask;
		createScreenshot_Task(): VcTask;
		createSecondaryVM_Task(host?: VcHostSystem): VcTask;
		createSecondaryVMEx_Task(host?: VcHostSystem, spec?: VcFaultToleranceConfigSpec): VcTask;
		createSnapshot_Task(name?: String, description?: String, memory?: boolean, quiesce?: boolean): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		customizeVM_Task(spec?: VcCustomizationSpec): VcTask;
		defragmentAllDisks(): void;
		destroy_Task(): VcTask;
		disableSecondaryVM_Task(vm?: VcVirtualMachine): VcTask;
		enableSecondaryVM_Task(vm?: VcVirtualMachine, host?: VcHostSystem): VcTask;
		estimateStorageForConsolidateSnapshots_Task(): VcTask;
		exportVm(): VcHttpNfcLease;
		extractOvfEnvironment(): String;
		makePrimaryVM_Task(vm?: VcVirtualMachine): VcTask;
		markAsTemplate(): void;
		markAsVirtualMachine(pool?: VcResourcePool, host?: VcHostSystem): void;
		migrateVM_Task(pool?: VcResourcePool, host?: VcHostSystem, priority?: VcVirtualMachineMovePriority, state?: VcVirtualMachinePowerState): VcTask;
		mountToolsInstaller(): void;
		mountToolsInstallerImage(isoImage?: VcVirtualDeviceBackingInfo, auth?: VcGuestAuthentication): void;
		powerOffVM_Task(): VcTask;
		powerOnVM_Task(host?: VcHostSystem): VcTask;
		promoteDisks_Task(unlink?: boolean, disks?: VcVirtualDisk[]): VcTask;
		putUsbScanCodes(spec?: VcUsbScanCodeSpec): Number;
		queryChangedDiskAreas(snapshot?: VcVirtualMachineSnapshot, deviceKey?: Number, startOffset?: Number, changeId?: String): VcDiskChangeInfo;
		queryFaultToleranceCompatibility(): VcMethodFault[];
		queryFaultToleranceCompatibilityEx(forLegacyFt?: boolean): VcMethodFault[];
		queryUnownedFiles(): String[];
		queryVRMPolicy(key?: String): VcVRMPolicyInfo;
		rebootGuest(): void;
		reconfigVM_Task(spec?: VcVirtualMachineConfigSpec): VcTask;
		refreshStorageInfo(): void;
		reload(): void;
		reloadVirtualMachineFromPath_Task(configurationPath?: String): VcTask;
		relocateVM_Task(spec?: VcVirtualMachineRelocateSpec, priority?: VcVirtualMachineMovePriority): VcTask;
		removeAllSnapshots_Task(consolidate?: boolean): VcTask;
		rename_Task(newName?: String): VcTask;
		resetGuestInformation(): void;
		resetVM_Task(): VcTask;
		revertToCurrentSnapshot_Task(host?: VcHostSystem, suppressPowerOn?: boolean): VcTask;
		sendNMI(): void;
		setCustomValue(key?: String, value?: String): void;
		setDisplayTopology(displays?: VcVirtualMachineDisplayTopology[]): void;
		setDisplayTopologyModes(monitorIndex?: Number, mode?: VcGuestScreenInfo[]): void;
		setScreenResolution(width?: Number, height?: Number): void;
		shutdownGuest(): void;
		standbyGuest(): void;
		startRecording_Task(name?: String, description?: String): VcTask;
		startReplaying_Task(replaySnapshot?: VcVirtualMachineSnapshot): VcTask;
		stopRecording_Task(): VcTask;
		stopReplaying_Task(): VcTask;
		suspendVM_Task(): VcTask;
		terminateFaultTolerantVM_Task(vm?: VcVirtualMachine): VcTask;
		terminateVM(): void;
		turnOffFaultToleranceForVM_Task(): VcTask;
		unlockVM(key?: String): void;
		unmountToolsInstaller(): void;
		unregisterVM(): void;
		updateVRMPolicy(key?: String, vrmPolicy?: VcVRMPolicyInfo): void;
		upgradeTools_Task(installerOptions?: String): VcTask;
		upgradeToolsFromImage_Task(installerOptions?: String, isoImage?: VcVirtualDeviceBackingInfo, auth?: VcGuestAuthentication): VcTask;
		upgradeVM_Task(version?: String): VcTask;
	}

	declare const VcVirtualMachine: VcVirtualMachine;

	declare class VcVirtualMachineAffinityInfo
	{
		affinitySet: Number[];

		constructor();
	}

	interface VcVirtualMachineAppHeartbeatStatusType
	{
		readonly _appStatusGray: String;
		readonly _appStatusGreen: String;
		readonly _appStatusRed: String;
		readonly appStatusGray: VcVirtualMachineAppHeartbeatStatusType;
		readonly appStatusGreen: VcVirtualMachineAppHeartbeatStatusType;
		readonly appStatusRed: VcVirtualMachineAppHeartbeatStatusType;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineAppHeartbeatStatusType;
	}

	interface VcVirtualMachineAppHeartbeatStatusTypeConstructor {
		new(value?:any): VcVirtualMachineAppHeartbeatStatusType;
		readonly prototype: VcVirtualMachineAppHeartbeatStatusType;
	}

	declare const VcVirtualMachineAppHeartbeatStatusType: VcVirtualMachineAppHeartbeatStatusTypeConstructor;

	declare class VcVirtualMachineBootOptions
	{
		bootDelay: Number;
		bootOrder: VcVirtualMachineBootOptionsBootableDevice[];
		bootRetryDelay: Number;
		bootRetryEnabled: boolean;
		enterBIOSSetup: boolean;
		networkBootProtocol: String;

		constructor();
	}

	declare class VcVirtualMachineBootOptionsBootableCdromDevice
	{

		constructor();
	}

	declare class VcVirtualMachineBootOptionsBootableDevice
	{

		constructor();
	}

	declare class VcVirtualMachineBootOptionsBootableDiskDevice
	{
		deviceKey: Number;

		constructor();
	}

	declare class VcVirtualMachineBootOptionsBootableEthernetDevice
	{
		deviceKey: Number;

		constructor();
	}

	declare class VcVirtualMachineBootOptionsBootableFloppyDevice
	{

		constructor();
	}

	interface VcVirtualMachineBootOptionsNetworkBootProtocolType
	{
		readonly _ipv4: String;
		readonly _ipv6: String;
		readonly id: String;
		readonly ipv4: VcVirtualMachineBootOptionsNetworkBootProtocolType;
		readonly ipv6: VcVirtualMachineBootOptionsNetworkBootProtocolType;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineBootOptionsNetworkBootProtocolType;
	}

	interface VcVirtualMachineBootOptionsNetworkBootProtocolTypeConstructor {
		new(value?:any): VcVirtualMachineBootOptionsNetworkBootProtocolType;
		readonly prototype: VcVirtualMachineBootOptionsNetworkBootProtocolType;
	}

	declare const VcVirtualMachineBootOptionsNetworkBootProtocolType: VcVirtualMachineBootOptionsNetworkBootProtocolTypeConstructor;

	declare class VcVirtualMachineCapability
	{
		bootOptionsSupported: boolean;
		bootRetryOptionsSupported: boolean;
		canConnectUSBDevices: boolean;
		changeTrackingSupported: boolean;
		consolePreferencesSupported: boolean;
		cpuFeatureMaskSupported: boolean;
		disableSnapshotsSupported: boolean;
		diskSharesSupported: boolean;
		featureRequirementSupported: boolean;
		guestAutoLockSupported: boolean;
		hostBasedReplicationSupported: boolean;
		lockSnapshotsSupported: boolean;
		memoryReservationLockSupported: boolean;
		memorySnapshotsSupported: boolean;
		messageBusSupported: boolean;
		multipleCoresPerSocketSupported: boolean;
		multipleSnapshotsSupported: boolean;
		nestedHVSupported: boolean;
		npivWwnOnNonRdmVmSupported: boolean;
		poweredOffSnapshotsSupported: boolean;
		poweredOnMonitorTypeChangeSupported: boolean;
		quiescedSnapshotsSupported: boolean;
		recordReplaySupported: boolean;
		revertToSnapshotSupported: boolean;
		s1AcpiManagementSupported: boolean;
		seSparseDiskSupported: boolean;
		settingDisplayTopologyModesSupported: boolean;
		settingDisplayTopologySupported: boolean;
		settingScreenResolutionSupported: boolean;
		settingVideoRamSizeSupported: boolean;
		snapshotConfigSupported: boolean;
		snapshotOperationsSupported: boolean;
		swapPlacementSupported: boolean;
		swapPreservationSupported: boolean;
		toolsAutoUpdateSupported: boolean;
		toolsRebootPredictSupported: boolean;
		toolsSyncTimeSupported: boolean;
		virtualMmuUsageSupported: boolean;
		vmfsNativeSnapshotSupported: boolean;
		vmNpivWwnDisableSupported: boolean;
		vmNpivWwnSupported: boolean;
		vmNpivWwnUpdateSupported: boolean;
		vPMCSupported: boolean;

		constructor();
	}

	declare class VcVirtualMachineCdromInfo
	{
		configurationTag: String[];
		description: String;
		name: String;

		constructor();
	}

	declare class VcVirtualMachineCloneSpec
	{
		config: VcVirtualMachineConfigSpec;
		customization: VcCustomizationSpec;
		location: VcVirtualMachineRelocateSpec;
		memory: boolean;
		powerOn: boolean;
		snapshot: VcVirtualMachineSnapshot;
		template: boolean;

		constructor();
	}

	interface VcVirtualMachineCompatibilityChecker
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		checkCompatibility_Task(vm?: VcVirtualMachine, host?: VcHostSystem, pool?: VcResourcePool, testType?: String[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
	}

	declare const VcVirtualMachineCompatibilityChecker: VcVirtualMachineCompatibilityChecker;

	declare class VcVirtualMachineConfigInfo
	{
		alternateGuestName: String;
		annotation: String;
		bootOptions: VcVirtualMachineBootOptions;
		changeTrackingEnabled: boolean;
		changeVersion: String;
		consolePreferences: VcVirtualMachineConsolePreferences;
		cpuAffinity: VcVirtualMachineAffinityInfo;
		cpuAllocation: VcResourceAllocationInfo;
		cpuFeatureMask: VcHostCpuIdInfo[];
		cpuHotAddEnabled: boolean;
		cpuHotRemoveEnabled: boolean;
		datastoreUrl: VcVirtualMachineConfigInfoDatastoreUrlPair[];
		defaultPowerOps: VcVirtualMachineDefaultPowerOpInfo;
		extraConfig: VcOptionValue[];
		files: VcVirtualMachineFileInfo;
		firmware: String;
		flags: VcVirtualMachineFlagInfo;
		forkConfigInfo: VcVirtualMachineForkConfigInfo;
		ftInfo: VcFaultToleranceConfigInfo;
		guestAutoLockEnabled: boolean;
		guestFullName: String;
		guestId: String;
		hardware: VcVirtualHardware;
		hotPlugMemoryIncrementSize: Number;
		hotPlugMemoryLimit: Number;
		initialOverhead: VcVirtualMachineConfigInfoOverheadInfo;
		instanceUuid: String;
		latencySensitivity: VcLatencySensitivity;
		locationId: String;
		managedBy: VcManagedByInfo;
		maxMksConnections: Number;
		memoryAffinity: VcVirtualMachineAffinityInfo;
		memoryAllocation: VcResourceAllocationInfo;
		memoryHotAddEnabled: boolean;
		memoryReservationLockedToMax: boolean;
		messageBusQueuePattern: String;
		messageBusTunnelEnabled: boolean;
		modified: Date;
		name: String;
		nestedHVEnabled: boolean;
		networkShaper: VcVirtualMachineNetworkShaperInfo;
		npivDesiredNodeWwns: Number;
		npivDesiredPortWwns: Number;
		npivNodeWorldWideName: Number[];
		npivOnNonRdmDisks: boolean;
		npivPortWorldWideName: Number[];
		npivTemporaryDisabled: boolean;
		npivWorldWideNameType: String;
		preserveSwapOnPowerOff: boolean;
		repConfig: VcReplicationConfigSpec;
		scheduledHardwareUpgradeInfo: VcScheduledHardwareUpgradeInfo;
		swapDirectory: String;
		swapPlacement: String;
		swapStorageObjectId: String;
		template: boolean;
		tools: VcToolsConfigInfo;
		uuid: String;
		vAppConfig: VcVmConfigInfo;
		vAssertsEnabled: boolean;
		version: String;
		vFlashCacheReservation: Number;
		vmStorageObjectId: String;
		vmxConfigChecksum: base64Binary;
		vPMCEnabled: boolean;

		constructor();
	}

	declare class VcVirtualMachineConfigInfoDatastoreUrlPair
	{
		name: String;
		url: String;

		constructor();
	}

	interface VcVirtualMachineConfigInfoNpivWwnType
	{
		readonly _external: String;
		readonly _host: String;
		readonly _vc: String;
		readonly external: VcVirtualMachineConfigInfoNpivWwnType;
		readonly host: VcVirtualMachineConfigInfoNpivWwnType;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vc: VcVirtualMachineConfigInfoNpivWwnType;

		fromString(value?: String): VcVirtualMachineConfigInfoNpivWwnType;
	}

	interface VcVirtualMachineConfigInfoNpivWwnTypeConstructor {
		new(value?:any): VcVirtualMachineConfigInfoNpivWwnType;
		readonly prototype: VcVirtualMachineConfigInfoNpivWwnType;
	}

	declare const VcVirtualMachineConfigInfoNpivWwnType: VcVirtualMachineConfigInfoNpivWwnTypeConstructor;

	declare class VcVirtualMachineConfigInfoOverheadInfo
	{
		initialMemoryReservation: Number;
		initialSwapReservation: Number;

		constructor();
	}

	interface VcVirtualMachineConfigInfoSwapPlacementType
	{
		readonly _hostLocal: String;
		readonly _inherit: String;
		readonly _vmConfigured: String;
		readonly _vmDirectory: String;
		readonly hostLocal: VcVirtualMachineConfigInfoSwapPlacementType;
		readonly id: String;
		readonly inherit: VcVirtualMachineConfigInfoSwapPlacementType;
		readonly name: String;
		readonly value: String;
		readonly vmConfigured: VcVirtualMachineConfigInfoSwapPlacementType;
		readonly vmDirectory: VcVirtualMachineConfigInfoSwapPlacementType;

		fromString(value?: String): VcVirtualMachineConfigInfoSwapPlacementType;
	}

	interface VcVirtualMachineConfigInfoSwapPlacementTypeConstructor {
		new(value?:any): VcVirtualMachineConfigInfoSwapPlacementType;
		readonly prototype: VcVirtualMachineConfigInfoSwapPlacementType;
	}

	declare const VcVirtualMachineConfigInfoSwapPlacementType: VcVirtualMachineConfigInfoSwapPlacementTypeConstructor;

	declare class VcVirtualMachineConfigOption
	{
		capabilities: VcVirtualMachineCapability;
		datastore: VcDatastoreOption;
		defaultDevice: VcVirtualDevice[];
		description: String;
		guestOSDefaultIndex: Number;
		guestOSDescriptor: VcGuestOsDescriptor[];
		hardwareOptions: VcVirtualHardwareOption;
		supportedMonitorType: String[];
		supportedOvfEnvironmentTransport: String[];
		supportedOvfInstallTransport: String[];
		version: String;

		constructor();
	}

	declare class VcVirtualMachineConfigOptionDescriptor
	{
		createSupported: boolean;
		defaultConfigOption: boolean;
		description: String;
		host: VcHostSystem[];
		key: String;
		runSupported: boolean;
		upgradeSupported: boolean;

		constructor();
	}

	declare class VcVirtualMachineConfigSpec
	{
		alternateGuestName: String;
		annotation: String;
		bootOptions: VcVirtualMachineBootOptions;
		changeTrackingEnabled: boolean;
		changeVersion: String;
		consolePreferences: VcVirtualMachineConsolePreferences;
		cpuAffinity: VcVirtualMachineAffinityInfo;
		cpuAllocation: VcResourceAllocationInfo;
		cpuFeatureMask: VcVirtualMachineCpuIdInfoSpec[];
		cpuHotAddEnabled: boolean;
		cpuHotRemoveEnabled: boolean;
		deviceChange: VcVirtualDeviceConfigSpec[];
		extraConfig: VcOptionValue[];
		files: VcVirtualMachineFileInfo;
		firmware: String;
		flags: VcVirtualMachineFlagInfo;
		ftInfo: VcFaultToleranceConfigInfo;
		guestAutoLockEnabled: boolean;
		guestId: String;
		instanceUuid: String;
		latencySensitivity: VcLatencySensitivity;
		locationId: String;
		managedBy: VcManagedByInfo;
		maxMksConnections: Number;
		memoryAffinity: VcVirtualMachineAffinityInfo;
		memoryAllocation: VcResourceAllocationInfo;
		memoryHotAddEnabled: boolean;
		memoryMB: Number;
		memoryReservationLockedToMax: boolean;
		messageBusQueuePattern: String;
		messageBusTunnelEnabled: boolean;
		name: String;
		nestedHVEnabled: boolean;
		networkShaper: VcVirtualMachineNetworkShaperInfo;
		npivDesiredNodeWwns: Number;
		npivDesiredPortWwns: Number;
		npivNodeWorldWideName: Number[];
		npivOnNonRdmDisks: boolean;
		npivPortWorldWideName: Number[];
		npivTemporaryDisabled: boolean;
		npivWorldWideNameOp: String;
		npivWorldWideNameType: String;
		numCoresPerSocket: Number;
		numCPUs: Number;
		powerOpInfo: VcVirtualMachineDefaultPowerOpInfo;
		preserveSwapOnPowerOff: boolean;
		repConfig: VcReplicationConfigSpec;
		scheduledHardwareUpgradeInfo: VcScheduledHardwareUpgradeInfo;
		swapDirectory: String;
		swapPlacement: String;
		tools: VcToolsConfigInfo;
		uuid: String;
		vAppConfig: VcVmConfigSpec;
		vAppConfigRemoved: boolean;
		vAssertsEnabled: boolean;
		version: String;
		virtualICH7MPresent: boolean;
		virtualSMCPresent: boolean;
		vmProfile: VcVirtualMachineProfileSpec[];
		vPMCEnabled: boolean;

		constructor();
	}

	interface VcVirtualMachineConfigSpecNpivWwnOp
	{
		readonly _extend: String;
		readonly _generate: String;
		readonly _remove: String;
		readonly _set: String;
		readonly extend: VcVirtualMachineConfigSpecNpivWwnOp;
		readonly generate: VcVirtualMachineConfigSpecNpivWwnOp;
		readonly id: String;
		readonly name: String;
		readonly remove: VcVirtualMachineConfigSpecNpivWwnOp;
		readonly set: VcVirtualMachineConfigSpecNpivWwnOp;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineConfigSpecNpivWwnOp;
	}

	interface VcVirtualMachineConfigSpecNpivWwnOpConstructor {
		new(value?:any): VcVirtualMachineConfigSpecNpivWwnOp;
		readonly prototype: VcVirtualMachineConfigSpecNpivWwnOp;
	}

	declare const VcVirtualMachineConfigSpecNpivWwnOp: VcVirtualMachineConfigSpecNpivWwnOpConstructor;

	declare class VcVirtualMachineConfigSummary
	{
		annotation: String;
		cpuReservation: Number;
		ftInfo: VcFaultToleranceConfigInfo;
		guestFullName: String;
		guestId: String;
		installBootRequired: boolean;
		instanceUuid: String;
		managedBy: VcManagedByInfo;
		memoryReservation: Number;
		memorySizeMB: Number;
		name: String;
		numCpu: Number;
		numEthernetCards: Number;
		numVirtualDisks: Number;
		product: VcVAppProductInfo;
		template: boolean;
		uuid: String;
		vmPathName: String;

		constructor();
	}

	interface VcVirtualMachineConnectionState
	{
		readonly _connected: String;
		readonly _disconnected: String;
		readonly _inaccessible: String;
		readonly _invalid: String;
		readonly _orphaned: String;
		readonly connected: VcVirtualMachineConnectionState;
		readonly disconnected: VcVirtualMachineConnectionState;
		readonly id: String;
		readonly inaccessible: VcVirtualMachineConnectionState;
		readonly invalid: VcVirtualMachineConnectionState;
		readonly name: String;
		readonly orphaned: VcVirtualMachineConnectionState;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineConnectionState;
	}

	interface VcVirtualMachineConnectionStateConstructor {
		new(value?:any): VcVirtualMachineConnectionState;
		readonly prototype: VcVirtualMachineConnectionState;
	}

	declare const VcVirtualMachineConnectionState: VcVirtualMachineConnectionStateConstructor;

	declare class VcVirtualMachineConsolePreferences
	{
		closeOnPowerOffOrSuspend: boolean;
		enterFullScreenOnPowerOn: boolean;
		powerOnWhenOpened: boolean;

		constructor();
	}

	declare class VcVirtualMachineCpuIdInfoSpec
	{
		info: VcHostCpuIdInfo;
		operation: VcArrayUpdateOperation;
		removeKey: Object;
		removeKey_FloatValue: Number;
		removeKey_IntValue: Number;
		removeKey_LongValue: Number;

		constructor();
	}

	declare class VcVirtualMachineCreateChildSpec
	{
		configParams: VcOptionValue[];
		location: VcVirtualMachineRelocateSpec;
		persistent: boolean;

		constructor();
	}

	declare class VcVirtualMachineDatastoreInfo
	{
		capability: VcDatastoreCapability;
		configurationTag: String[];
		datastore: VcDatastoreSummary;
		maxFileSize: Number;
		maxPhysicalRDMFileSize: Number;
		maxVirtualDiskCapacity: Number;
		maxVirtualRDMFileSize: Number;
		mode: String;
		name: String;
		vStorageSupport: String;

		constructor();
	}

	declare class VcVirtualMachineDatastoreVolumeOption
	{
		fileSystemType: String;
		majorVersion: Number;

		constructor();
	}

	declare class VcVirtualMachineDefaultPowerOpInfo
	{
		defaultPowerOffType: String;
		defaultResetType: String;
		defaultSuspendType: String;
		powerOffType: String;
		resetType: String;
		standbyAction: String;
		suspendType: String;

		constructor();
	}

	declare class VcVirtualMachineDefaultProfileSpec
	{

		constructor();
	}

	declare class VcVirtualMachineDefinedProfileSpec
	{
		profileData: VcVirtualMachineProfileRawData;
		profileId: String;

		constructor();
	}

	declare class VcVirtualMachineDeviceRuntimeInfo
	{
		key: Number;
		runtimeState: VcVirtualMachineDeviceRuntimeInfoDeviceRuntimeState;

		constructor();
	}

	declare class VcVirtualMachineDeviceRuntimeInfoDeviceRuntimeState
	{

		constructor();
	}

	declare class VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState
	{
		reservationStatus: String;
		vmDirectPathGen2Active: boolean;
		vmDirectPathGen2InactiveReasonExtended: String;
		vmDirectPathGen2InactiveReasonOther: String[];
		vmDirectPathGen2InactiveReasonVm: String[];

		constructor();
	}

	interface VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther
	{
		readonly _vmNptIncompatibleHost: String;
		readonly _vmNptIncompatibleNetwork: String;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmNptIncompatibleHost: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;
		readonly vmNptIncompatibleNetwork: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;

		fromString(value?: String): VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;
	}

	interface VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOtherConstructor {
		new(value?:any): VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;
		readonly prototype: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;
	}

	declare const VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOtherConstructor;

	interface VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm
	{
		readonly _vmNptConflictingIOChainConfigured: String;
		readonly _vmNptConflictingOperationInProgress: String;
		readonly _vmNptDisabledOrDisconnectedAdapter: String;
		readonly _vmNptFaultToleranceOrRecordReplayConfigured: String;
		readonly _vmNptIncompatibleAdapterFeatures: String;
		readonly _vmNptIncompatibleAdapterType: String;
		readonly _vmNptIncompatibleBackingType: String;
		readonly _vmNptIncompatibleGuest: String;
		readonly _vmNptIncompatibleGuestDriver: String;
		readonly _vmNptInsufficientMemoryReservation: String;
		readonly _vmNptMonitorBlocks: String;
		readonly _vmNptOutOfIntrVector: String;
		readonly _vmNptRuntimeError: String;
		readonly _vmNptVMCIActive: String;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmNptConflictingIOChainConfigured: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptConflictingOperationInProgress: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptDisabledOrDisconnectedAdapter: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptFaultToleranceOrRecordReplayConfigured: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptIncompatibleAdapterFeatures: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptIncompatibleAdapterType: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptIncompatibleBackingType: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptIncompatibleGuest: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptIncompatibleGuestDriver: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptInsufficientMemoryReservation: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptMonitorBlocks: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptOutOfIntrVector: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptRuntimeError: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly vmNptVMCIActive: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;

		fromString(value?: String): VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
	}

	interface VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVmConstructor {
		new(value?:any): VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly prototype: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
	}

	declare const VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm: VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVmConstructor;

	declare class VcVirtualMachineDiskDeviceInfo
	{
		capacity: Number;
		configurationTag: String[];
		name: String;
		vm: VcVirtualMachine[];

		constructor();
	}

	declare class VcVirtualMachineDisplayTopology
	{
		height: Number;
		width: Number;
		x: Number;
		y: Number;

		constructor();
	}

	declare class VcVirtualMachineEmptyProfileSpec
	{

		constructor();
	}

	interface VcVirtualMachineFaultToleranceState
	{
		readonly _disabled: String;
		readonly _enabled: String;
		readonly _needSecondary: String;
		readonly _notConfigured: String;
		readonly _running: String;
		readonly _starting: String;
		readonly disabled: VcVirtualMachineFaultToleranceState;
		readonly enabled: VcVirtualMachineFaultToleranceState;
		readonly id: String;
		readonly name: String;
		readonly needSecondary: VcVirtualMachineFaultToleranceState;
		readonly notConfigured: VcVirtualMachineFaultToleranceState;
		readonly running: VcVirtualMachineFaultToleranceState;
		readonly starting: VcVirtualMachineFaultToleranceState;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineFaultToleranceState;
	}

	interface VcVirtualMachineFaultToleranceStateConstructor {
		new(value?:any): VcVirtualMachineFaultToleranceState;
		readonly prototype: VcVirtualMachineFaultToleranceState;
	}

	declare const VcVirtualMachineFaultToleranceState: VcVirtualMachineFaultToleranceStateConstructor;

	interface VcVirtualMachineFaultToleranceType
	{
		readonly _checkpointing: String;
		readonly _recordReplay: String;
		readonly _unset: String;
		readonly checkpointing: VcVirtualMachineFaultToleranceType;
		readonly id: String;
		readonly name: String;
		readonly recordReplay: VcVirtualMachineFaultToleranceType;
		readonly unset: VcVirtualMachineFaultToleranceType;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineFaultToleranceType;
	}

	interface VcVirtualMachineFaultToleranceTypeConstructor {
		new(value?:any): VcVirtualMachineFaultToleranceType;
		readonly prototype: VcVirtualMachineFaultToleranceType;
	}

	declare const VcVirtualMachineFaultToleranceType: VcVirtualMachineFaultToleranceTypeConstructor;

	declare class VcVirtualMachineFeatureRequirement
	{
		featureName: String;
		key: String;
		value: String;

		constructor();
	}

	declare class VcVirtualMachineFileInfo
	{
		ftMetadataDirectory: String;
		logDirectory: String;
		snapshotDirectory: String;
		suspendDirectory: String;
		vmPathName: String;

		constructor();
	}

	declare class VcVirtualMachineFileLayout
	{
		configFile: String[];
		disk: VcVirtualMachineFileLayoutDiskLayout[];
		logFile: String[];
		snapshot: VcVirtualMachineFileLayoutSnapshotLayout[];
		swapFile: String;

		constructor();
	}

	declare class VcVirtualMachineFileLayoutDiskLayout
	{
		diskFile: String[];
		key: Number;

		constructor();
	}

	declare class VcVirtualMachineFileLayoutEx
	{
		disk: VcVirtualMachineFileLayoutExDiskLayout[];
		file: VcVirtualMachineFileLayoutExFileInfo[];
		snapshot: VcVirtualMachineFileLayoutExSnapshotLayout[];
		timestamp: Date;

		constructor();
	}

	declare class VcVirtualMachineFileLayoutExDiskLayout
	{
		chain: VcVirtualMachineFileLayoutExDiskUnit[];
		key: Number;

		constructor();
	}

	declare class VcVirtualMachineFileLayoutExDiskUnit
	{
		fileKey: Number[];

		constructor();
	}

	declare class VcVirtualMachineFileLayoutExFileInfo
	{
		accessible: boolean;
		backingObjectId: String;
		key: Number;
		name: String;
		size: Number;
		type: String;
		uniqueSize: Number;

		constructor();
	}

	interface VcVirtualMachineFileLayoutExFileType
	{
		readonly _config: String;
		readonly _core: String;
		readonly _digestDescriptor: String;
		readonly _digestExtent: String;
		readonly _diskDescriptor: String;
		readonly _diskExtent: String;
		readonly _diskReplicationState: String;
		readonly _extendedConfig: String;
		readonly _ftMetadata: String;
		readonly _guestCustomization: String;
		readonly _log: String;
		readonly _namespaceData: String;
		readonly _nvram: String;
		readonly _screenshot: String;
		readonly _snapshotData: String;
		readonly _snapshotList: String;
		readonly _snapshotManifestList: String;
		readonly _snapshotMemory: String;
		readonly _stat: String;
		readonly _suspend: String;
		readonly _suspendMemory: String;
		readonly _swap: String;
		readonly _uwswap: String;
		readonly config: VcVirtualMachineFileLayoutExFileType;
		readonly core: VcVirtualMachineFileLayoutExFileType;
		readonly digestDescriptor: VcVirtualMachineFileLayoutExFileType;
		readonly digestExtent: VcVirtualMachineFileLayoutExFileType;
		readonly diskDescriptor: VcVirtualMachineFileLayoutExFileType;
		readonly diskExtent: VcVirtualMachineFileLayoutExFileType;
		readonly diskReplicationState: VcVirtualMachineFileLayoutExFileType;
		readonly extendedConfig: VcVirtualMachineFileLayoutExFileType;
		readonly ftMetadata: VcVirtualMachineFileLayoutExFileType;
		readonly guestCustomization: VcVirtualMachineFileLayoutExFileType;
		readonly id: String;
		readonly log: VcVirtualMachineFileLayoutExFileType;
		readonly name: String;
		readonly namespaceData: VcVirtualMachineFileLayoutExFileType;
		readonly nvram: VcVirtualMachineFileLayoutExFileType;
		readonly screenshot: VcVirtualMachineFileLayoutExFileType;
		readonly snapshotData: VcVirtualMachineFileLayoutExFileType;
		readonly snapshotList: VcVirtualMachineFileLayoutExFileType;
		readonly snapshotManifestList: VcVirtualMachineFileLayoutExFileType;
		readonly snapshotMemory: VcVirtualMachineFileLayoutExFileType;
		readonly stat: VcVirtualMachineFileLayoutExFileType;
		readonly suspend: VcVirtualMachineFileLayoutExFileType;
		readonly suspendMemory: VcVirtualMachineFileLayoutExFileType;
		readonly swap: VcVirtualMachineFileLayoutExFileType;
		readonly uwswap: VcVirtualMachineFileLayoutExFileType;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineFileLayoutExFileType;
	}

	interface VcVirtualMachineFileLayoutExFileTypeConstructor {
		new(value?:any): VcVirtualMachineFileLayoutExFileType;
		readonly prototype: VcVirtualMachineFileLayoutExFileType;
	}

	declare const VcVirtualMachineFileLayoutExFileType: VcVirtualMachineFileLayoutExFileTypeConstructor;

	declare class VcVirtualMachineFileLayoutExSnapshotLayout
	{
		dataKey: Number;
		disk: VcVirtualMachineFileLayoutExDiskLayout[];
		key: VcVirtualMachineSnapshot;
		memoryKey: Number;

		constructor();
	}

	declare class VcVirtualMachineFileLayoutSnapshotLayout
	{
		key: VcVirtualMachineSnapshot;
		snapshotFile: String[];

		constructor();
	}

	declare class VcVirtualMachineFlagInfo
	{
		disableAcceleration: boolean;
		diskUuidEnabled: boolean;
		enableLogging: boolean;
		faultToleranceType: String;
		htSharing: String;
		monitorType: String;
		recordReplayEnabled: boolean;
		runWithDebugInfo: boolean;
		snapshotDisabled: boolean;
		snapshotLocked: boolean;
		snapshotPowerOffBehavior: String;
		useToe: boolean;
		virtualExecUsage: String;
		virtualMmuUsage: String;

		constructor();
	}

	interface VcVirtualMachineFlagInfoMonitorType
	{
		readonly _debug: String;
		readonly _release: String;
		readonly _stats: String;
		readonly debug: VcVirtualMachineFlagInfoMonitorType;
		readonly id: String;
		readonly name: String;
		readonly release: VcVirtualMachineFlagInfoMonitorType;
		readonly stats: VcVirtualMachineFlagInfoMonitorType;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineFlagInfoMonitorType;
	}

	interface VcVirtualMachineFlagInfoMonitorTypeConstructor {
		new(value?:any): VcVirtualMachineFlagInfoMonitorType;
		readonly prototype: VcVirtualMachineFlagInfoMonitorType;
	}

	declare const VcVirtualMachineFlagInfoMonitorType: VcVirtualMachineFlagInfoMonitorTypeConstructor;

	interface VcVirtualMachineFlagInfoVirtualExecUsage
	{
		readonly _hvAuto: String;
		readonly _hvOff: String;
		readonly _hvOn: String;
		readonly hvAuto: VcVirtualMachineFlagInfoVirtualExecUsage;
		readonly hvOff: VcVirtualMachineFlagInfoVirtualExecUsage;
		readonly hvOn: VcVirtualMachineFlagInfoVirtualExecUsage;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineFlagInfoVirtualExecUsage;
	}

	interface VcVirtualMachineFlagInfoVirtualExecUsageConstructor {
		new(value?:any): VcVirtualMachineFlagInfoVirtualExecUsage;
		readonly prototype: VcVirtualMachineFlagInfoVirtualExecUsage;
	}

	declare const VcVirtualMachineFlagInfoVirtualExecUsage: VcVirtualMachineFlagInfoVirtualExecUsageConstructor;

	interface VcVirtualMachineFlagInfoVirtualMmuUsage
	{
		readonly _automatic: String;
		readonly _off: String;
		readonly _on: String;
		readonly automatic: VcVirtualMachineFlagInfoVirtualMmuUsage;
		readonly id: String;
		readonly name: String;
		readonly off: VcVirtualMachineFlagInfoVirtualMmuUsage;
		readonly on: VcVirtualMachineFlagInfoVirtualMmuUsage;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineFlagInfoVirtualMmuUsage;
	}

	interface VcVirtualMachineFlagInfoVirtualMmuUsageConstructor {
		new(value?:any): VcVirtualMachineFlagInfoVirtualMmuUsage;
		readonly prototype: VcVirtualMachineFlagInfoVirtualMmuUsage;
	}

	declare const VcVirtualMachineFlagInfoVirtualMmuUsage: VcVirtualMachineFlagInfoVirtualMmuUsageConstructor;

	declare class VcVirtualMachineFloppyInfo
	{
		configurationTag: String[];
		name: String;

		constructor();
	}

	declare class VcVirtualMachineForkConfigInfo
	{
		childForkGroupId: String;
		childType: String;
		parentEnabled: boolean;

		constructor();
	}

	interface VcVirtualMachineForkConfigInfoChildType
	{
		readonly _none: String;
		readonly _nonpersistent: String;
		readonly _persistent: String;
		readonly id: String;
		readonly name: String;
		readonly none: VcVirtualMachineForkConfigInfoChildType;
		readonly nonpersistent: VcVirtualMachineForkConfigInfoChildType;
		readonly persistent: VcVirtualMachineForkConfigInfoChildType;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineForkConfigInfoChildType;
	}

	interface VcVirtualMachineForkConfigInfoChildTypeConstructor {
		new(value?:any): VcVirtualMachineForkConfigInfoChildType;
		readonly prototype: VcVirtualMachineForkConfigInfoChildType;
	}

	declare const VcVirtualMachineForkConfigInfoChildType: VcVirtualMachineForkConfigInfoChildTypeConstructor;

	interface VcVirtualMachineGuestOsFamily
	{
		readonly _darwinGuestFamily: String;
		readonly _linuxGuest: String;
		readonly _netwareGuest: String;
		readonly _otherGuestFamily: String;
		readonly _solarisGuest: String;
		readonly _windowsGuest: String;
		readonly darwinGuestFamily: VcVirtualMachineGuestOsFamily;
		readonly id: String;
		readonly linuxGuest: VcVirtualMachineGuestOsFamily;
		readonly name: String;
		readonly netwareGuest: VcVirtualMachineGuestOsFamily;
		readonly otherGuestFamily: VcVirtualMachineGuestOsFamily;
		readonly solarisGuest: VcVirtualMachineGuestOsFamily;
		readonly value: String;
		readonly windowsGuest: VcVirtualMachineGuestOsFamily;

		fromString(value?: String): VcVirtualMachineGuestOsFamily;
	}

	interface VcVirtualMachineGuestOsFamilyConstructor {
		new(value?:any): VcVirtualMachineGuestOsFamily;
		readonly prototype: VcVirtualMachineGuestOsFamily;
	}

	declare const VcVirtualMachineGuestOsFamily: VcVirtualMachineGuestOsFamilyConstructor;

	interface VcVirtualMachineGuestOsIdentifier
	{
		readonly _asianux3_64Guest: String;
		readonly _asianux3Guest: String;
		readonly _asianux4_64Guest: String;
		readonly _asianux4Guest: String;
		readonly _asianux5_64Guest: String;
		readonly _centos64Guest: String;
		readonly _centosGuest: String;
		readonly _coreos64Guest: String;
		readonly _darwin10_64Guest: String;
		readonly _darwin10Guest: String;
		readonly _darwin11_64Guest: String;
		readonly _darwin11Guest: String;
		readonly _darwin12_64Guest: String;
		readonly _darwin13_64Guest: String;
		readonly _darwin14_64Guest: String;
		readonly _darwin64Guest: String;
		readonly _darwinGuest: String;
		readonly _debian4_64Guest: String;
		readonly _debian4Guest: String;
		readonly _debian5_64Guest: String;
		readonly _debian5Guest: String;
		readonly _debian6_64Guest: String;
		readonly _debian6Guest: String;
		readonly _debian7_64Guest: String;
		readonly _debian7Guest: String;
		readonly _debian8_64Guest: String;
		readonly _debian8Guest: String;
		readonly _dosGuest: String;
		readonly _eComStation2Guest: String;
		readonly _eComStationGuest: String;
		readonly _fedora64Guest: String;
		readonly _fedoraGuest: String;
		readonly _freebsd64Guest: String;
		readonly _freebsdGuest: String;
		readonly _genericLinuxGuest: String;
		readonly _mandrakeGuest: String;
		readonly _mandriva64Guest: String;
		readonly _mandrivaGuest: String;
		readonly _netware4Guest: String;
		readonly _netware5Guest: String;
		readonly _netware6Guest: String;
		readonly _nld9Guest: String;
		readonly _oesGuest: String;
		readonly _openServer5Guest: String;
		readonly _openServer6Guest: String;
		readonly _opensuse64Guest: String;
		readonly _opensuseGuest: String;
		readonly _oracleLinux64Guest: String;
		readonly _oracleLinuxGuest: String;
		readonly _os2Guest: String;
		readonly _other24xLinux64Guest: String;
		readonly _other24xLinuxGuest: String;
		readonly _other26xLinux64Guest: String;
		readonly _other26xLinuxGuest: String;
		readonly _other3xLinux64Guest: String;
		readonly _other3xLinuxGuest: String;
		readonly _otherGuest: String;
		readonly _otherGuest64: String;
		readonly _otherLinux64Guest: String;
		readonly _otherLinuxGuest: String;
		readonly _redhatGuest: String;
		readonly _rhel2Guest: String;
		readonly _rhel3_64Guest: String;
		readonly _rhel3Guest: String;
		readonly _rhel4_64Guest: String;
		readonly _rhel4Guest: String;
		readonly _rhel5_64Guest: String;
		readonly _rhel5Guest: String;
		readonly _rhel6_64Guest: String;
		readonly _rhel6Guest: String;
		readonly _rhel7_64Guest: String;
		readonly _rhel7Guest: String;
		readonly _sjdsGuest: String;
		readonly _sles10_64Guest: String;
		readonly _sles10Guest: String;
		readonly _sles11_64Guest: String;
		readonly _sles11Guest: String;
		readonly _sles12_64Guest: String;
		readonly _sles12Guest: String;
		readonly _sles64Guest: String;
		readonly _slesGuest: String;
		readonly _solaris10_64Guest: String;
		readonly _solaris10Guest: String;
		readonly _solaris11_64Guest: String;
		readonly _solaris6Guest: String;
		readonly _solaris7Guest: String;
		readonly _solaris8Guest: String;
		readonly _solaris9Guest: String;
		readonly _suse64Guest: String;
		readonly _suseGuest: String;
		readonly _turboLinux64Guest: String;
		readonly _turboLinuxGuest: String;
		readonly _ubuntu64Guest: String;
		readonly _ubuntuGuest: String;
		readonly _unixWare7Guest: String;
		readonly _vmkernel5Guest: String;
		readonly _vmkernel6Guest: String;
		readonly _vmkernelGuest: String;
		readonly _win2000AdvServGuest: String;
		readonly _win2000ProGuest: String;
		readonly _win2000ServGuest: String;
		readonly _win31Guest: String;
		readonly _win95Guest: String;
		readonly _win98Guest: String;
		readonly _windows7_64Guest: String;
		readonly _windows7Guest: String;
		readonly _windows7Server64Guest: String;
		readonly _windows8_64Guest: String;
		readonly _windows8Guest: String;
		readonly _windows8Server64Guest: String;
		readonly _windows9_64Guest: String;
		readonly _windows9Guest: String;
		readonly _windows9Server64Guest: String;
		readonly _windowsHyperVGuest: String;
		readonly _winLonghorn64Guest: String;
		readonly _winLonghornGuest: String;
		readonly _winMeGuest: String;
		readonly _winNetBusinessGuest: String;
		readonly _winNetDatacenter64Guest: String;
		readonly _winNetDatacenterGuest: String;
		readonly _winNetEnterprise64Guest: String;
		readonly _winNetEnterpriseGuest: String;
		readonly _winNetStandard64Guest: String;
		readonly _winNetStandardGuest: String;
		readonly _winNetWebGuest: String;
		readonly _winNTGuest: String;
		readonly _winVista64Guest: String;
		readonly _winVistaGuest: String;
		readonly _winXPHomeGuest: String;
		readonly _winXPPro64Guest: String;
		readonly _winXPProGuest: String;
		readonly asianux3_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly asianux3Guest: VcVirtualMachineGuestOsIdentifier;
		readonly asianux4_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly asianux4Guest: VcVirtualMachineGuestOsIdentifier;
		readonly asianux5_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly centos64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly centosGuest: VcVirtualMachineGuestOsIdentifier;
		readonly coreos64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin10_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin10Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin11_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin11Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin12_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin13_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin14_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwin64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly darwinGuest: VcVirtualMachineGuestOsIdentifier;
		readonly debian4_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian4Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian5_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian5Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian6_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian7_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian8_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly debian8Guest: VcVirtualMachineGuestOsIdentifier;
		readonly dosGuest: VcVirtualMachineGuestOsIdentifier;
		readonly eComStation2Guest: VcVirtualMachineGuestOsIdentifier;
		readonly eComStationGuest: VcVirtualMachineGuestOsIdentifier;
		readonly fedora64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly fedoraGuest: VcVirtualMachineGuestOsIdentifier;
		readonly freebsd64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly freebsdGuest: VcVirtualMachineGuestOsIdentifier;
		readonly genericLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly id: String;
		readonly mandrakeGuest: VcVirtualMachineGuestOsIdentifier;
		readonly mandriva64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly mandrivaGuest: VcVirtualMachineGuestOsIdentifier;
		readonly name: String;
		readonly netware4Guest: VcVirtualMachineGuestOsIdentifier;
		readonly netware5Guest: VcVirtualMachineGuestOsIdentifier;
		readonly netware6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly nld9Guest: VcVirtualMachineGuestOsIdentifier;
		readonly oesGuest: VcVirtualMachineGuestOsIdentifier;
		readonly openServer5Guest: VcVirtualMachineGuestOsIdentifier;
		readonly openServer6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly opensuse64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly opensuseGuest: VcVirtualMachineGuestOsIdentifier;
		readonly oracleLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly oracleLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly os2Guest: VcVirtualMachineGuestOsIdentifier;
		readonly other24xLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly other24xLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly other26xLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly other26xLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly other3xLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly other3xLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly otherGuest: VcVirtualMachineGuestOsIdentifier;
		readonly otherGuest64: VcVirtualMachineGuestOsIdentifier;
		readonly otherLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly otherLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly redhatGuest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel2Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel3_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel3Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel4_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel4Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel5_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel5Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel6_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel7_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly rhel7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sjdsGuest: VcVirtualMachineGuestOsIdentifier;
		readonly sles10_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles10Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles11_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles11Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles12_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles12Guest: VcVirtualMachineGuestOsIdentifier;
		readonly sles64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly slesGuest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris10_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris10Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris11_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris8Guest: VcVirtualMachineGuestOsIdentifier;
		readonly solaris9Guest: VcVirtualMachineGuestOsIdentifier;
		readonly suse64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly suseGuest: VcVirtualMachineGuestOsIdentifier;
		readonly turboLinux64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly turboLinuxGuest: VcVirtualMachineGuestOsIdentifier;
		readonly ubuntu64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly ubuntuGuest: VcVirtualMachineGuestOsIdentifier;
		readonly unixWare7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly value: String;
		readonly vmkernel5Guest: VcVirtualMachineGuestOsIdentifier;
		readonly vmkernel6Guest: VcVirtualMachineGuestOsIdentifier;
		readonly vmkernelGuest: VcVirtualMachineGuestOsIdentifier;
		readonly win2000AdvServGuest: VcVirtualMachineGuestOsIdentifier;
		readonly win2000ProGuest: VcVirtualMachineGuestOsIdentifier;
		readonly win2000ServGuest: VcVirtualMachineGuestOsIdentifier;
		readonly win31Guest: VcVirtualMachineGuestOsIdentifier;
		readonly win95Guest: VcVirtualMachineGuestOsIdentifier;
		readonly win98Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows7_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows7Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows7Server64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows8_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows8Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows8Server64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows9_64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows9Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windows9Server64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly windowsHyperVGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winLonghorn64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winLonghornGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winMeGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetBusinessGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetDatacenter64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetDatacenterGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetEnterprise64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetEnterpriseGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetStandard64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetStandardGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNetWebGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winNTGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winVista64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winVistaGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winXPHomeGuest: VcVirtualMachineGuestOsIdentifier;
		readonly winXPPro64Guest: VcVirtualMachineGuestOsIdentifier;
		readonly winXPProGuest: VcVirtualMachineGuestOsIdentifier;

		fromString(value?: String): VcVirtualMachineGuestOsIdentifier;
	}

	interface VcVirtualMachineGuestOsIdentifierConstructor {
		new(value?:any): VcVirtualMachineGuestOsIdentifier;
		readonly prototype: VcVirtualMachineGuestOsIdentifier;
	}

	declare const VcVirtualMachineGuestOsIdentifier: VcVirtualMachineGuestOsIdentifierConstructor;

	interface VcVirtualMachineGuestState
	{
		readonly _notRunning: String;
		readonly _resetting: String;
		readonly _running: String;
		readonly _shuttingDown: String;
		readonly _standby: String;
		readonly _unknown: String;
		readonly id: String;
		readonly name: String;
		readonly notRunning: VcVirtualMachineGuestState;
		readonly resetting: VcVirtualMachineGuestState;
		readonly running: VcVirtualMachineGuestState;
		readonly shuttingDown: VcVirtualMachineGuestState;
		readonly standby: VcVirtualMachineGuestState;
		readonly unknown: VcVirtualMachineGuestState;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineGuestState;
	}

	interface VcVirtualMachineGuestStateConstructor {
		new(value?:any): VcVirtualMachineGuestState;
		readonly prototype: VcVirtualMachineGuestState;
	}

	declare const VcVirtualMachineGuestState: VcVirtualMachineGuestStateConstructor;

	declare class VcVirtualMachineGuestSummary
	{
		guestFullName: String;
		guestId: String;
		hostName: String;
		ipAddress: String;
		ipList: String[];
		toolsRunningStatus: String;
		toolsStatus: VcVirtualMachineToolsStatus;
		toolsVersionStatus: String;
		toolsVersionStatus2: String;

		constructor();
	}

	interface VcVirtualMachineHtSharing
	{
		readonly _any: String;
		readonly _internal: String;
		readonly _none: String;
		readonly any: VcVirtualMachineHtSharing;
		readonly id: String;
		readonly internal: VcVirtualMachineHtSharing;
		readonly name: String;
		readonly none: VcVirtualMachineHtSharing;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineHtSharing;
	}

	interface VcVirtualMachineHtSharingConstructor {
		new(value?:any): VcVirtualMachineHtSharing;
		readonly prototype: VcVirtualMachineHtSharing;
	}

	declare const VcVirtualMachineHtSharing: VcVirtualMachineHtSharingConstructor;

	declare class VcVirtualMachineIdeDiskDeviceInfo
	{
		capacity: Number;
		configurationTag: String[];
		name: String;
		partitionTable: VcVirtualMachineIdeDiskDevicePartitionInfo[];
		vm: VcVirtualMachine[];

		constructor();
	}

	declare class VcVirtualMachineIdeDiskDevicePartitionInfo
	{
		capacity: Number;
		id: Number;

		constructor();
	}

	declare class VcVirtualMachineImportSpec
	{
		configSpec: VcVirtualMachineConfigSpec;
		entityConfig: VcVAppEntityConfigInfo;
		instantiationOst: VcOvfConsumerOstNode;
		resPoolEntity: VcResourcePool;

		constructor();
	}

	declare class VcVirtualMachineLegacyNetworkSwitchInfo
	{
		name: String;

		constructor();
	}

	interface VcVirtualMachineMemoryAllocationPolicy
	{
		readonly _swapMost: String;
		readonly _swapNone: String;
		readonly _swapSome: String;
		readonly id: String;
		readonly name: String;
		readonly swapMost: VcVirtualMachineMemoryAllocationPolicy;
		readonly swapNone: VcVirtualMachineMemoryAllocationPolicy;
		readonly swapSome: VcVirtualMachineMemoryAllocationPolicy;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineMemoryAllocationPolicy;
	}

	interface VcVirtualMachineMemoryAllocationPolicyConstructor {
		new(value?:any): VcVirtualMachineMemoryAllocationPolicy;
		readonly prototype: VcVirtualMachineMemoryAllocationPolicy;
	}

	declare const VcVirtualMachineMemoryAllocationPolicy: VcVirtualMachineMemoryAllocationPolicyConstructor;

	declare class VcVirtualMachineMemoryReservationInfo
	{
		allocationPolicy: String;
		virtualMachineMax: Number;
		virtualMachineMin: Number;
		virtualMachineReserved: Number;

		constructor();
	}

	declare class VcVirtualMachineMemoryReservationSpec
	{
		allocationPolicy: String;
		virtualMachineReserved: Number;

		constructor();
	}

	declare class VcVirtualMachineMessage
	{
		argument: Object;
		argument_FloatValue: Number;
		argument_IntValue: Number;
		argument_LongValue: Number;
		id: String;
		text: String;

		constructor();
	}

	declare class VcVirtualMachineMetadataManagerVmMetadata
	{
		metadata: String;
		vmId: String;

		constructor();
	}

	declare class VcVirtualMachineMetadataManagerVmMetadataInput
	{
		operation: String;
		vmMetadata: VcVirtualMachineMetadataManagerVmMetadata;

		constructor();
	}

	interface VcVirtualMachineMetadataManagerVmMetadataOp
	{
		readonly _Remove: String;
		readonly _Update: String;
		readonly id: String;
		readonly name: String;
		readonly Remove: VcVirtualMachineMetadataManagerVmMetadataOp;
		readonly Update: VcVirtualMachineMetadataManagerVmMetadataOp;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineMetadataManagerVmMetadataOp;
	}

	interface VcVirtualMachineMetadataManagerVmMetadataOpConstructor {
		new(value?:any): VcVirtualMachineMetadataManagerVmMetadataOp;
		readonly prototype: VcVirtualMachineMetadataManagerVmMetadataOp;
	}

	declare const VcVirtualMachineMetadataManagerVmMetadataOp: VcVirtualMachineMetadataManagerVmMetadataOpConstructor;

	declare class VcVirtualMachineMetadataManagerVmMetadataOwner
	{
		name: String;

		constructor();
	}

	interface VcVirtualMachineMetadataManagerVmMetadataOwnerOwner
	{
		readonly _ComVmwareVsphereHA: String;
		readonly ComVmwareVsphereHA: VcVirtualMachineMetadataManagerVmMetadataOwnerOwner;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineMetadataManagerVmMetadataOwnerOwner;
	}

	interface VcVirtualMachineMetadataManagerVmMetadataOwnerOwnerConstructor {
		new(value?:any): VcVirtualMachineMetadataManagerVmMetadataOwnerOwner;
		readonly prototype: VcVirtualMachineMetadataManagerVmMetadataOwnerOwner;
	}

	declare const VcVirtualMachineMetadataManagerVmMetadataOwnerOwner: VcVirtualMachineMetadataManagerVmMetadataOwnerOwnerConstructor;

	declare class VcVirtualMachineMetadataManagerVmMetadataResult
	{
		error: VcLocalizedMethodFault;
		vmMetadata: VcVirtualMachineMetadataManagerVmMetadata;

		constructor();
	}

	declare class VcVirtualMachineMksTicket
	{
		cfgFile: String;
		host: String;
		port: Number;
		sslThumbprint: String;
		ticket: String;

		constructor();
	}

	interface VcVirtualMachineMovePriority
	{
		readonly _defaultPriority: String;
		readonly _highPriority: String;
		readonly _lowPriority: String;
		readonly defaultPriority: VcVirtualMachineMovePriority;
		readonly highPriority: VcVirtualMachineMovePriority;
		readonly id: String;
		readonly lowPriority: VcVirtualMachineMovePriority;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineMovePriority;
	}

	interface VcVirtualMachineMovePriorityConstructor {
		new(value?:any): VcVirtualMachineMovePriority;
		readonly prototype: VcVirtualMachineMovePriority;
	}

	declare const VcVirtualMachineMovePriority: VcVirtualMachineMovePriorityConstructor;

	interface VcVirtualMachineNeedSecondaryReason
	{
		readonly _checkpointError: String;
		readonly _divergence: String;
		readonly _initializing: String;
		readonly _lostConnection: String;
		readonly _other: String;
		readonly _partialHardwareFailure: String;
		readonly _userAction: String;
		readonly checkpointError: VcVirtualMachineNeedSecondaryReason;
		readonly divergence: VcVirtualMachineNeedSecondaryReason;
		readonly id: String;
		readonly initializing: VcVirtualMachineNeedSecondaryReason;
		readonly lostConnection: VcVirtualMachineNeedSecondaryReason;
		readonly name: String;
		readonly other: VcVirtualMachineNeedSecondaryReason;
		readonly partialHardwareFailure: VcVirtualMachineNeedSecondaryReason;
		readonly userAction: VcVirtualMachineNeedSecondaryReason;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineNeedSecondaryReason;
	}

	interface VcVirtualMachineNeedSecondaryReasonConstructor {
		new(value?:any): VcVirtualMachineNeedSecondaryReason;
		readonly prototype: VcVirtualMachineNeedSecondaryReason;
	}

	declare const VcVirtualMachineNeedSecondaryReason: VcVirtualMachineNeedSecondaryReasonConstructor;

	declare class VcVirtualMachineNetworkInfo
	{
		configurationTag: String[];
		name: String;
		network: VcNetworkSummary;

		constructor();
	}

	declare class VcVirtualMachineNetworkShaperInfo
	{
		averageBps: Number;
		burstSize: Number;
		enabled: boolean;
		peakBps: Number;

		constructor();
	}

	declare class VcVirtualMachineParallelInfo
	{
		configurationTag: String[];
		name: String;

		constructor();
	}

	declare class VcVirtualMachinePciPassthroughInfo
	{
		configurationTag: String[];
		name: String;
		pciDevice: VcHostPciDevice;
		systemId: String;

		constructor();
	}

	declare class VcVirtualMachinePciSharedGpuPassthroughInfo
	{
		configurationTag: String[];
		name: String;
		vgpu: String;

		constructor();
	}

	interface VcVirtualMachinePowerOffBehavior
	{
		readonly _powerOff: String;
		readonly _prompt: String;
		readonly _revert: String;
		readonly _take: String;
		readonly id: String;
		readonly name: String;
		readonly powerOff: VcVirtualMachinePowerOffBehavior;
		readonly prompt: VcVirtualMachinePowerOffBehavior;
		readonly revert: VcVirtualMachinePowerOffBehavior;
		readonly take: VcVirtualMachinePowerOffBehavior;
		readonly value: String;

		fromString(value?: String): VcVirtualMachinePowerOffBehavior;
	}

	interface VcVirtualMachinePowerOffBehaviorConstructor {
		new(value?:any): VcVirtualMachinePowerOffBehavior;
		readonly prototype: VcVirtualMachinePowerOffBehavior;
	}

	declare const VcVirtualMachinePowerOffBehavior: VcVirtualMachinePowerOffBehaviorConstructor;

	interface VcVirtualMachinePowerOpType
	{
		readonly _hard: String;
		readonly _preset: String;
		readonly _soft: String;
		readonly hard: VcVirtualMachinePowerOpType;
		readonly id: String;
		readonly name: String;
		readonly preset: VcVirtualMachinePowerOpType;
		readonly soft: VcVirtualMachinePowerOpType;
		readonly value: String;

		fromString(value?: String): VcVirtualMachinePowerOpType;
	}

	interface VcVirtualMachinePowerOpTypeConstructor {
		new(value?:any): VcVirtualMachinePowerOpType;
		readonly prototype: VcVirtualMachinePowerOpType;
	}

	declare const VcVirtualMachinePowerOpType: VcVirtualMachinePowerOpTypeConstructor;

	declare class VcVirtualMachinePowerPolicy
	{
		acProfile: VcVirtualMachinePowerPolicyProfile;
		batteryProfile: VcVirtualMachinePowerPolicyProfile;
		powerMode: String;

		constructor();
	}

	interface VcVirtualMachinePowerPolicyCpuMode
	{
		readonly _adaptiveProcessorThrottling: String;
		readonly _constantProcessorThrottling: String;
		readonly _degradedProcessorThrottling: String;
		readonly _noProcessorThrottling: String;
		readonly adaptiveProcessorThrottling: VcVirtualMachinePowerPolicyCpuMode;
		readonly constantProcessorThrottling: VcVirtualMachinePowerPolicyCpuMode;
		readonly degradedProcessorThrottling: VcVirtualMachinePowerPolicyCpuMode;
		readonly id: String;
		readonly name: String;
		readonly noProcessorThrottling: VcVirtualMachinePowerPolicyCpuMode;
		readonly value: String;

		fromString(value?: String): VcVirtualMachinePowerPolicyCpuMode;
	}

	interface VcVirtualMachinePowerPolicyCpuModeConstructor {
		new(value?:any): VcVirtualMachinePowerPolicyCpuMode;
		readonly prototype: VcVirtualMachinePowerPolicyCpuMode;
	}

	declare const VcVirtualMachinePowerPolicyCpuMode: VcVirtualMachinePowerPolicyCpuModeConstructor;

	interface VcVirtualMachinePowerPolicyPowerMode
	{
		readonly _acPower: String;
		readonly _batteryPower: String;
		readonly acPower: VcVirtualMachinePowerPolicyPowerMode;
		readonly batteryPower: VcVirtualMachinePowerPolicyPowerMode;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachinePowerPolicyPowerMode;
	}

	interface VcVirtualMachinePowerPolicyPowerModeConstructor {
		new(value?:any): VcVirtualMachinePowerPolicyPowerMode;
		readonly prototype: VcVirtualMachinePowerPolicyPowerMode;
	}

	declare const VcVirtualMachinePowerPolicyPowerMode: VcVirtualMachinePowerPolicyPowerModeConstructor;

	declare class VcVirtualMachinePowerPolicyProfile
	{
		cpuMode: String;
		forcedThrottle: Number;
		hardDiskTimeout: Number;
		hibernateTimeout: Number;
		maxProcessorState: Number;
		minProcessorState: Number;
		monitorTimeout: Number;
		suspendTimeout: Number;

		constructor();
	}

	interface VcVirtualMachinePowerState
	{
		readonly _poweredOff: String;
		readonly _poweredOn: String;
		readonly _suspended: String;
		readonly id: String;
		readonly name: String;
		readonly poweredOff: VcVirtualMachinePowerState;
		readonly poweredOn: VcVirtualMachinePowerState;
		readonly suspended: VcVirtualMachinePowerState;
		readonly value: String;

		fromString(value?: String): VcVirtualMachinePowerState;
	}

	interface VcVirtualMachinePowerStateConstructor {
		new(value?:any): VcVirtualMachinePowerState;
		readonly prototype: VcVirtualMachinePowerState;
	}

	declare const VcVirtualMachinePowerState: VcVirtualMachinePowerStateConstructor;

	declare class VcVirtualMachineProfileRawData
	{
		extensionKey: String;
		objectData: String;

		constructor();
	}

	declare class VcVirtualMachineProfileSpec
	{

		constructor();
	}

	interface VcVirtualMachineProvisioningChecker
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		checkMigrate_Task(vm?: VcVirtualMachine, host?: VcHostSystem, pool?: VcResourcePool, state?: VcVirtualMachinePowerState, testType?: String[]): VcTask;
		checkRelocate_Task(vm?: VcVirtualMachine, spec?: VcVirtualMachineRelocateSpec, testType?: String[]): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		queryVMotionCompatibilityEx_Task(vm?: VcVirtualMachine[], host?: VcHostSystem[]): VcTask;
	}

	declare const VcVirtualMachineProvisioningChecker: VcVirtualMachineProvisioningChecker;

	declare class VcVirtualMachineQuestionInfo
	{
		choice: VcChoiceOption;
		id: String;
		message: VcVirtualMachineMessage[];
		text: String;

		constructor();
	}

	declare class VcVirtualMachineQuickStats
	{
		balloonedMemory: Number;
		compressedMemory: Number;
		consumedOverheadMemory: Number;
		distributedCpuEntitlement: Number;
		distributedMemoryEntitlement: Number;
		ftLatencyStatus: VcManagedEntityStatus;
		ftLogBandwidth: Number;
		ftSecondaryLatency: Number;
		guestHeartbeatStatus: VcManagedEntityStatus;
		guestMemoryUsage: Number;
		hostMemoryUsage: Number;
		overallCpuDemand: Number;
		overallCpuUsage: Number;
		privateMemory: Number;
		sharedMemory: Number;
		ssdSwappedMemory: Number;
		staticCpuEntitlement: Number;
		staticMemoryEntitlement: Number;
		swappedMemory: Number;
		uptimeSeconds: Number;

		constructor();
	}

	interface VcVirtualMachineRecordReplayState
	{
		readonly _inactive: String;
		readonly _recording: String;
		readonly _replaying: String;
		readonly id: String;
		readonly inactive: VcVirtualMachineRecordReplayState;
		readonly name: String;
		readonly recording: VcVirtualMachineRecordReplayState;
		readonly replaying: VcVirtualMachineRecordReplayState;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineRecordReplayState;
	}

	interface VcVirtualMachineRecordReplayStateConstructor {
		new(value?:any): VcVirtualMachineRecordReplayState;
		readonly prototype: VcVirtualMachineRecordReplayState;
	}

	declare const VcVirtualMachineRecordReplayState: VcVirtualMachineRecordReplayStateConstructor;

	interface VcVirtualMachineRelocateDiskMoveOptions
	{
		readonly _createNewChildDiskBacking: String;
		readonly _moveAllDiskBackingsAndAllowSharing: String;
		readonly _moveAllDiskBackingsAndConsolidate: String;
		readonly _moveAllDiskBackingsAndDisallowSharing: String;
		readonly _moveChildMostDiskBacking: String;
		readonly createNewChildDiskBacking: VcVirtualMachineRelocateDiskMoveOptions;
		readonly id: String;
		readonly moveAllDiskBackingsAndAllowSharing: VcVirtualMachineRelocateDiskMoveOptions;
		readonly moveAllDiskBackingsAndConsolidate: VcVirtualMachineRelocateDiskMoveOptions;
		readonly moveAllDiskBackingsAndDisallowSharing: VcVirtualMachineRelocateDiskMoveOptions;
		readonly moveChildMostDiskBacking: VcVirtualMachineRelocateDiskMoveOptions;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineRelocateDiskMoveOptions;
	}

	interface VcVirtualMachineRelocateDiskMoveOptionsConstructor {
		new(value?:any): VcVirtualMachineRelocateDiskMoveOptions;
		readonly prototype: VcVirtualMachineRelocateDiskMoveOptions;
	}

	declare const VcVirtualMachineRelocateDiskMoveOptions: VcVirtualMachineRelocateDiskMoveOptionsConstructor;

	declare class VcVirtualMachineRelocateSpec
	{
		datastore: VcDatastore;
		deviceChange: VcVirtualDeviceConfigSpec[];
		disk: VcVirtualMachineRelocateSpecDiskLocator[];
		diskMoveType: String;
		folder: VcFolder;
		host: VcHostSystem;
		pool: VcResourcePool;
		profile: VcVirtualMachineProfileSpec[];
		service: VcServiceLocator;
		transform: VcVirtualMachineRelocateTransformation;

		constructor();
	}

	declare class VcVirtualMachineRelocateSpecDiskLocator
	{
		datastore: VcDatastore;
		diskBackingInfo: VcVirtualDeviceBackingInfo;
		diskId: Number;
		diskMoveType: String;
		profile: VcVirtualMachineProfileSpec[];

		constructor();
	}

	interface VcVirtualMachineRelocateTransformation
	{
		readonly _flat: String;
		readonly _sparse: String;
		readonly flat: VcVirtualMachineRelocateTransformation;
		readonly id: String;
		readonly name: String;
		readonly sparse: VcVirtualMachineRelocateTransformation;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineRelocateTransformation;
	}

	interface VcVirtualMachineRelocateTransformationConstructor {
		new(value?:any): VcVirtualMachineRelocateTransformation;
		readonly prototype: VcVirtualMachineRelocateTransformation;
	}

	declare const VcVirtualMachineRelocateTransformation: VcVirtualMachineRelocateTransformationConstructor;

	declare class VcVirtualMachineRuntimeInfo
	{
		bootTime: Date;
		cleanPowerOff: boolean;
		connectionState: VcVirtualMachineConnectionState;
		consolidationNeeded: boolean;
		dasVmProtection: VcVirtualMachineRuntimeInfoDasProtectionState;
		device: VcVirtualMachineDeviceRuntimeInfo[];
		faultToleranceState: VcVirtualMachineFaultToleranceState;
		featureMask: VcHostFeatureMask[];
		featureRequirement: VcVirtualMachineFeatureRequirement[];
		host: VcHostSystem;
		maxCpuUsage: Number;
		maxMemoryUsage: Number;
		memoryOverhead: Number;
		minRequiredEVCModeKey: String;
		needSecondaryReason: String;
		numMksConnections: Number;
		offlineFeatureRequirement: VcVirtualMachineFeatureRequirement[];
		onlineStandby: boolean;
		paused: boolean;
		powerState: VcVirtualMachinePowerState;
		question: VcVirtualMachineQuestionInfo;
		quiescedForkParent: boolean;
		recordReplayState: VcVirtualMachineRecordReplayState;
		snapshotInBackground: boolean;
		suspendInterval: Number;
		suspendTime: Date;
		toolsInstallerMounted: boolean;
		vFlashCacheAllocation: Number;

		constructor();
	}

	declare class VcVirtualMachineRuntimeInfoDasProtectionState
	{
		dasProtected: boolean;

		constructor();
	}

	declare class VcVirtualMachineScsiDiskDeviceInfo
	{
		capacity: Number;
		configurationTag: String[];
		disk: VcHostScsiDisk;
		lunNumber: Number;
		name: String;
		transportHint: String;
		vm: VcVirtualMachine[];

		constructor();
	}

	declare class VcVirtualMachineScsiPassthroughInfo
	{
		configurationTag: String[];
		name: String;
		physicalUnitNumber: Number;
		scsiClass: String;
		vendor: String;

		constructor();
	}

	interface VcVirtualMachineScsiPassthroughType
	{
		readonly _cdrom: String;
		readonly _com: String;
		readonly _disk: String;
		readonly _media: String;
		readonly _optical: String;
		readonly _printer: String;
		readonly _processor: String;
		readonly _raid: String;
		readonly _scanner: String;
		readonly _tape: String;
		readonly _unknown: String;
		readonly _worm: String;
		readonly cdrom: VcVirtualMachineScsiPassthroughType;
		readonly com: VcVirtualMachineScsiPassthroughType;
		readonly disk: VcVirtualMachineScsiPassthroughType;
		readonly id: String;
		readonly media: VcVirtualMachineScsiPassthroughType;
		readonly name: String;
		readonly optical: VcVirtualMachineScsiPassthroughType;
		readonly printer: VcVirtualMachineScsiPassthroughType;
		readonly processor: VcVirtualMachineScsiPassthroughType;
		readonly raid: VcVirtualMachineScsiPassthroughType;
		readonly scanner: VcVirtualMachineScsiPassthroughType;
		readonly tape: VcVirtualMachineScsiPassthroughType;
		readonly unknown: VcVirtualMachineScsiPassthroughType;
		readonly value: String;
		readonly worm: VcVirtualMachineScsiPassthroughType;

		fromString(value?: String): VcVirtualMachineScsiPassthroughType;
	}

	interface VcVirtualMachineScsiPassthroughTypeConstructor {
		new(value?:any): VcVirtualMachineScsiPassthroughType;
		readonly prototype: VcVirtualMachineScsiPassthroughType;
	}

	declare const VcVirtualMachineScsiPassthroughType: VcVirtualMachineScsiPassthroughTypeConstructor;

	declare class VcVirtualMachineSerialInfo
	{
		configurationTag: String[];
		name: String;

		constructor();
	}

	interface VcVirtualMachineSnapshot
	{
		availableField: VcCustomFieldDef[];
		childSnapshot: VcVirtualMachineSnapshot[];
		config: VcVirtualMachineConfigInfo;
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;
		vm: VcVirtualMachine;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		exportSnapshot(): VcHttpNfcLease;
		removeSnapshot_Task(removeChildren?: boolean, consolidate?: boolean): VcTask;
		renameSnapshot(name?: String, description?: String): void;
		revertToSnapshot_Task(host?: VcHostSystem, suppressPowerOn?: boolean): VcTask;
		setCustomValue(key?: String, value?: String): void;
	}

	declare const VcVirtualMachineSnapshot: VcVirtualMachineSnapshot;

	declare class VcVirtualMachineSnapshotInfo
	{
		currentSnapshot: VcVirtualMachineSnapshot;
		rootSnapshotList: VcVirtualMachineSnapshotTree[];

		constructor();
	}

	declare class VcVirtualMachineSnapshotTree
	{
		backupManifest: String;
		childSnapshotList: VcVirtualMachineSnapshotTree[];
		createTime: Date;
		description: String;
		id: Number;
		name: String;
		quiesced: boolean;
		replaySupported: boolean;
		snapshot: VcVirtualMachineSnapshot;
		state: VcVirtualMachinePowerState;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcVirtualMachineSoundInfo
	{
		configurationTag: String[];
		name: String;

		constructor();
	}

	declare class VcVirtualMachineSriovInfo
	{
		configurationTag: String[];
		name: String;
		pciDevice: VcHostPciDevice;
		pnic: String;
		systemId: String;
		virtualFunction: boolean;

		constructor();
	}

	interface VcVirtualMachineStandbyActionType
	{
		readonly _checkpoint: String;
		readonly _powerOnSuspend: String;
		readonly checkpoint: VcVirtualMachineStandbyActionType;
		readonly id: String;
		readonly name: String;
		readonly powerOnSuspend: VcVirtualMachineStandbyActionType;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineStandbyActionType;
	}

	interface VcVirtualMachineStandbyActionTypeConstructor {
		new(value?:any): VcVirtualMachineStandbyActionType;
		readonly prototype: VcVirtualMachineStandbyActionType;
	}

	declare const VcVirtualMachineStandbyActionType: VcVirtualMachineStandbyActionTypeConstructor;

	declare class VcVirtualMachineStorageInfo
	{
		perDatastoreUsage: VcVirtualMachineUsageOnDatastore[];
		timestamp: Date;

		constructor();
	}

	declare class VcVirtualMachineStorageSummary
	{
		committed: Number;
		timestamp: Date;
		uncommitted: Number;
		unshared: Number;

		constructor();
	}

	declare class VcVirtualMachineSummary
	{
		config: VcVirtualMachineConfigSummary;
		customValue: VcCustomFieldValue[];
		guest: VcVirtualMachineGuestSummary;
		overallStatus: VcManagedEntityStatus;
		quickStats: VcVirtualMachineQuickStats;
		runtime: VcVirtualMachineRuntimeInfo;
		storage: VcVirtualMachineStorageSummary;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcVirtualMachineTargetInfo
	{
		configurationTag: String[];
		name: String;

		constructor();
	}

	interface VcVirtualMachineTargetInfoConfigurationTag
	{
		readonly _clusterWide: String;
		readonly _compliant: String;
		readonly clusterWide: VcVirtualMachineTargetInfoConfigurationTag;
		readonly compliant: VcVirtualMachineTargetInfoConfigurationTag;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineTargetInfoConfigurationTag;
	}

	interface VcVirtualMachineTargetInfoConfigurationTagConstructor {
		new(value?:any): VcVirtualMachineTargetInfoConfigurationTag;
		readonly prototype: VcVirtualMachineTargetInfoConfigurationTag;
	}

	declare const VcVirtualMachineTargetInfoConfigurationTag: VcVirtualMachineTargetInfoConfigurationTagConstructor;

	declare class VcVirtualMachineTicket
	{
		cfgFile: String;
		host: String;
		port: Number;
		sslThumbprint: String;
		ticket: String;

		constructor();
	}

	interface VcVirtualMachineTicketType
	{
		readonly _device: String;
		readonly _guestControl: String;
		readonly _mks: String;
		readonly _webmks: String;
		readonly device: VcVirtualMachineTicketType;
		readonly guestControl: VcVirtualMachineTicketType;
		readonly id: String;
		readonly mks: VcVirtualMachineTicketType;
		readonly name: String;
		readonly value: String;
		readonly webmks: VcVirtualMachineTicketType;

		fromString(value?: String): VcVirtualMachineTicketType;
	}

	interface VcVirtualMachineTicketTypeConstructor {
		new(value?:any): VcVirtualMachineTicketType;
		readonly prototype: VcVirtualMachineTicketType;
	}

	declare const VcVirtualMachineTicketType: VcVirtualMachineTicketTypeConstructor;

	interface VcVirtualMachineToolsRunningStatus
	{
		readonly _guestToolsExecutingScripts: String;
		readonly _guestToolsNotRunning: String;
		readonly _guestToolsRunning: String;
		readonly guestToolsExecutingScripts: VcVirtualMachineToolsRunningStatus;
		readonly guestToolsNotRunning: VcVirtualMachineToolsRunningStatus;
		readonly guestToolsRunning: VcVirtualMachineToolsRunningStatus;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineToolsRunningStatus;
	}

	interface VcVirtualMachineToolsRunningStatusConstructor {
		new(value?:any): VcVirtualMachineToolsRunningStatus;
		readonly prototype: VcVirtualMachineToolsRunningStatus;
	}

	declare const VcVirtualMachineToolsRunningStatus: VcVirtualMachineToolsRunningStatusConstructor;

	interface VcVirtualMachineToolsStatus
	{
		readonly _toolsNotInstalled: String;
		readonly _toolsNotRunning: String;
		readonly _toolsOk: String;
		readonly _toolsOld: String;
		readonly id: String;
		readonly name: String;
		readonly toolsNotInstalled: VcVirtualMachineToolsStatus;
		readonly toolsNotRunning: VcVirtualMachineToolsStatus;
		readonly toolsOk: VcVirtualMachineToolsStatus;
		readonly toolsOld: VcVirtualMachineToolsStatus;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineToolsStatus;
	}

	interface VcVirtualMachineToolsStatusConstructor {
		new(value?:any): VcVirtualMachineToolsStatus;
		readonly prototype: VcVirtualMachineToolsStatus;
	}

	declare const VcVirtualMachineToolsStatus: VcVirtualMachineToolsStatusConstructor;

	declare class VcVirtualMachineToolsUpdateStatus
	{
		updateRequireReboot: boolean;
		updateRequireRebootComponent: String[];

		constructor();
	}

	interface VcVirtualMachineToolsVersionStatus
	{
		readonly _guestToolsBlacklisted: String;
		readonly _guestToolsCurrent: String;
		readonly _guestToolsNeedUpgrade: String;
		readonly _guestToolsNotInstalled: String;
		readonly _guestToolsSupportedNew: String;
		readonly _guestToolsSupportedOld: String;
		readonly _guestToolsTooNew: String;
		readonly _guestToolsTooOld: String;
		readonly _guestToolsUnmanaged: String;
		readonly guestToolsBlacklisted: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsCurrent: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsNeedUpgrade: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsNotInstalled: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsSupportedNew: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsSupportedOld: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsTooNew: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsTooOld: VcVirtualMachineToolsVersionStatus;
		readonly guestToolsUnmanaged: VcVirtualMachineToolsVersionStatus;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineToolsVersionStatus;
	}

	interface VcVirtualMachineToolsVersionStatusConstructor {
		new(value?:any): VcVirtualMachineToolsVersionStatus;
		readonly prototype: VcVirtualMachineToolsVersionStatus;
	}

	declare const VcVirtualMachineToolsVersionStatus: VcVirtualMachineToolsVersionStatusConstructor;

	declare class VcVirtualMachineUsageOnDatastore
	{
		committed: Number;
		datastore: VcDatastore;
		uncommitted: Number;
		unshared: Number;

		constructor();
	}

	declare class VcVirtualMachineUsbInfo
	{
		configurationTag: String[];
		description: String;
		family: String[];
		name: String;
		physicalPath: String;
		product: Number;
		speed: String[];
		summary: VcVirtualMachineSummary;
		vendor: Number;

		constructor();
	}

	interface VcVirtualMachineUsbInfoFamily
	{
		readonly _audio: String;
		readonly _bluetooth: String;
		readonly _communication: String;
		readonly _hid: String;
		readonly _hid_bootable: String;
		readonly _hub: String;
		readonly _imaging: String;
		readonly _other: String;
		readonly _pda: String;
		readonly _physical: String;
		readonly _printer: String;
		readonly _security: String;
		readonly _smart_card: String;
		readonly _storage: String;
		readonly _unknownFamily: String;
		readonly _vendor_specific: String;
		readonly _video: String;
		readonly _wireless: String;
		readonly _wusb: String;
		readonly audio: VcVirtualMachineUsbInfoFamily;
		readonly bluetooth: VcVirtualMachineUsbInfoFamily;
		readonly communication: VcVirtualMachineUsbInfoFamily;
		readonly hid: VcVirtualMachineUsbInfoFamily;
		readonly hid_bootable: VcVirtualMachineUsbInfoFamily;
		readonly hub: VcVirtualMachineUsbInfoFamily;
		readonly id: String;
		readonly imaging: VcVirtualMachineUsbInfoFamily;
		readonly name: String;
		readonly other: VcVirtualMachineUsbInfoFamily;
		readonly pda: VcVirtualMachineUsbInfoFamily;
		readonly physical: VcVirtualMachineUsbInfoFamily;
		readonly printer: VcVirtualMachineUsbInfoFamily;
		readonly security: VcVirtualMachineUsbInfoFamily;
		readonly smart_card: VcVirtualMachineUsbInfoFamily;
		readonly storage: VcVirtualMachineUsbInfoFamily;
		readonly unknownFamily: VcVirtualMachineUsbInfoFamily;
		readonly value: String;
		readonly vendor_specific: VcVirtualMachineUsbInfoFamily;
		readonly video: VcVirtualMachineUsbInfoFamily;
		readonly wireless: VcVirtualMachineUsbInfoFamily;
		readonly wusb: VcVirtualMachineUsbInfoFamily;

		fromString(value?: String): VcVirtualMachineUsbInfoFamily;
	}

	interface VcVirtualMachineUsbInfoFamilyConstructor {
		new(value?:any): VcVirtualMachineUsbInfoFamily;
		readonly prototype: VcVirtualMachineUsbInfoFamily;
	}

	declare const VcVirtualMachineUsbInfoFamily: VcVirtualMachineUsbInfoFamilyConstructor;

	interface VcVirtualMachineUsbInfoSpeed
	{
		readonly _full: String;
		readonly _high: String;
		readonly _low: String;
		readonly _superSpeed: String;
		readonly _unknownSpeed: String;
		readonly full: VcVirtualMachineUsbInfoSpeed;
		readonly high: VcVirtualMachineUsbInfoSpeed;
		readonly id: String;
		readonly low: VcVirtualMachineUsbInfoSpeed;
		readonly name: String;
		readonly superSpeed: VcVirtualMachineUsbInfoSpeed;
		readonly unknownSpeed: VcVirtualMachineUsbInfoSpeed;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineUsbInfoSpeed;
	}

	interface VcVirtualMachineUsbInfoSpeedConstructor {
		new(value?:any): VcVirtualMachineUsbInfoSpeed;
		readonly prototype: VcVirtualMachineUsbInfoSpeed;
	}

	declare const VcVirtualMachineUsbInfoSpeed: VcVirtualMachineUsbInfoSpeedConstructor;

	declare class VcVirtualMachineVFlashModuleInfo
	{
		configurationTag: String[];
		name: String;
		vFlashModule: VcHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;

		constructor();
	}

	declare class VcVirtualMachineVideoCard
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		enable3DSupport: boolean;
		enableMPTSupport: boolean;
		graphicsMemorySizeInKB: Number;
		key: Number;
		numDisplays: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		use3dRenderer: String;
		useAutoDetect: boolean;
		videoRamSizeInKB: Number;

		constructor();
	}

	interface VcVirtualMachineVideoCardUse3dRenderer
	{
		readonly _automatic: String;
		readonly _hardware: String;
		readonly _software: String;
		readonly automatic: VcVirtualMachineVideoCardUse3dRenderer;
		readonly hardware: VcVirtualMachineVideoCardUse3dRenderer;
		readonly id: String;
		readonly name: String;
		readonly software: VcVirtualMachineVideoCardUse3dRenderer;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineVideoCardUse3dRenderer;
	}

	interface VcVirtualMachineVideoCardUse3dRendererConstructor {
		new(value?:any): VcVirtualMachineVideoCardUse3dRenderer;
		readonly prototype: VcVirtualMachineVideoCardUse3dRenderer;
	}

	declare const VcVirtualMachineVideoCardUse3dRenderer: VcVirtualMachineVideoCardUse3dRendererConstructor;

	declare class VcVirtualMachineVMCIDevice
	{
		allowUnrestrictedCommunication: boolean;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		filterEnable: boolean;
		filters: VcVirtualMachineVMCIDeviceFilterSpec[];
		id: Number;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	interface VcVirtualMachineVMCIDeviceAction
	{
		readonly _allow: String;
		readonly _deny: String;
		readonly allow: VcVirtualMachineVMCIDeviceAction;
		readonly deny: VcVirtualMachineVMCIDeviceAction;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineVMCIDeviceAction;
	}

	interface VcVirtualMachineVMCIDeviceActionConstructor {
		new(value?:any): VcVirtualMachineVMCIDeviceAction;
		readonly prototype: VcVirtualMachineVMCIDeviceAction;
	}

	declare const VcVirtualMachineVMCIDeviceAction: VcVirtualMachineVMCIDeviceActionConstructor;

	interface VcVirtualMachineVMCIDeviceDirection
	{
		readonly _anyDirection: String;
		readonly _guest: String;
		readonly _host: String;
		readonly anyDirection: VcVirtualMachineVMCIDeviceDirection;
		readonly guest: VcVirtualMachineVMCIDeviceDirection;
		readonly host: VcVirtualMachineVMCIDeviceDirection;
		readonly id: String;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineVMCIDeviceDirection;
	}

	interface VcVirtualMachineVMCIDeviceDirectionConstructor {
		new(value?:any): VcVirtualMachineVMCIDeviceDirection;
		readonly prototype: VcVirtualMachineVMCIDeviceDirection;
	}

	declare const VcVirtualMachineVMCIDeviceDirection: VcVirtualMachineVMCIDeviceDirectionConstructor;

	declare class VcVirtualMachineVMCIDeviceFilterSpec
	{
		action: String;
		direction: String;
		lowerDstPortBoundary: Number;
		protocol: String;
		rank: Number;
		upperDstPortBoundary: Number;

		constructor();
	}

	declare class VcVirtualMachineVMCIDeviceOption
	{
		allowUnrestrictedCommunication: VcBoolOption;
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		filterSpecOption: VcVirtualMachineVMCIDeviceOptionFilterSpecOption;
		filterSupported: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualMachineVMCIDeviceOptionFilterSpecOption
	{
		action: VcChoiceOption;
		direction: VcChoiceOption;
		lowerDstPortBoundary: VcLongOption;
		protocol: VcChoiceOption;
		upperDstPortBoundary: VcLongOption;

		constructor();
	}

	interface VcVirtualMachineVMCIDeviceProtocol
	{
		readonly _anyProtocol: String;
		readonly _datagram: String;
		readonly _doorbell: String;
		readonly _hypervisor: String;
		readonly _queuepair: String;
		readonly _stream: String;
		readonly anyProtocol: VcVirtualMachineVMCIDeviceProtocol;
		readonly datagram: VcVirtualMachineVMCIDeviceProtocol;
		readonly doorbell: VcVirtualMachineVMCIDeviceProtocol;
		readonly hypervisor: VcVirtualMachineVMCIDeviceProtocol;
		readonly id: String;
		readonly name: String;
		readonly queuepair: VcVirtualMachineVMCIDeviceProtocol;
		readonly stream: VcVirtualMachineVMCIDeviceProtocol;
		readonly value: String;

		fromString(value?: String): VcVirtualMachineVMCIDeviceProtocol;
	}

	interface VcVirtualMachineVMCIDeviceProtocolConstructor {
		new(value?:any): VcVirtualMachineVMCIDeviceProtocol;
		readonly prototype: VcVirtualMachineVMCIDeviceProtocol;
	}

	declare const VcVirtualMachineVMCIDeviceProtocol: VcVirtualMachineVMCIDeviceProtocolConstructor;

	declare class VcVirtualMachineVMIROM
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualMachineWipeResult
	{
		diskId: Number;
		shrinkableDiskSpace: Number;

		constructor();
	}

	declare class VcVirtualNicManagerNetConfig
	{
		candidateVnic: VcHostVirtualNic[];
		multiSelectAllowed: boolean;
		nicType: String;
		selectedVnic: VcHostVirtualNic[];

		constructor();
	}

	declare class VcVirtualParallelPort
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualParallelPortDeviceBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualParallelPortDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualParallelPortFileBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		fileName: String;

		constructor();
	}

	declare class VcVirtualParallelPortFileBackingOption
	{
		fileNameExtensions: VcChoiceOption;
		type: String;

		constructor();
	}

	declare class VcVirtualParallelPortOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualPCIController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualPCIControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numEthernetCards: VcIntOption;
		numParaVirtualSCSIControllers: VcIntOption;
		numPCIPassthroughDevices: VcIntOption;
		numSasSCSIControllers: VcIntOption;
		numSATAControllers: VcIntOption;
		numSCSIControllers: VcIntOption;
		numSoundCards: VcIntOption;
		numVideoCards: VcIntOption;
		numVmciDevices: VcIntOption;
		numVmiRoms: VcIntOption;
		numVmxnet3EthernetCards: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
	}

	declare class VcVirtualPCIPassthrough
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualPCIPassthroughDeviceBackingInfo
	{
		deviceId: String;
		deviceName: String;
		id: String;
		systemId: String;
		useAutoDetect: boolean;
		vendorId: Number;

		constructor();
	}

	declare class VcVirtualPCIPassthroughDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualPCIPassthroughOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualPCIPassthroughPluginBackingInfo
	{

		constructor();
	}

	declare class VcVirtualPCIPassthroughPluginBackingOption
	{
		type: String;

		constructor();
	}

	declare class VcVirtualPCIPassthroughVmiopBackingInfo
	{
		vgpu: String;

		constructor();
	}

	declare class VcVirtualPCIPassthroughVmiopBackingOption
	{
		maxInstances: Number;
		type: String;
		vgpu: VcStringOption;

		constructor();
	}

	declare class VcVirtualPCNet32
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
	}

	declare class VcVirtualPCNet32Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		supportsMorphing: boolean;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
	}

	declare class VcVirtualPointingDevice
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualPointingDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		hostPointingDevice: VcChoiceOption;
		type: String;

		constructor();
	}

	declare class VcVirtualPointingDeviceDeviceBackingInfo
	{
		deviceName: String;
		hostPointingDevice: String;
		useAutoDetect: boolean;

		constructor();
	}

	interface VcVirtualPointingDeviceHostChoice
	{
		readonly _autodetect: String;
		readonly _intellimouseExplorer: String;
		readonly _intellimousePs2: String;
		readonly _logitechMouseman: String;
		readonly _microsoft_serial: String;
		readonly _mousemanSerial: String;
		readonly _mouseSystems: String;
		readonly _ps2: String;
		readonly autodetect: VcVirtualPointingDeviceHostChoice;
		readonly id: String;
		readonly intellimouseExplorer: VcVirtualPointingDeviceHostChoice;
		readonly intellimousePs2: VcVirtualPointingDeviceHostChoice;
		readonly logitechMouseman: VcVirtualPointingDeviceHostChoice;
		readonly microsoft_serial: VcVirtualPointingDeviceHostChoice;
		readonly mousemanSerial: VcVirtualPointingDeviceHostChoice;
		readonly mouseSystems: VcVirtualPointingDeviceHostChoice;
		readonly name: String;
		readonly ps2: VcVirtualPointingDeviceHostChoice;
		readonly value: String;

		fromString(value?: String): VcVirtualPointingDeviceHostChoice;
	}

	interface VcVirtualPointingDeviceHostChoiceConstructor {
		new(value?:any): VcVirtualPointingDeviceHostChoice;
		readonly prototype: VcVirtualPointingDeviceHostChoice;
	}

	declare const VcVirtualPointingDeviceHostChoice: VcVirtualPointingDeviceHostChoiceConstructor;

	declare class VcVirtualPointingDeviceOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualPS2Controller
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualPS2ControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numKeyboards: VcIntOption;
		numPointingDevices: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
	}

	declare class VcVirtualResourcePoolSpec
	{
		changeVersion: Number;
		cpuAllocation: VcVrpResourceAllocationInfo;
		description: String;
		hubList: VcManagedEntity[];
		memoryAllocation: VcVrpResourceAllocationInfo;
		rootVRP: boolean;
		rpList: VcManagedEntity[];
		staticVRP: boolean;
		vrpId: String;
		vrpName: String;

		constructor();
	}

	declare class VcVirtualResourcePoolUsage
	{
		cpuReservationMhz: Number;
		cpuReservationUsedMhz: Number;
		memReservationMB: Number;
		memReservationUsedMB: Number;
		vrpId: String;

		constructor();
	}

	declare class VcVirtualSATAController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualSATAControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSATACdroms: VcIntOption;
		numSATADisks: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
	}

	declare class VcVirtualSCSIController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		hotAddRemove: boolean;
		key: Number;
		scsiCtlrUnitNumber: Number;
		sharedBus: VcVirtualSCSISharing;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualSCSIControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		defaultSharedIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotAddRemove: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numSCSICdroms: VcIntOption;
		numSCSIDisks: VcIntOption;
		numSCSIPassthrough: VcIntOption;
		plugAndPlay: boolean;
		scsiCtlrUnitNumber: Number;
		sharing: VcVirtualSCSISharing[];
		supportedDevice: String[];
		type: String;

		constructor();
	}

	declare class VcVirtualSCSIPassthrough
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualSCSIPassthroughDeviceBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualSCSIPassthroughDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualSCSIPassthroughOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	interface VcVirtualSCSISharing
	{
		readonly _noSharing: String;
		readonly _physicalSharing: String;
		readonly _virtualSharing: String;
		readonly id: String;
		readonly name: String;
		readonly noSharing: VcVirtualSCSISharing;
		readonly physicalSharing: VcVirtualSCSISharing;
		readonly value: String;
		readonly virtualSharing: VcVirtualSCSISharing;

		fromString(value?: String): VcVirtualSCSISharing;
	}

	interface VcVirtualSCSISharingConstructor {
		new(value?:any): VcVirtualSCSISharing;
		readonly prototype: VcVirtualSCSISharing;
	}

	declare const VcVirtualSCSISharing: VcVirtualSCSISharingConstructor;

	declare class VcVirtualSerialPort
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		yieldOnPoll: boolean;

		constructor();
	}

	declare class VcVirtualSerialPortDeviceBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualSerialPortDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	interface VcVirtualSerialPortEndPoint
	{
		readonly _client: String;
		readonly _server: String;
		readonly client: VcVirtualSerialPortEndPoint;
		readonly id: String;
		readonly name: String;
		readonly server: VcVirtualSerialPortEndPoint;
		readonly value: String;

		fromString(value?: String): VcVirtualSerialPortEndPoint;
	}

	interface VcVirtualSerialPortEndPointConstructor {
		new(value?:any): VcVirtualSerialPortEndPoint;
		readonly prototype: VcVirtualSerialPortEndPoint;
	}

	declare const VcVirtualSerialPortEndPoint: VcVirtualSerialPortEndPointConstructor;

	declare class VcVirtualSerialPortFileBackingInfo
	{
		backingObjectId: String;
		datastore: VcDatastore;
		fileName: String;

		constructor();
	}

	declare class VcVirtualSerialPortFileBackingOption
	{
		fileNameExtensions: VcChoiceOption;
		type: String;

		constructor();
	}

	declare class VcVirtualSerialPortOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;
		yieldOnPoll: VcBoolOption;

		constructor();
	}

	declare class VcVirtualSerialPortPipeBackingInfo
	{
		endpoint: String;
		noRxLoss: boolean;
		pipeName: String;

		constructor();
	}

	declare class VcVirtualSerialPortPipeBackingOption
	{
		endpoint: VcChoiceOption;
		noRxLoss: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualSerialPortThinPrintBackingInfo
	{

		constructor();
	}

	declare class VcVirtualSerialPortThinPrintBackingOption
	{
		type: String;

		constructor();
	}

	declare class VcVirtualSerialPortURIBackingInfo
	{
		direction: String;
		proxyURI: String;
		serviceURI: String;

		constructor();
	}

	declare class VcVirtualSerialPortURIBackingOption
	{
		directions: VcChoiceOption;
		type: String;

		constructor();
	}

	declare class VcVirtualSIOController
	{
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualSIOControllerOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numFloppyDrives: VcIntOption;
		numParallelPorts: VcIntOption;
		numSerialPorts: VcIntOption;
		plugAndPlay: boolean;
		supportedDevice: String[];
		type: String;

		constructor();
	}

	declare class VcVirtualSoundBlaster16
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualSoundBlaster16Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualSoundCard
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualSoundCardDeviceBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualSoundCardDeviceBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualSoundCardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualSriovEthernetCard
	{
		addressType: String;
		allowGuestOSMtuChange: boolean;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		sriovBacking: VcVirtualSriovEthernetCardSriovBackingInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
	}

	declare class VcVirtualSriovEthernetCardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
	}

	declare class VcVirtualSriovEthernetCardSriovBackingInfo
	{
		physicalFunctionBacking: VcVirtualPCIPassthroughDeviceBackingInfo;
		virtualFunctionBacking: VcVirtualPCIPassthroughDeviceBackingInfo;
		virtualFunctionIndex: Number;

		constructor();
	}

	declare class VcVirtualSriovEthernetCardSriovBackingOption
	{
		type: String;

		constructor();
	}

	declare class VcVirtualSwitchProfile
	{
		enabled: boolean;
		key: String;
		link: VcLinkProfile;
		name: String;
		networkPolicy: VcNetworkPolicyProfile;
		numPorts: VcNumPortsProfile;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcVirtualSwitchSelectionProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcVirtualUSB
	{
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		connected: boolean;
		controllerKey: Number;
		deviceInfo: VcDescription;
		family: String[];
		key: Number;
		product: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		speed: String[];
		unitNumber: Number;
		vendor: Number;

		constructor();
	}

	declare class VcVirtualUSBController
	{
		autoConnectDevices: boolean;
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		ehciEnabled: boolean;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualUSBControllerOption
	{
		autoAssignController: VcBoolOption;
		autoConnectDevices: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		ehciSupported: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		supportedDevice: String[];
		supportedSpeeds: String[];
		type: String;

		constructor();
	}

	declare class VcVirtualUSBControllerPciBusSlotInfo
	{
		ehciPciSlotNumber: Number;
		pciSlotNumber: Number;

		constructor();
	}

	declare class VcVirtualUSBOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualUSBRemoteClientBackingInfo
	{
		deviceName: String;
		hostname: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualUSBRemoteClientBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualUSBRemoteHostBackingInfo
	{
		deviceName: String;
		hostname: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualUSBRemoteHostBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualUSBUSBBackingInfo
	{
		deviceName: String;
		useAutoDetect: boolean;

		constructor();
	}

	declare class VcVirtualUSBUSBBackingOption
	{
		autoDetectAvailable: VcBoolOption;
		type: String;

		constructor();
	}

	declare class VcVirtualUSBXHCIController
	{
		autoConnectDevices: boolean;
		backing: VcVirtualDeviceBackingInfo;
		busNumber: Number;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		device: Number[];
		deviceInfo: VcDescription;
		key: Number;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;

		constructor();
	}

	declare class VcVirtualUSBXHCIControllerOption
	{
		autoAssignController: VcBoolOption;
		autoConnectDevices: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		devices: VcIntOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		supportedDevice: String[];
		supportedSpeeds: String[];
		type: String;

		constructor();
	}

	declare class VcVirtualVideoCardOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		graphicsMemorySizeInKB: VcLongOption;
		graphicsMemorySizeSupported: VcBoolOption;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		numDisplays: VcIntOption;
		plugAndPlay: boolean;
		support3D: VcBoolOption;
		supportMPT: VcBoolOption;
		type: String;
		use3dRendererSupported: VcBoolOption;
		useAutoDetect: VcBoolOption;
		videoRamSizeInKB: VcLongOption;

		constructor();
	}

	declare class VcVirtualVMIROMOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		plugAndPlay: boolean;
		type: String;

		constructor();
	}

	declare class VcVirtualVmxnet
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
	}

	declare class VcVirtualVmxnet2
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
	}

	declare class VcVirtualVmxnet2Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
	}

	declare class VcVirtualVmxnet3
	{
		addressType: String;
		backing: VcVirtualDeviceBackingInfo;
		connectable: VcVirtualDeviceConnectInfo;
		controllerKey: Number;
		deviceInfo: VcDescription;
		externalId: String;
		key: Number;
		macAddress: String;
		resourceAllocation: VcVirtualEthernetCardResourceAllocation;
		slotInfo: VcVirtualDeviceBusSlotInfo;
		unitNumber: Number;
		uptCompatibilityEnabled: boolean;
		wakeOnLanEnabled: boolean;

		constructor();
	}

	declare class VcVirtualVmxnet3Option
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
	}

	declare class VcVirtualVmxnetOption
	{
		autoAssignController: VcBoolOption;
		backingOption: VcVirtualDeviceBackingOption[];
		busSlotOption: VcVirtualDeviceBusSlotOption;
		connectOption: VcVirtualDeviceConnectOption;
		controllerType: String;
		defaultBackingOptionIndex: Number;
		deprecated: boolean;
		hotRemoveSupported: boolean;
		licensingLimit: String[];
		macType: VcChoiceOption;
		plugAndPlay: boolean;
		supportedOUI: VcChoiceOption;
		type: String;
		uptCompatibilityEnabled: VcBoolOption;
		vmDirectPathGen2Supported: boolean;
		wakeOnLanEnabled: VcBoolOption;

		constructor();
	}

	declare class VcVlanProfile
	{
		enabled: boolean;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];

		constructor();
	}

	declare class VcVmAcquiredMksTicketEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmAcquiredTicketEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		ticketType: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmAutoRenameEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmBeingClonedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destFolder: VcFolderEventArgument;
		destHost: VcHostEventArgument;
		destName: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmBeingClonedNoFolderEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destHost: VcHostEventArgument;
		destName: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmBeingCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configSpec: VcVirtualMachineConfigSpec;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmBeingDeployedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		srcTemplate: VcVmEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmBeingHotMigratedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatacenter: VcDatacenterEventArgument;
		destDatastore: VcDatastoreEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmBeingMigratedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatacenter: VcDatacenterEventArgument;
		destDatastore: VcDatastoreEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmBeingRelocatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatacenter: VcDatacenterEventArgument;
		destDatastore: VcDatastoreEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmClonedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceVm: VcVmEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmCloneEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmCloneFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destFolder: VcFolderEventArgument;
		destHost: VcHostEventArgument;
		destName: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmConfigFileInfo
	{
		configVersion: Number;
		fileSize: Number;
		modification: Date;
		owner: String;
		path: String;

		constructor();
	}

	declare class VcVmConfigFileQuery
	{
		details: VcVmConfigFileQueryFlags;
		filter: VcVmConfigFileQueryFilter;

		constructor();
	}

	declare class VcVmConfigFileQueryFilter
	{
		matchConfigVersion: Number[];

		constructor();
	}

	declare class VcVmConfigFileQueryFlags
	{
		configVersion: boolean;

		constructor();
	}

	declare class VcVmConfigInfo
	{
		eula: String[];
		installBootRequired: boolean;
		installBootStopDelay: Number;
		ipAssignment: VcVAppIPAssignmentInfo;
		ovfEnvironmentTransport: String[];
		ovfSection: VcVAppOvfSectionInfo[];
		product: VcVAppProductInfo[];
		property: VcVAppPropertyInfo[];

		constructor();
	}

	declare class VcVmConfigMissingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmConfigSpec
	{
		eula: String[];
		installBootRequired: boolean;
		installBootStopDelay: Number;
		ipAssignment: VcVAppIPAssignmentInfo;
		ovfEnvironmentTransport: String[];
		ovfSection: VcVAppOvfSectionSpec[];
		product: VcVAppProductSpec[];
		property: VcVAppPropertySpec[];

		constructor();
	}

	declare class VcVmConnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDasBeingResetEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcVmDasBeingResetEventReasonCode
	{
		readonly _appHeartbeatFailure: String;
		readonly _appImmediateResetRequest: String;
		readonly _vmcpResetApdCleared: String;
		readonly _vmtoolsHeartbeatFailure: String;
		readonly appHeartbeatFailure: VcVmDasBeingResetEventReasonCode;
		readonly appImmediateResetRequest: VcVmDasBeingResetEventReasonCode;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly vmcpResetApdCleared: VcVmDasBeingResetEventReasonCode;
		readonly vmtoolsHeartbeatFailure: VcVmDasBeingResetEventReasonCode;

		fromString(value?: String): VcVmDasBeingResetEventReasonCode;
	}

	interface VcVmDasBeingResetEventReasonCodeConstructor {
		new(value?:any): VcVmDasBeingResetEventReasonCode;
		readonly prototype: VcVmDasBeingResetEventReasonCode;
	}

	declare const VcVmDasBeingResetEventReasonCode: VcVmDasBeingResetEventReasonCodeConstructor;

	declare class VcVmDasBeingResetWithScreenshotEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		screenshotFilePath: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDasResetFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDasUpdateErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDasUpdateOkEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDateRolledBackEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDeployedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		srcTemplate: VcVmEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDeployFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatastore: VcEntityEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDisconnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDiscoveredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDiskFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		disk: String;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmDiskFileInfo
	{
		capacityKb: Number;
		controllerType: String;
		diskExtents: String[];
		diskType: String;
		fileSize: Number;
		hardwareVersion: Number;
		modification: Date;
		owner: String;
		path: String;
		thin: boolean;

		constructor();
	}

	declare class VcVmDiskFileQuery
	{
		details: VcVmDiskFileQueryFlags;
		filter: VcVmDiskFileQueryFilter;

		constructor();
	}

	declare class VcVmDiskFileQueryFilter
	{
		controllerType: String[];
		diskType: String[];
		matchHardwareVersion: Number[];
		thin: boolean;

		constructor();
	}

	declare class VcVmDiskFileQueryFlags
	{
		capacityKb: boolean;
		controllerType: boolean;
		diskExtents: boolean;
		diskType: boolean;
		hardwareVersion: boolean;
		thin: boolean;

		constructor();
	}

	declare class VcVmDVPortEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		eventType: String;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		portKey: String;
		switchUuid: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcVmDVPortEventEventCode
	{
		readonly _blocked: String;
		readonly _connected: String;
		readonly _created: String;
		readonly _deleted: String;
		readonly _disconnected: String;
		readonly _joinedPortgroup: String;
		readonly _leftPortgroup: String;
		readonly _linkdown: String;
		readonly _linkup: String;
		readonly _reconfigured: String;
		readonly _unblocked: String;
		readonly blocked: VcVmDVPortEventEventCode;
		readonly connected: VcVmDVPortEventEventCode;
		readonly created: VcVmDVPortEventEventCode;
		readonly deleted: VcVmDVPortEventEventCode;
		readonly disconnected: VcVmDVPortEventEventCode;
		readonly id: String;
		readonly joinedPortgroup: VcVmDVPortEventEventCode;
		readonly leftPortgroup: VcVmDVPortEventEventCode;
		readonly linkdown: VcVmDVPortEventEventCode;
		readonly linkup: VcVmDVPortEventEventCode;
		readonly name: String;
		readonly reconfigured: VcVmDVPortEventEventCode;
		readonly unblocked: VcVmDVPortEventEventCode;
		readonly value: String;

		fromString(value?: String): VcVmDVPortEventEventCode;
	}

	interface VcVmDVPortEventEventCodeConstructor {
		new(value?:any): VcVmDVPortEventEventCode;
		readonly prototype: VcVmDVPortEventEventCode;
	}

	declare const VcVmDVPortEventEventCode: VcVmDVPortEventEventCodeConstructor;

	declare class VcVmEmigratingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmEndRecordingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmEndReplayingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmEventArgument
	{
		name: String;
		vm: VcVirtualMachine;

		constructor();
	}

	declare class VcVmFailedMigrateEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatacenter: VcDatacenterEventArgument;
		destDatastore: VcDatastoreEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailedRelayoutEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailedRelayoutOnVmfs2DatastoreEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailedStartingSecondaryEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcVmFailedStartingSecondaryEventFailureReason
	{
		readonly _incompatibleHost: String;
		readonly _loginFailed: String;
		readonly _migrateFailed: String;
		readonly _registerVmFailed: String;
		readonly id: String;
		readonly incompatibleHost: VcVmFailedStartingSecondaryEventFailureReason;
		readonly loginFailed: VcVmFailedStartingSecondaryEventFailureReason;
		readonly migrateFailed: VcVmFailedStartingSecondaryEventFailureReason;
		readonly name: String;
		readonly registerVmFailed: VcVmFailedStartingSecondaryEventFailureReason;
		readonly value: String;

		fromString(value?: String): VcVmFailedStartingSecondaryEventFailureReason;
	}

	interface VcVmFailedStartingSecondaryEventFailureReasonConstructor {
		new(value?:any): VcVmFailedStartingSecondaryEventFailureReason;
		readonly prototype: VcVmFailedStartingSecondaryEventFailureReason;
	}

	declare const VcVmFailedStartingSecondaryEventFailureReason: VcVmFailedStartingSecondaryEventFailureReasonConstructor;

	declare class VcVmFailedToPowerOffEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailedToPowerOnEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailedToRebootGuestEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailedToResetEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailedToShutdownGuestEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailedToStandbyGuestEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailedToSuspendEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailedUpdatingSecondaryConfig
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFailoverFailed
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcVmFaultToleranceConfigIssueReasonForIssue
	{
		readonly _cpuHvDisabled: String;
		readonly _cpuHvUnsupported: String;
		readonly _cpuHwmmuUnsupported: String;
		readonly _esxAgentVm: String;
		readonly _ftSecondaryVm: String;
		readonly _ftUnsupportedHardware: String;
		readonly _ftUnsupportedProduct: String;
		readonly _haNotEnabled: String;
		readonly _hasEFIFirmware: String;
		readonly _hasLocalDisk: String;
		readonly _hasNestedHVConfiguration: String;
		readonly _hasSnapshots: String;
		readonly _hasUnsupportedDisk: String;
		readonly _hasVFlashConfiguration: String;
		readonly _hostInactive: String;
		readonly _insufficientBandwidth: String;
		readonly _missingFTLoggingNic: String;
		readonly _missingVMotionNic: String;
		readonly _moreThanOneSecondary: String;
		readonly _multipleVCPU: String;
		readonly _noConfig: String;
		readonly _recordReplayNotSupported: String;
		readonly _replayNotSupported: String;
		readonly _templateVm: String;
		readonly _thinDisk: String;
		readonly _unsupportedProduct: String;
		readonly _verifySSLCertificateFlagNotSet: String;
		readonly _video3dEnabled: String;
		readonly cpuHvDisabled: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly cpuHvUnsupported: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly cpuHwmmuUnsupported: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly esxAgentVm: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly ftSecondaryVm: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly ftUnsupportedHardware: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly ftUnsupportedProduct: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly haNotEnabled: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasEFIFirmware: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasLocalDisk: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasNestedHVConfiguration: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasSnapshots: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasUnsupportedDisk: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hasVFlashConfiguration: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly hostInactive: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly id: String;
		readonly insufficientBandwidth: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly missingFTLoggingNic: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly missingVMotionNic: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly moreThanOneSecondary: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly multipleVCPU: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly name: String;
		readonly noConfig: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly recordReplayNotSupported: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly replayNotSupported: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly templateVm: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly thinDisk: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly unsupportedProduct: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly value: String;
		readonly verifySSLCertificateFlagNotSet: VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly video3dEnabled: VcVmFaultToleranceConfigIssueReasonForIssue;

		fromString(value?: String): VcVmFaultToleranceConfigIssueReasonForIssue;
	}

	interface VcVmFaultToleranceConfigIssueReasonForIssueConstructor {
		new(value?:any): VcVmFaultToleranceConfigIssueReasonForIssue;
		readonly prototype: VcVmFaultToleranceConfigIssueReasonForIssue;
	}

	declare const VcVmFaultToleranceConfigIssueReasonForIssue: VcVmFaultToleranceConfigIssueReasonForIssueConstructor;

	interface VcVmFaultToleranceInvalidFileBackingDeviceType
	{
		readonly _virtualCdrom: String;
		readonly _virtualDisk: String;
		readonly _virtualFloppy: String;
		readonly _virtualParallelPort: String;
		readonly _virtualSerialPort: String;
		readonly id: String;
		readonly name: String;
		readonly value: String;
		readonly virtualCdrom: VcVmFaultToleranceInvalidFileBackingDeviceType;
		readonly virtualDisk: VcVmFaultToleranceInvalidFileBackingDeviceType;
		readonly virtualFloppy: VcVmFaultToleranceInvalidFileBackingDeviceType;
		readonly virtualParallelPort: VcVmFaultToleranceInvalidFileBackingDeviceType;
		readonly virtualSerialPort: VcVmFaultToleranceInvalidFileBackingDeviceType;

		fromString(value?: String): VcVmFaultToleranceInvalidFileBackingDeviceType;
	}

	interface VcVmFaultToleranceInvalidFileBackingDeviceTypeConstructor {
		new(value?:any): VcVmFaultToleranceInvalidFileBackingDeviceType;
		readonly prototype: VcVmFaultToleranceInvalidFileBackingDeviceType;
	}

	declare const VcVmFaultToleranceInvalidFileBackingDeviceType: VcVmFaultToleranceInvalidFileBackingDeviceTypeConstructor;

	declare class VcVmFaultToleranceStateChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newState: VcVirtualMachineFaultToleranceState;
		oldState: VcVirtualMachineFaultToleranceState;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFaultToleranceTurnedOffEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmFaultToleranceVmTerminatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmfsDatastoreAllExtentOption
	{
		layout: VcHostDiskPartitionLayout;
		partitionFormatChange: boolean;
		vmfsExtent: VcHostDiskPartitionBlockRange;

		constructor();
	}

	declare class VcVmfsDatastoreBaseOption
	{
		layout: VcHostDiskPartitionLayout;
		partitionFormatChange: boolean;

		constructor();
	}

	declare class VcVMFSDatastoreCreatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmfsDatastoreCreateSpec
	{
		diskUuid: String;
		extent: VcHostScsiDiskPartition[];
		partition: VcHostDiskPartitionSpec;
		vmfs: VcHostVmfsSpec;

		constructor();
	}

	declare class VcVMFSDatastoreExpandedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmfsDatastoreExpandSpec
	{
		diskUuid: String;
		extent: VcHostScsiDiskPartition;
		partition: VcHostDiskPartitionSpec;

		constructor();
	}

	declare class VcVMFSDatastoreExtendedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		datastore: VcDatastoreEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmfsDatastoreExtendSpec
	{
		diskUuid: String;
		extent: VcHostScsiDiskPartition[];
		partition: VcHostDiskPartitionSpec;

		constructor();
	}

	declare class VcVmfsDatastoreInfo
	{
		containerId: String;
		freeSpace: Number;
		lun: VcVmfsDatastoreInfoScsiLunInfo[];
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxPhysicalRDMFileSize: Number;
		maxVirtualDiskCapacity: Number;
		maxVirtualRDMFileSize: Number;
		name: String;
		timestamp: Date;
		url: String;
		vmfs: VcHostVmfsVolume;

		constructor();
	}

	declare class VcVmfsDatastoreInfoScsiLunInfo
	{
		canonicalName: String;
		key: String;
		uuid: String;

		constructor();
	}

	declare class VcVmfsDatastoreMultipleExtentOption
	{
		layout: VcHostDiskPartitionLayout;
		partitionFormatChange: boolean;
		vmfsExtent: VcHostDiskPartitionBlockRange[];

		constructor();
	}

	declare class VcVmfsDatastoreOption
	{
		info: VcVmfsDatastoreBaseOption;
		spec: VcVmfsDatastoreSpec;

		constructor();
	}

	declare class VcVmfsDatastoreSingleExtentOption
	{
		layout: VcHostDiskPartitionLayout;
		partitionFormatChange: boolean;
		vmfsExtent: VcHostDiskPartitionBlockRange;

		constructor();
	}

	declare class VcVmfsDatastoreSpec
	{
		diskUuid: String;

		constructor();
	}

	declare class VcVmGuestOSCrashedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmGuestRebootEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmGuestShutdownEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmGuestStandbyEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmHealthMonitoringStateChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		state: String;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmInstanceUuidAssignedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		instanceUuid: String;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmInstanceUuidChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newInstanceUuid: String;
		oldInstanceUuid: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmInstanceUuidConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedVm: VcVmEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		instanceUuid: String;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmLogFileInfo
	{
		fileSize: Number;
		modification: Date;
		owner: String;
		path: String;

		constructor();
	}

	declare class VcVmLogFileQuery
	{

		constructor();
	}

	declare class VcVmMacAssignedEvent
	{
		adapter: String;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		mac: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmMacChangedEvent
	{
		adapter: String;
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newMac: String;
		oldMac: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmMacConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedVm: VcVmEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		mac: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmMaxFTRestartCountReached
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmMaxRestartCountReached
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmMessageErrorEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		messageInfo: VcVirtualMachineMessage[];
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmMessageEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		messageInfo: VcVirtualMachineMessage[];
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmMessageWarningEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		messageInfo: VcVirtualMachineMessage[];
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmMigratedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDatacenter: VcDatacenterEventArgument;
		sourceDatastore: VcDatastoreEventArgument;
		sourceHost: VcHostEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmNoCompatibleHostForSecondaryEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmNoNetworkAccessEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmNvramFileInfo
	{
		fileSize: Number;
		modification: Date;
		owner: String;
		path: String;

		constructor();
	}

	declare class VcVmNvramFileQuery
	{

		constructor();
	}

	declare class VcVmOrphanedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcVMotionCompatibilityType
	{
		readonly _cpu: String;
		readonly _software: String;
		readonly cpu: VcVMotionCompatibilityType;
		readonly id: String;
		readonly name: String;
		readonly software: VcVMotionCompatibilityType;
		readonly value: String;

		fromString(value?: String): VcVMotionCompatibilityType;
	}

	interface VcVMotionCompatibilityTypeConstructor {
		new(value?:any): VcVMotionCompatibilityType;
		readonly prototype: VcVMotionCompatibilityType;
	}

	declare const VcVMotionCompatibilityType: VcVMotionCompatibilityTypeConstructor;

	declare class VcVMotionLicenseExpiredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmPodConfigForPlacement
	{
		disk: VcPodDiskLocator[];
		interVmRule: VcClusterRuleInfo[];
		storagePod: VcStoragePod;
		vmConfig: VcStorageDrsVmConfigInfo;

		constructor();
	}

	declare class VcVmPortGroupProfile
	{
		enabled: boolean;
		key: String;
		name: String;
		networkPolicy: VcNetworkPolicyProfile;
		policy: VcProfilePolicy[];
		profileTypeName: String;
		profileVersion: String;
		property: VcProfileApplyProfileProperty[];
		vlan: VcVlanProfile;
		vswitch: VcVirtualSwitchSelectionProfile;

		constructor();
	}

	declare class VcVmPoweredOffEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmPoweredOnEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmPoweringOnWithCustomizedDVPortEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;
		vnic: VcVnicPortArgument[];

		constructor();
	}

	declare class VcVmPowerOffOnIsolationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		isolatedHost: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmPrimaryFailoverEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmReconfiguredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configSpec: VcVirtualMachineConfigSpec;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRegisteredEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRelayoutSuccessfulEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRelayoutUpToDateEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmReloadFromPathEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configPath: String;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmReloadFromPathFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		configPath: String;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRelocatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceDatacenter: VcDatacenterEventArgument;
		sourceDatastore: VcDatastoreEventArgument;
		sourceHost: VcHostEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRelocateFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		destDatacenter: VcDatacenterEventArgument;
		destDatastore: VcDatastoreEventArgument;
		destHost: VcHostEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRelocateSpecEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRemoteConsoleConnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRemoteConsoleDisconnectedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRemovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRenamedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newName: String;
		oldName: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRequirementsExceedCurrentEVCModeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmResettingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmResourcePoolMovedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newParent: VcResourcePoolEventArgument;
		oldParent: VcResourcePoolEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmResourceReallocatedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmRestartedOnAlternateHostEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		sourceHost: VcHostEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmResumingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmSecondaryAddedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmSecondaryDisabledBySystemEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		reason: VcLocalizedMethodFault;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmSecondaryDisabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmSecondaryEnabledEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmSecondaryStartedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmShutdownOnIsolationEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		isolatedHost: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		shutdownResult: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	interface VcVmShutdownOnIsolationEventOperation
	{
		readonly _poweredOff: String;
		readonly _shutdown: String;
		readonly id: String;
		readonly name: String;
		readonly poweredOff: VcVmShutdownOnIsolationEventOperation;
		readonly shutdown: VcVmShutdownOnIsolationEventOperation;
		readonly value: String;

		fromString(value?: String): VcVmShutdownOnIsolationEventOperation;
	}

	interface VcVmShutdownOnIsolationEventOperationConstructor {
		new(value?:any): VcVmShutdownOnIsolationEventOperation;
		readonly prototype: VcVmShutdownOnIsolationEventOperation;
	}

	declare const VcVmShutdownOnIsolationEventOperation: VcVmShutdownOnIsolationEventOperationConstructor;

	declare class VcVmSnapshotFileInfo
	{
		fileSize: Number;
		modification: Date;
		owner: String;
		path: String;

		constructor();
	}

	declare class VcVmSnapshotFileQuery
	{

		constructor();
	}

	declare class VcVmStartingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmStartingSecondaryEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmStartRecordingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmStartReplayingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmStaticMacConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedVm: VcVmEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		mac: String;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmStoppingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmSuspendedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmSuspendingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmTimedoutStartingSecondaryEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		timeout: Number;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmUnsupportedStartingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		guestId: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmUpgradeCompleteEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		version: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmUpgradeFailedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmUpgradingEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		version: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmUuidAssignedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		uuid: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmUuidChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newUuid: String;
		oldUuid: String;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmUuidConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedVm: VcVmEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		uuid: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmVnicPoolReservationViolationClearEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;
		vmVnicResourcePoolKey: String;
		vmVnicResourcePoolName: String;

		constructor();
	}

	declare class VcVmVnicPoolReservationViolationRaiseEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;
		vmVnicResourcePoolKey: String;
		vmVnicResourcePoolName: String;

		constructor();
	}

	interface VcVmwareDistributedVirtualSwitch
	{
		alarmActionsEnabled: boolean;
		availableField: VcCustomFieldDef[];
		capability: VcDVSCapability;
		config: VcDVSConfigInfo;
		configIssue: VcEvent[];
		configStatus: VcManagedEntityStatus;
		customValue: VcCustomFieldValue[];
		declaredAlarmState: VcAlarmState[];
		disabledMethod: String[];
		effectiveRole: Number[];
		readonly id: String;
		name: String;
		networkResourcePool: VcDVSNetworkResourcePool[];
		overallStatus: VcManagedEntityStatus;
		parent: VcManagedEntity;
		permission: VcPermission[];
		portgroup: VcDistributedVirtualPortgroup[];
		recentTask: VcTask[];
		readonly reference: VcManagedObjectReference;
		runtime: VcDVSRuntimeInfo;
		readonly sdkConnection: VcSdkConnection;
		summary: VcDVSSummary;
		tag: VcTag[];
		triggeredAlarmState: VcAlarmState[];
		uuid: String;
		value: VcCustomFieldValue[];
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		addDVPortgroup_Task(spec?: VcDVPortgroupConfigSpec[]): VcTask;
		addNetworkResourcePool(configSpec?: VcDVSNetworkResourcePoolConfigSpec[]): void;
		createDVPortgroup_Task(spec?: VcDVPortgroupConfigSpec): VcTask;
		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		destroy_Task(): VcTask;
		DVSClearPortDbEntry_Task(portKey?: String, dbClearSpec?: VcDVSPortDbClearSpec): VcTask;
		DVSFetchPortDb(portKey?: String): VcDVSPortDbQueryResults;
		DVSQueryAvailableOverlayClass(): VcDVSOverlayClassConfigInfo[];
		DVSReconfigureOverlayInstance_Task(configSpec?: VcDVSOverlayInstanceConfigSpec[]): VcTask;
		dvsReconfigureVmVnicNetworkResourcePool_Task(configSpec?: VcDvsVmVnicResourcePoolConfigSpec[]): VcTask;
		DVSRollback_Task(entityBackup?: VcEntityBackupConfig): VcTask;
		enableNetworkResourceManagement(enable?: boolean): void;
		fetchDVPortKeys(criteria?: VcDistributedVirtualSwitchPortCriteria): String[];
		fetchDVPorts(criteria?: VcDistributedVirtualSwitchPortCriteria): VcDistributedVirtualPort[];
		lookupDvPortGroup(portgroupKey?: String): VcDistributedVirtualPortgroup;
		mergeDvs_Task(dvs?: VcDistributedVirtualSwitch): VcTask;
		moveDVPort_Task(portKey?: String[], destinationPortgroupKey?: String): VcTask;
		performDvsProductSpecOperation_Task(operation?: String, productSpec?: VcDistributedVirtualSwitchProductSpec): VcTask;
		queryUsedVlanIdInDvs(): Number[];
		reconfigureDVPort_Task(port?: VcDVPortConfigSpec[]): VcTask;
		reconfigureDvs_Task(spec?: VcDVSConfigSpec): VcTask;
		rectifyDvsHost_Task(hosts?: VcHostSystem[]): VcTask;
		refreshDVPortState(portKeys?: String[]): void;
		reload(): void;
		removeNetworkResourcePool(key?: String[]): void;
		rename_Task(newName?: String): VcTask;
		setCustomValue(key?: String, value?: String): void;
		updateDvsCapability(capability?: VcDVSCapability): void;
		updateDVSHealthCheckConfig_Task(healthCheckConfig?: VcDVSHealthCheckConfig[]): VcTask;
		updateDVSLacpGroupConfig_Task(lacpGroupSpec?: VcVMwareDvsLacpGroupSpec[]): VcTask;
		updateNetworkResourcePool(configSpec?: VcDVSNetworkResourcePoolConfigSpec[]): void;
	}

	declare const VcVmwareDistributedVirtualSwitch: VcVmwareDistributedVirtualSwitch;

	interface VcVmwareDistributedVirtualSwitchPvlanPortType
	{
		readonly _community: String;
		readonly _isolated: String;
		readonly _promiscuous: String;
		readonly community: VcVmwareDistributedVirtualSwitchPvlanPortType;
		readonly id: String;
		readonly isolated: VcVmwareDistributedVirtualSwitchPvlanPortType;
		readonly name: String;
		readonly promiscuous: VcVmwareDistributedVirtualSwitchPvlanPortType;
		readonly value: String;

		fromString(value?: String): VcVmwareDistributedVirtualSwitchPvlanPortType;
	}

	interface VcVmwareDistributedVirtualSwitchPvlanPortTypeConstructor {
		new(value?:any): VcVmwareDistributedVirtualSwitchPvlanPortType;
		readonly prototype: VcVmwareDistributedVirtualSwitchPvlanPortType;
	}

	declare const VcVmwareDistributedVirtualSwitchPvlanPortType: VcVmwareDistributedVirtualSwitchPvlanPortTypeConstructor;

	declare class VcVmwareDistributedVirtualSwitchPvlanSpec
	{
		inherited: boolean;
		pvlanId: Number;

		constructor();
	}

	declare class VcVmwareDistributedVirtualSwitchTrunkVlanSpec
	{
		inherited: boolean;
		vlanId: VcNumericRange[];

		constructor();
	}

	declare class VcVmwareDistributedVirtualSwitchVlanIdSpec
	{
		inherited: boolean;
		vlanId: Number;

		constructor();
	}

	declare class VcVmwareDistributedVirtualSwitchVlanSpec
	{
		inherited: boolean;

		constructor();
	}

	declare class VcVMwareDVSConfigInfo
	{
		configVersion: String;
		contact: VcDVSContactInfo;
		createTime: Date;
		defaultPortConfig: VcDVPortSetting;
		defaultProxySwitchMaxNumPorts: Number;
		description: String;
		extensionKey: String;
		healthCheckConfig: VcDVSHealthCheckConfig[];
		host: VcDistributedVirtualSwitchHostMember[];
		infrastructureTrafficResourceConfig: VcDvsHostInfrastructureTrafficResource[];
		ipfixConfig: VcVMwareIpfixConfig;
		lacpApiVersion: String;
		lacpGroupConfig: VcVMwareDvsLacpGroupConfig[];
		linkDiscoveryProtocolConfig: VcLinkDiscoveryProtocolConfig;
		maxMtu: Number;
		maxPorts: Number;
		multicastFilteringMode: String;
		name: String;
		networkResourceControlVersion: String;
		networkResourceManagementEnabled: boolean;
		numPorts: Number;
		numStandalonePorts: Number;
		overlayInstance: VcDVSOverlayInstanceConfigInfo[];
		pnicCapacityRatioForReservation: Number;
		policy: VcDVSPolicy;
		productInfo: VcDistributedVirtualSwitchProductSpec;
		pvlanConfig: VcVMwareDVSPvlanMapEntry[];
		switchIpAddress: String;
		targetInfo: VcDistributedVirtualSwitchProductSpec;
		uplinkPortgroup: VcDistributedVirtualPortgroup[];
		uplinkPortPolicy: VcDVSUplinkPortPolicy;
		uuid: String;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vmVnicNetworkResourcePool: VcDVSVmVnicNetworkResourcePool[];
		vspanSession: VcVMwareVspanSession[];

		constructor();
	}

	declare class VcVMwareDVSConfigSpec
	{
		configVersion: String;
		contact: VcDVSContactInfo;
		defaultPortConfig: VcDVPortSetting;
		defaultProxySwitchMaxNumPorts: Number;
		description: String;
		extensionKey: String;
		host: VcDistributedVirtualSwitchHostMemberConfigSpec[];
		infrastructureTrafficResourceConfig: VcDvsHostInfrastructureTrafficResource[];
		ipfixConfig: VcVMwareIpfixConfig;
		lacpApiVersion: String;
		linkDiscoveryProtocolConfig: VcLinkDiscoveryProtocolConfig;
		maxMtu: Number;
		maxPorts: Number;
		multicastFilteringMode: String;
		name: String;
		networkResourceControlVersion: String;
		numStandalonePorts: Number;
		policy: VcDVSPolicy;
		pvlanConfigSpec: VcVMwareDVSPvlanConfigSpec[];
		switchIpAddress: String;
		uplinkPortgroup: VcDistributedVirtualPortgroup[];
		uplinkPortPolicy: VcDVSUplinkPortPolicy;
		vendorSpecificConfig: VcDistributedVirtualSwitchKeyedOpaqueBlob[];
		vspanConfigSpec: VcVMwareDVSVspanConfigSpec[];

		constructor();
	}

	declare class VcVMwareDVSFeatureCapability
	{
		backupRestoreCapability: VcDVSBackupRestoreCapability;
		healthCheckCapability: VcDVSHealthCheckCapability;
		ipfixCapability: VcVMwareDvsIpfixCapability;
		ipfixSupported: boolean;
		lacpCapability: VcVMwareDvsLacpCapability;
		lldpSupported: boolean;
		multicastSnoopingSupported: boolean;
		networkFilterSupported: boolean;
		networkResourceManagementCapability: VcDVSNetworkResourceManagementCapability;
		networkResourceManagementSupported: boolean;
		networkResourcePoolHighShareValue: Number;
		nicTeamingPolicy: String[];
		overlayFeatureCapability: VcDistributedVirtualSwitchOverlayFeatureSpec;
		overlaySupported: boolean;
		rollbackCapability: VcDVSRollbackCapability;
		statefulFirewallCapability: VcDvsStatefulFirewallFeatureCapability;
		switchSecurityCapability: VcDVSSwitchSecurityFeatureCapability;
		vmDirectPathGen2Supported: boolean;
		vspanCapability: VcVMwareDVSVspanCapability;
		vspanSupported: boolean;

		constructor();
	}

	declare class VcVMwareDVSHealthCheckCapability
	{
		teamingSupported: boolean;
		vlanMtuSupported: boolean;

		constructor();
	}

	declare class VcVMwareDVSHealthCheckConfig
	{
		enable: boolean;
		interval: Number;

		constructor();
	}

	declare class VcVMwareDvsIpfixCapability
	{
		ipfixSupported: boolean;
		ipv6ForIpfixSupported: boolean;
		observationDomainIdSupported: boolean;

		constructor();
	}

	interface VcVMwareDvsLacpApiVersion
	{
		readonly _multipleLag: String;
		readonly _singleLag: String;
		readonly id: String;
		readonly multipleLag: VcVMwareDvsLacpApiVersion;
		readonly name: String;
		readonly singleLag: VcVMwareDvsLacpApiVersion;
		readonly value: String;

		fromString(value?: String): VcVMwareDvsLacpApiVersion;
	}

	interface VcVMwareDvsLacpApiVersionConstructor {
		new(value?:any): VcVMwareDvsLacpApiVersion;
		readonly prototype: VcVMwareDvsLacpApiVersion;
	}

	declare const VcVMwareDvsLacpApiVersion: VcVMwareDvsLacpApiVersionConstructor;

	declare class VcVMwareDvsLacpCapability
	{
		lacpSupported: boolean;
		multiLacpGroupSupported: boolean;

		constructor();
	}

	declare class VcVMwareDvsLacpGroupConfig
	{
		ipfix: VcVMwareDvsLagIpfixConfig;
		key: String;
		loadbalanceAlgorithm: String;
		mode: String;
		name: String;
		uplinkName: String[];
		uplinkNum: Number;
		uplinkPortKey: String[];
		vlan: VcVMwareDvsLagVlanConfig;

		constructor();
	}

	declare class VcVMwareDvsLacpGroupSpec
	{
		lacpGroupConfig: VcVMwareDvsLacpGroupConfig;
		operation: String;

		constructor();
	}

	interface VcVMwareDvsLacpLoadBalanceAlgorithm
	{
		readonly _destIp: String;
		readonly _destIpTcpUdpPort: String;
		readonly _destIpTcpUdpPortVlan: String;
		readonly _destIpVlan: String;
		readonly _destMac: String;
		readonly _destTcpUdpPort: String;
		readonly _srcDestIp: String;
		readonly _srcDestIpTcpUdpPort: String;
		readonly _srcDestIpTcpUdpPortVlan: String;
		readonly _srcDestIpVlan: String;
		readonly _srcDestMac: String;
		readonly _srcDestTcpUdpPort: String;
		readonly _srcIp: String;
		readonly _srcIpTcpUdpPort: String;
		readonly _srcIpTcpUdpPortVlan: String;
		readonly _srcIpVlan: String;
		readonly _srcMac: String;
		readonly _srcPortId: String;
		readonly _srcTcpUdpPort: String;
		readonly _vlan: String;
		readonly destIp: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly destIpTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly destIpTcpUdpPortVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly destIpVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly destMac: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly destTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly id: String;
		readonly name: String;
		readonly srcDestIp: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcDestIpTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcDestIpTcpUdpPortVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcDestIpVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcDestMac: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcDestTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcIp: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcIpTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcIpTcpUdpPortVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcIpVlan: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcMac: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcPortId: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly srcTcpUdpPort: VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly value: String;
		readonly vlan: VcVMwareDvsLacpLoadBalanceAlgorithm;

		fromString(value?: String): VcVMwareDvsLacpLoadBalanceAlgorithm;
	}

	interface VcVMwareDvsLacpLoadBalanceAlgorithmConstructor {
		new(value?:any): VcVMwareDvsLacpLoadBalanceAlgorithm;
		readonly prototype: VcVMwareDvsLacpLoadBalanceAlgorithm;
	}

	declare const VcVMwareDvsLacpLoadBalanceAlgorithm: VcVMwareDvsLacpLoadBalanceAlgorithmConstructor;

	declare class VcVMwareDvsLagIpfixConfig
	{
		ipfixEnabled: boolean;

		constructor();
	}

	declare class VcVMwareDvsLagVlanConfig
	{
		vlanId: VcNumericRange[];

		constructor();
	}

	declare class VcVMwareDVSMtuHealthCheckResult
	{
		mtuMismatch: boolean;
		summary: String;
		uplinkPortKey: String;
		vlanNotSupportSwitchMtu: VcNumericRange[];
		vlanSupportSwitchMtu: VcNumericRange[];

		constructor();
	}

	interface VcVMwareDvsMulticastFilteringMode
	{
		readonly _legacyFiltering: String;
		readonly _snooping: String;
		readonly id: String;
		readonly legacyFiltering: VcVMwareDvsMulticastFilteringMode;
		readonly name: String;
		readonly snooping: VcVMwareDvsMulticastFilteringMode;
		readonly value: String;

		fromString(value?: String): VcVMwareDvsMulticastFilteringMode;
	}

	interface VcVMwareDvsMulticastFilteringModeConstructor {
		new(value?:any): VcVMwareDvsMulticastFilteringMode;
		readonly prototype: VcVMwareDvsMulticastFilteringMode;
	}

	declare const VcVMwareDvsMulticastFilteringMode: VcVMwareDvsMulticastFilteringModeConstructor;

	declare class VcVMwareDVSPortgroupPolicy
	{
		blockOverrideAllowed: boolean;
		ipfixOverrideAllowed: boolean;
		livePortMovingAllowed: boolean;
		networkResourcePoolOverrideAllowed: boolean;
		overlayParameterOverrideAllowed: boolean;
		portConfigResetAtDisconnect: boolean;
		securityPolicyOverrideAllowed: boolean;
		shapingOverrideAllowed: boolean;
		statefulFirewallOverrideAllowed: boolean;
		switchSecurityOverrideAllowed: boolean;
		trafficFilterOverrideAllowed: boolean;
		uplinkTeamingOverrideAllowed: boolean;
		vendorConfigOverrideAllowed: boolean;
		vlanOverrideAllowed: boolean;

		constructor();
	}

	declare class VcVMwareDVSPortSetting
	{
		blocked: VcBoolPolicy;
		filterPolicy: VcDvsFilterPolicy;
		inShapingPolicy: VcDVSTrafficShapingPolicy;
		ipfixEnabled: VcBoolPolicy;
		lacpPolicy: VcVMwareUplinkLacpPolicy;
		networkResourcePoolKey: VcStringPolicy;
		outShapingPolicy: VcDVSTrafficShapingPolicy;
		overlayParameter: VcDVSoverlayParameterPolicy;
		qosTag: VcIntPolicy;
		securityPolicy: VcDVSSecurityPolicy;
		statefulFirewallPolicy: VcDvsStatefulFirewallPolicy;
		switchSecurityConfig: VcDVSSwitchSecurityConfig;
		txUplink: VcBoolPolicy;
		uplinkTeamingPolicy: VcVmwareUplinkPortTeamingPolicy;
		vendorSpecificConfig: VcDVSVendorSpecificConfig;
		vlan: VcVmwareDistributedVirtualSwitchVlanSpec;
		vmDirectPathGen2Allowed: VcBoolPolicy;

		constructor();
	}

	declare class VcVMwareDVSPvlanConfigSpec
	{
		operation: String;
		pvlanEntry: VcVMwareDVSPvlanMapEntry;

		constructor();
	}

	declare class VcVMwareDVSPvlanMapEntry
	{
		primaryVlanId: Number;
		pvlanType: String;
		secondaryVlanId: Number;

		constructor();
	}

	declare class VcVMwareDVSTeamingHealthCheckConfig
	{
		enable: boolean;
		interval: Number;

		constructor();
	}

	declare class VcVMwareDVSTeamingHealthCheckResult
	{
		summary: String;
		teamingStatus: String;

		constructor();
	}

	interface VcVMwareDVSTeamingMatchStatus
	{
		readonly _iphashMatch: String;
		readonly _iphashMismatch: String;
		readonly _nonIphashMatch: String;
		readonly _nonIphashMismatch: String;
		readonly id: String;
		readonly iphashMatch: VcVMwareDVSTeamingMatchStatus;
		readonly iphashMismatch: VcVMwareDVSTeamingMatchStatus;
		readonly name: String;
		readonly nonIphashMatch: VcVMwareDVSTeamingMatchStatus;
		readonly nonIphashMismatch: VcVMwareDVSTeamingMatchStatus;
		readonly value: String;

		fromString(value?: String): VcVMwareDVSTeamingMatchStatus;
	}

	interface VcVMwareDVSTeamingMatchStatusConstructor {
		new(value?:any): VcVMwareDVSTeamingMatchStatus;
		readonly prototype: VcVMwareDVSTeamingMatchStatus;
	}

	declare const VcVMwareDVSTeamingMatchStatus: VcVMwareDVSTeamingMatchStatusConstructor;

	declare class VcVMwareDVSVlanHealthCheckResult
	{
		summary: String;
		trunkedVlan: VcNumericRange[];
		untrunkedVlan: VcNumericRange[];
		uplinkPortKey: String;

		constructor();
	}

	declare class VcVMwareDVSVlanMtuHealthCheckConfig
	{
		enable: boolean;
		interval: Number;

		constructor();
	}

	declare class VcVMwareDVSVspanCapability
	{
		dvportSupported: boolean;
		encapRemoteSourceSupported: boolean;
		mixedDestSupported: boolean;
		remoteDestSupported: boolean;
		remoteSourceSupported: boolean;

		constructor();
	}

	declare class VcVMwareDVSVspanConfigSpec
	{
		operation: String;
		vspanSession: VcVMwareVspanSession;

		constructor();
	}

	interface VcVMwareDVSVspanSessionType
	{
		readonly _dvPortMirror: String;
		readonly _encapsulatedRemoteMirrorSource: String;
		readonly _mixedDestMirror: String;
		readonly _remoteMirrorDest: String;
		readonly _remoteMirrorSource: String;
		readonly dvPortMirror: VcVMwareDVSVspanSessionType;
		readonly encapsulatedRemoteMirrorSource: VcVMwareDVSVspanSessionType;
		readonly id: String;
		readonly mixedDestMirror: VcVMwareDVSVspanSessionType;
		readonly name: String;
		readonly remoteMirrorDest: VcVMwareDVSVspanSessionType;
		readonly remoteMirrorSource: VcVMwareDVSVspanSessionType;
		readonly value: String;

		fromString(value?: String): VcVMwareDVSVspanSessionType;
	}

	interface VcVMwareDVSVspanSessionTypeConstructor {
		new(value?:any): VcVMwareDVSVspanSessionType;
		readonly prototype: VcVMwareDVSVspanSessionType;
	}

	declare const VcVMwareDVSVspanSessionType: VcVMwareDVSVspanSessionTypeConstructor;

	declare class VcVMwareIpfixConfig
	{
		activeFlowTimeout: Number;
		collectorIpAddress: String;
		collectorPort: Number;
		idleFlowTimeout: Number;
		internalFlowsOnly: boolean;
		observationDomainId: Number;
		samplingRate: Number;

		constructor();
	}

	interface VcVMwareUplinkLacpMode
	{
		readonly _active: String;
		readonly _passive: String;
		readonly active: VcVMwareUplinkLacpMode;
		readonly id: String;
		readonly name: String;
		readonly passive: VcVMwareUplinkLacpMode;
		readonly value: String;

		fromString(value?: String): VcVMwareUplinkLacpMode;
	}

	interface VcVMwareUplinkLacpModeConstructor {
		new(value?:any): VcVMwareUplinkLacpMode;
		readonly prototype: VcVMwareUplinkLacpMode;
	}

	declare const VcVMwareUplinkLacpMode: VcVMwareUplinkLacpModeConstructor;

	declare class VcVMwareUplinkLacpPolicy
	{
		enable: VcBoolPolicy;
		inherited: boolean;
		mode: VcStringPolicy;

		constructor();
	}

	declare class VcVMwareUplinkPortOrderPolicy
	{
		activeUplinkPort: String[];
		inherited: boolean;
		standbyUplinkPort: String[];

		constructor();
	}

	declare class VcVmwareUplinkPortTeamingPolicy
	{
		failureCriteria: VcDVSFailureCriteria;
		inherited: boolean;
		notifySwitches: VcBoolPolicy;
		policy: VcStringPolicy;
		reversePolicy: VcBoolPolicy;
		rollingOrder: VcBoolPolicy;
		uplinkPortOrder: VcVMwareUplinkPortOrderPolicy;

		constructor();
	}

	declare class VcVMwareVspanPort
	{
		ipAddress: String[];
		portKey: String[];
		uplinkPortName: String[];
		vlans: Number[];
		wildcardPortConnecteeType: String[];

		constructor();
	}

	declare class VcVMwareVspanSession
	{
		description: String;
		destinationPort: VcVMwareVspanPort;
		enabled: boolean;
		encapsulationVlanId: Number;
		key: String;
		mirroredPacketLength: Number;
		name: String;
		normalTrafficAllowed: boolean;
		samplingRate: Number;
		sessionType: String;
		sourcePortReceived: VcVMwareVspanPort;
		sourcePortTransmitted: VcVMwareVspanPort;
		stripOriginalVlan: boolean;

		constructor();
	}

	declare class VcVmWwnAssignedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		nodeWwns: Number[];
		portWwns: Number[];
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmWwnChangedEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		newNodeWwns: Number[];
		newPortWwns: Number[];
		oldNodeWwns: Number[];
		oldPortWwns: Number[];
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcVmWwnConflictEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		conflictedHosts: VcHostEventArgument[];
		conflictedVms: VcVmEventArgument[];
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		net: VcNetworkEventArgument;
		template: boolean;
		userName: String;
		vm: VcVmEventArgument;
		wwn: Number;

		constructor();
	}

	declare class VcVnicPortArgument
	{
		port: VcDistributedVirtualSwitchPortConnection;
		vnic: String;

		constructor();
	}

	declare class VcVRMPolicyInfo
	{
		destroyOnCheckin: boolean;
		destroyOnInvalidSession: boolean;
		disksReplicated: VcVRMPolicyInfoDisksReplicated;
		expireTime: Number;
		policyCacheLifetime: Number;
		replicationRequestTime: Number;
		requestedReplicationCanBeDeferred: boolean;
		revoked: boolean;
		targetReplicationFrequency: Number;
		updateCacheExpireTime: boolean;
		usbAllowedFamilies: Number;
		usbBlockedFamilies: Number;
		usbDefaultAccess: boolean;
		userAllowedToDeferReplication: boolean;

		constructor();
	}

	interface VcVRMPolicyInfoDisksReplicated
	{
		readonly _system: String;
		readonly _systemAndUser: String;
		readonly _user: String;
		readonly id: String;
		readonly name: String;
		readonly system: VcVRMPolicyInfoDisksReplicated;
		readonly systemAndUser: VcVRMPolicyInfoDisksReplicated;
		readonly user: VcVRMPolicyInfoDisksReplicated;
		readonly value: String;

		fromString(value?: String): VcVRMPolicyInfoDisksReplicated;
	}

	interface VcVRMPolicyInfoDisksReplicatedConstructor {
		new(value?:any): VcVRMPolicyInfoDisksReplicated;
		readonly prototype: VcVRMPolicyInfoDisksReplicated;
	}

	declare const VcVRMPolicyInfoDisksReplicated: VcVRMPolicyInfoDisksReplicatedConstructor;

	declare class VcVRPEditSpec
	{
		addedHubs: VcManagedEntity[];
		changeVersion: Number;
		cpuAllocation: VcVrpResourceAllocationInfo;
		description: String;
		memoryAllocation: VcVrpResourceAllocationInfo;
		removedHubs: VcManagedEntity[];
		vrpId: String;

		constructor();
	}

	declare class VcVrpResourceAllocationInfo
	{
		expandableReservation: boolean;
		limit: Number;
		overheadLimit: Number;
		reservation: Number;
		reservationLimit: Number;
		shares: VcSharesInfo;

		constructor();
	}

	interface VcVRPResourceManager
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		createVRP(spec?: VcVirtualResourcePoolSpec): String;
		deleteVRP(vrpId?: String): void;
		deployVM(vrpId?: String, vm?: VcVirtualMachine, cluster?: VcManagedEntity): void;
		getAllVRPIds(): String[];
		getChildRPforHub(vrpId?: String, hub?: VcManagedEntity): VcResourcePool;
		getRPSettings(resourcePool?: VcResourcePool): VcResourceConfigSpec;
		getVRPofVM(vm?: VcVirtualMachine): String;
		getVRPSettings(vrpId?: String): VcVirtualResourcePoolSpec;
		getVRPUsage(vrpId?: String): VcVirtualResourcePoolUsage;
		setManagedByVDC(cluster?: VcManagedEntity, status?: boolean): void;
		undeployVM(vrpId?: String, vm?: VcVirtualMachine, cluster?: VcManagedEntity): void;
		updateVRP(spec?: VcVRPEditSpec): void;
	}

	declare const VcVRPResourceManager: VcVRPResourceManager;

	declare class VcVsanClusterConfigInfo
	{
		defaultConfig: VcVsanClusterConfigInfoHostDefaultInfo;
		enabled: boolean;

		constructor();
	}

	declare class VcVsanClusterConfigInfoHostDefaultInfo
	{
		autoClaimStorage: boolean;
		checksumEnabled: boolean;
		uuid: String;

		constructor();
	}

	interface VcVsanDiskIssueType
	{
		readonly _nonExist: String;
		readonly _stampMismatch: String;
		readonly _unknown: String;
		readonly id: String;
		readonly name: String;
		readonly nonExist: VcVsanDiskIssueType;
		readonly stampMismatch: VcVsanDiskIssueType;
		readonly unknown: VcVsanDiskIssueType;
		readonly value: String;

		fromString(value?: String): VcVsanDiskIssueType;
	}

	interface VcVsanDiskIssueTypeConstructor {
		new(value?:any): VcVsanDiskIssueType;
		readonly prototype: VcVsanDiskIssueType;
	}

	declare const VcVsanDiskIssueType: VcVsanDiskIssueTypeConstructor;

	declare class VcVsanHostClusterStatus
	{
		health: String;
		memberUuid: String[];
		nodeState: VcVsanHostClusterStatusState;
		nodeUuid: String;
		uuid: String;

		constructor();
	}

	declare class VcVsanHostClusterStatusState
	{
		completion: VcVsanHostClusterStatusStateCompletionEstimate;
		state: String;

		constructor();
	}

	declare class VcVsanHostClusterStatusStateCompletionEstimate
	{
		completeTime: Date;
		percentComplete: Number;

		constructor();
	}

	declare class VcVsanHostConfigInfo
	{
		clusterInfo: VcVsanHostConfigInfoClusterInfo;
		enabled: boolean;
		faultDomainInfo: VcVsanHostFaultDomainInfo;
		hostSystem: VcHostSystem;
		networkInfo: VcVsanHostConfigInfoNetworkInfo;
		storageInfo: VcVsanHostConfigInfoStorageInfo;

		constructor();
	}

	declare class VcVsanHostConfigInfoClusterInfo
	{
		nodeUuid: String;
		uuid: String;

		constructor();
	}

	declare class VcVsanHostConfigInfoNetworkInfo
	{
		port: VcVsanHostConfigInfoNetworkInfoPortConfig[];

		constructor();
	}

	declare class VcVsanHostConfigInfoNetworkInfoPortConfig
	{
		device: String;
		ipConfig: VcVsanHostIpConfig;

		constructor();
	}

	declare class VcVsanHostConfigInfoStorageInfo
	{
		autoClaimStorage: boolean;
		checksumEnabled: boolean;
		diskMapInfo: VcVsanHostDiskMapInfo[];
		diskMapping: VcVsanHostDiskMapping[];

		constructor();
	}

	declare class VcVsanHostDecommissionMode
	{
		objectAction: String;

		constructor();
	}

	interface VcVsanHostDecommissionModeObjectAction
	{
		readonly _ensureObjectAccessibility: String;
		readonly _evacuateAllData: String;
		readonly _noAction: String;
		readonly ensureObjectAccessibility: VcVsanHostDecommissionModeObjectAction;
		readonly evacuateAllData: VcVsanHostDecommissionModeObjectAction;
		readonly id: String;
		readonly name: String;
		readonly noAction: VcVsanHostDecommissionModeObjectAction;
		readonly value: String;

		fromString(value?: String): VcVsanHostDecommissionModeObjectAction;
	}

	interface VcVsanHostDecommissionModeObjectActionConstructor {
		new(value?:any): VcVsanHostDecommissionModeObjectAction;
		readonly prototype: VcVsanHostDecommissionModeObjectAction;
	}

	declare const VcVsanHostDecommissionModeObjectAction: VcVsanHostDecommissionModeObjectActionConstructor;

	declare class VcVsanHostDiskMapInfo
	{
		mapping: VcVsanHostDiskMapping;
		mounted: boolean;

		constructor();
	}

	declare class VcVsanHostDiskMapping
	{
		nonSsd: VcHostScsiDisk[];
		ssd: VcHostScsiDisk;

		constructor();
	}

	declare class VcVsanHostDiskMapResult
	{
		diskResult: VcVsanHostDiskResult[];
		error: VcLocalizedMethodFault;
		mapping: VcVsanHostDiskMapping;

		constructor();
	}

	declare class VcVsanHostDiskResult
	{
		degraded: boolean;
		disk: VcHostScsiDisk;
		error: VcLocalizedMethodFault;
		state: String;
		vsanUuid: String;

		constructor();
	}

	interface VcVsanHostDiskResultState
	{
		readonly _eligible: String;
		readonly _ineligible: String;
		readonly _inUse: String;
		readonly eligible: VcVsanHostDiskResultState;
		readonly id: String;
		readonly ineligible: VcVsanHostDiskResultState;
		readonly inUse: VcVsanHostDiskResultState;
		readonly name: String;
		readonly value: String;

		fromString(value?: String): VcVsanHostDiskResultState;
	}

	interface VcVsanHostDiskResultStateConstructor {
		new(value?:any): VcVsanHostDiskResultState;
		readonly prototype: VcVsanHostDiskResultState;
	}

	declare const VcVsanHostDiskResultState: VcVsanHostDiskResultStateConstructor;

	declare class VcVsanHostFaultDomainInfo
	{
		name: String;

		constructor();
	}

	interface VcVsanHostHealthState
	{
		readonly _healthy: String;
		readonly _unhealthy: String;
		readonly _unknown: String;
		readonly healthy: VcVsanHostHealthState;
		readonly id: String;
		readonly name: String;
		readonly unhealthy: VcVsanHostHealthState;
		readonly unknown: VcVsanHostHealthState;
		readonly value: String;

		fromString(value?: String): VcVsanHostHealthState;
	}

	interface VcVsanHostHealthStateConstructor {
		new(value?:any): VcVsanHostHealthState;
		readonly prototype: VcVsanHostHealthState;
	}

	declare const VcVsanHostHealthState: VcVsanHostHealthStateConstructor;

	declare class VcVsanHostIpConfig
	{
		downstreamIpAddress: String;
		upstreamIpAddress: String;

		constructor();
	}

	declare class VcVsanHostMembershipInfo
	{
		hostname: String;
		nodeUuid: String;

		constructor();
	}

	interface VcVsanHostNodeState
	{
		readonly _agent: String;
		readonly _backup: String;
		readonly _decommissioning: String;
		readonly _disabled: String;
		readonly _enteringMaintenanceMode: String;
		readonly _error: String;
		readonly _exitingMaintenanceMode: String;
		readonly _master: String;
		readonly _starting: String;
		readonly _stopping: String;
		readonly agent: VcVsanHostNodeState;
		readonly backup: VcVsanHostNodeState;
		readonly decommissioning: VcVsanHostNodeState;
		readonly disabled: VcVsanHostNodeState;
		readonly enteringMaintenanceMode: VcVsanHostNodeState;
		readonly error: VcVsanHostNodeState;
		readonly exitingMaintenanceMode: VcVsanHostNodeState;
		readonly id: String;
		readonly master: VcVsanHostNodeState;
		readonly name: String;
		readonly starting: VcVsanHostNodeState;
		readonly stopping: VcVsanHostNodeState;
		readonly value: String;

		fromString(value?: String): VcVsanHostNodeState;
	}

	interface VcVsanHostNodeStateConstructor {
		new(value?:any): VcVsanHostNodeState;
		readonly prototype: VcVsanHostNodeState;
	}

	declare const VcVsanHostNodeState: VcVsanHostNodeStateConstructor;

	declare class VcVsanHostRuntimeInfo
	{
		accessGenNo: Number;
		diskIssues: VcVsanHostRuntimeInfoDiskIssue[];
		membershipList: VcVsanHostMembershipInfo[];

		constructor();
	}

	declare class VcVsanHostRuntimeInfoDiskIssue
	{
		diskId: String;
		issue: String;

		constructor();
	}

	declare class VcVsanHostVsanDiskInfo
	{
		formatVersion: Number;
		vsanUuid: String;

		constructor();
	}

	declare class VcVsanNewPolicyBatch
	{
		policy: String;
		size: Number[];

		constructor();
	}

	declare class VcVsanPolicyChangeBatch
	{
		policy: String;
		uuid: String[];

		constructor();
	}

	declare class VcVsanPolicyCost
	{
		changeDataSize: Number;
		changeFlashReadCacheSize: Number;
		copyDataSize: Number;
		currentDataSize: Number;
		currentDiskSpaceToAddressSpaceRatio: Number;
		currentFlashReadCacheSize: Number;
		diskSpaceToAddressSpaceRatio: Number;
		tempDataSize: Number;

		constructor();
	}

	declare class VcVsanPolicySatisfiability
	{
		cost: VcVsanPolicyCost;
		isSatisfiable: boolean;
		reason: VcLocalizableMessage;
		uuid: String;

		constructor();
	}

	interface VcVsanUpgradeSystem
	{
		readonly id: String;
		readonly reference: VcManagedObjectReference;
		readonly sdkConnection: VcSdkConnection;
		readonly vimHost: VcSdkConnection;
		readonly vimType: String;

		createTrigger(timeout?: Number, filter?: String, condition?: String, filterToSync?: String): Trigger;
		performVsanUpgrade_Task(cluster?: VcClusterComputeResource, performObjectUpgrade?: boolean, downgradeFormat?: boolean, allowReducedRedundancy?: boolean, excludeHosts?: VcHostSystem[]): VcTask;
		performVsanUpgradePreflightCheck(cluster?: VcClusterComputeResource, downgradeFormat?: boolean): VcVsanUpgradeSystemPreflightCheckResult;
		queryVsanUpgradeStatus(cluster?: VcClusterComputeResource): VcVsanUpgradeSystemUpgradeStatus;
	}

	declare const VcVsanUpgradeSystem: VcVsanUpgradeSystem;

	declare class VcVsanUpgradeSystemAPIBrokenIssue
	{
		hosts: VcHostSystem[];
		msg: String;

		constructor();
	}

	declare class VcVsanUpgradeSystemAutoClaimEnabledOnHostsIssue
	{
		hosts: VcHostSystem[];
		msg: String;

		constructor();
	}

	declare class VcVsanUpgradeSystemHostsDisconnectedIssue
	{
		hosts: VcHostSystem[];
		msg: String;

		constructor();
	}

	declare class VcVsanUpgradeSystemMissingHostsInClusterIssue
	{
		hosts: VcHostSystem[];
		msg: String;

		constructor();
	}

	declare class VcVsanUpgradeSystemNetworkPartitionInfo
	{
		hosts: VcHostSystem[];

		constructor();
	}

	declare class VcVsanUpgradeSystemNetworkPartitionIssue
	{
		msg: String;
		partitions: VcVsanUpgradeSystemNetworkPartitionInfo[];

		constructor();
	}

	declare class VcVsanUpgradeSystemNotEnoughFreeCapacityIssue
	{
		msg: String;
		reducedRedundancyUpgradePossible: boolean;

		constructor();
	}

	declare class VcVsanUpgradeSystemPreflightCheckIssue
	{
		msg: String;

		constructor();
	}

	declare class VcVsanUpgradeSystemPreflightCheckResult
	{
		diskMappingToRestore: VcVsanHostDiskMapping;
		issues: VcVsanUpgradeSystemPreflightCheckIssue[];

		constructor();
	}

	declare class VcVsanUpgradeSystemRogueHostsInClusterIssue
	{
		msg: String;
		uuids: String[];

		constructor();
	}

	declare class VcVsanUpgradeSystemUpgradeHistoryDiskGroupOp
	{
		diskMapping: VcVsanHostDiskMapping;
		host: VcHostSystem;
		message: String;
		operation: String;
		task: VcTask;
		timestamp: Date;

		constructor();
	}

	interface VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType
	{
		readonly _add: String;
		readonly _remove: String;
		readonly add: VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
		readonly id: String;
		readonly name: String;
		readonly remove: VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
		readonly value: String;

		fromString(value?: String): VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
	}

	interface VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpTypeConstructor {
		new(value?:any): VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
		readonly prototype: VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
	}

	declare const VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType: VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpTypeConstructor;

	declare class VcVsanUpgradeSystemUpgradeHistoryItem
	{
		host: VcHostSystem;
		message: String;
		task: VcTask;
		timestamp: Date;

		constructor();
	}

	declare class VcVsanUpgradeSystemUpgradeHistoryPreflightFail
	{
		host: VcHostSystem;
		message: String;
		preflightResult: VcVsanUpgradeSystemPreflightCheckResult;
		task: VcTask;
		timestamp: Date;

		constructor();
	}

	declare class VcVsanUpgradeSystemUpgradeStatus
	{
		aborted: boolean;
		completed: boolean;
		history: VcVsanUpgradeSystemUpgradeHistoryItem[];
		inProgress: boolean;
		progress: Number;

		constructor();
	}

	declare class VcVsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue
	{
		msg: String;
		uuids: String[];

		constructor();
	}

	declare class VcVsanUpgradeSystemWrongEsxVersionIssue
	{
		hosts: VcHostSystem[];
		msg: String;

		constructor();
	}

	declare class VcVvolDatastoreInfo
	{
		containerId: String;
		freeSpace: Number;
		maxFileSize: Number;
		maxMemoryFileSize: Number;
		maxVirtualDiskCapacity: Number;
		name: String;
		timestamp: Date;
		url: String;
		vvolDS: VcHostVvolVolume;

		constructor();
	}

	declare class VcVVolHostPE
	{
		key: VcHostSystem;
		protocolEndpoint: VcHostProtocolEndpoint[];

		constructor();
	}

	declare class VcWaitOptions
	{
		maxObjectUpdates: Number;
		maxWaitSeconds: Number;

		constructor();
	}

	declare class VcWarningUpgradeEvent
	{
		chainId: Number;
		changeTag: String;
		computeResource: VcComputeResourceEventArgument;
		createdTime: Date;
		datacenter: VcDatacenterEventArgument;
		ds: VcDatastoreEventArgument;
		dvs: VcDvsEventArgument;
		fullFormattedMessage: String;
		host: VcHostEventArgument;
		key: Number;
		message: String;
		net: VcNetworkEventArgument;
		userName: String;
		vm: VcVmEventArgument;

		constructor();
	}

	declare class VcWeeklyTaskScheduler
	{
		activeTime: Date;
		expireTime: Date;
		friday: boolean;
		hour: Number;
		interval: Number;
		minute: Number;
		monday: boolean;
		saturday: boolean;
		sunday: boolean;
		thursday: boolean;
		tuesday: boolean;
		wednesday: boolean;

		constructor();
	}

	interface VcWeekOfMonth
	{
		readonly _first: String;
		readonly _fourth: String;
		readonly _last: String;
		readonly _second: String;
		readonly _third: String;
		readonly first: VcWeekOfMonth;
		readonly fourth: VcWeekOfMonth;
		readonly id: String;
		readonly last: VcWeekOfMonth;
		readonly name: String;
		readonly second: VcWeekOfMonth;
		readonly third: VcWeekOfMonth;
		readonly value: String;

		fromString(value?: String): VcWeekOfMonth;
	}

	interface VcWeekOfMonthConstructor {
		new(value?:any): VcWeekOfMonth;
		readonly prototype: VcWeekOfMonth;
	}

	declare const VcWeekOfMonth: VcWeekOfMonthConstructor;

	interface VcWillLoseHAProtectionResolution
	{
		readonly _relocate: String;
		readonly _svmotion: String;
		readonly id: String;
		readonly name: String;
		readonly relocate: VcWillLoseHAProtectionResolution;
		readonly svmotion: VcWillLoseHAProtectionResolution;
		readonly value: String;

		fromString(value?: String): VcWillLoseHAProtectionResolution;
	}

	interface VcWillLoseHAProtectionResolutionConstructor {
		new(value?:any): VcWillLoseHAProtectionResolution;
		readonly prototype: VcWillLoseHAProtectionResolution;
	}

	declare const VcWillLoseHAProtectionResolution: VcWillLoseHAProtectionResolutionConstructor;

	declare class VcWinNetBIOSConfigInfo
	{
		mode: String;
		primaryWINS: String;
		secondaryWINS: String;

		constructor();
	}

    
    // Finder objects.
declare namespace VC {
	interface ActionParameter extends VcActionParameter
	{
		name: any;

	}

	interface ActionParameterConstructor {
		new(value?:any): ActionParameter;
		readonly prototype: ActionParameter;
	}

	const ActionParameter: ActionParameterConstructor;

	interface ActionType extends VcActionType
	{
		name: any;

	}

	interface ActionTypeConstructor {
		new(value?:any): ActionType;
		readonly prototype: ActionType;
	}

	const ActionType: ActionTypeConstructor;

	interface AffinityType extends VcAffinityType
	{
		name: any;

	}

	interface AffinityTypeConstructor {
		new(value?:any): AffinityType;
		readonly prototype: AffinityType;
	}

	const AffinityType: AffinityTypeConstructor;

	interface AgentInstallFailedReason extends VcAgentInstallFailedReason
	{
		name: any;

	}

	interface AgentInstallFailedReasonConstructor {
		new(value?:any): AgentInstallFailedReason;
		readonly prototype: AgentInstallFailedReason;
	}

	const AgentInstallFailedReason: AgentInstallFailedReasonConstructor;

	interface ArrayUpdateOperation extends VcArrayUpdateOperation
	{
		name: any;

	}

	interface ArrayUpdateOperationConstructor {
		new(value?:any): ArrayUpdateOperation;
		readonly prototype: ArrayUpdateOperation;
	}

	const ArrayUpdateOperation: ArrayUpdateOperationConstructor;

	interface AutoStartAction extends VcAutoStartAction
	{
		name: any;

	}

	interface AutoStartActionConstructor {
		new(value?:any): AutoStartAction;
		readonly prototype: AutoStartAction;
	}

	const AutoStartAction: AutoStartActionConstructor;

	interface AutoStartWaitHeartbeatSetting extends VcAutoStartWaitHeartbeatSetting
	{
		name: any;

	}

	interface AutoStartWaitHeartbeatSettingConstructor {
		new(value?:any): AutoStartWaitHeartbeatSetting;
		readonly prototype: AutoStartWaitHeartbeatSetting;
	}

	const AutoStartWaitHeartbeatSetting: AutoStartWaitHeartbeatSettingConstructor;

	interface BatchResultResult extends VcBatchResultResult
	{
		name: any;

	}

	interface BatchResultResultConstructor {
		new(value?:any): BatchResultResult;
		readonly prototype: BatchResultResult;
	}

	const BatchResultResult: BatchResultResultConstructor;

	interface CannotEnableVmcpForClusterReason extends VcCannotEnableVmcpForClusterReason
	{
		name: any;

	}

	interface CannotEnableVmcpForClusterReasonConstructor {
		new(value?:any): CannotEnableVmcpForClusterReason;
		readonly prototype: CannotEnableVmcpForClusterReason;
	}

	const CannotEnableVmcpForClusterReason: CannotEnableVmcpForClusterReasonConstructor;

	interface CannotMoveFaultToleranceVmMoveType extends VcCannotMoveFaultToleranceVmMoveType
	{
		name: any;

	}

	interface CannotMoveFaultToleranceVmMoveTypeConstructor {
		new(value?:any): CannotMoveFaultToleranceVmMoveType;
		readonly prototype: CannotMoveFaultToleranceVmMoveType;
	}

	const CannotMoveFaultToleranceVmMoveType: CannotMoveFaultToleranceVmMoveTypeConstructor;

	interface CannotPowerOffVmInClusterOperation extends VcCannotPowerOffVmInClusterOperation
	{
		name: any;

	}

	interface CannotPowerOffVmInClusterOperationConstructor {
		new(value?:any): CannotPowerOffVmInClusterOperation;
		readonly prototype: CannotPowerOffVmInClusterOperation;
	}

	const CannotPowerOffVmInClusterOperation: CannotPowerOffVmInClusterOperationConstructor;

	interface CannotUseNetworkReason extends VcCannotUseNetworkReason
	{
		name: any;

	}

	interface CannotUseNetworkReasonConstructor {
		new(value?:any): CannotUseNetworkReason;
		readonly prototype: CannotUseNetworkReason;
	}

	const CannotUseNetworkReason: CannotUseNetworkReasonConstructor;

	interface CheckTestConditionOpType extends VcCheckTestConditionOpType
	{
		name: any;

	}

	interface CheckTestConditionOpTypeConstructor {
		new(value?:any): CheckTestConditionOpType;
		readonly prototype: CheckTestConditionOpType;
	}

	const CheckTestConditionOpType: CheckTestConditionOpTypeConstructor;

	interface CheckTestletTestLanguage extends VcCheckTestletTestLanguage
	{
		name: any;

	}

	interface CheckTestletTestLanguageConstructor {
		new(value?:any): CheckTestletTestLanguage;
		readonly prototype: CheckTestletTestLanguage;
	}

	const CheckTestletTestLanguage: CheckTestletTestLanguageConstructor;

	interface CheckTestType extends VcCheckTestType
	{
		name: any;

	}

	interface CheckTestTypeConstructor {
		new(value?:any): CheckTestType;
		readonly prototype: CheckTestType;
	}

	const CheckTestType: CheckTestTypeConstructor;

	interface ClusterComputeResource extends VcClusterComputeResource
	{
		id: any;
		name: any;
		vimHost: any;

		getDatastore(): Datastore;
		getHost(): HostSystem;
		getNetwork(): Network;
		getNetwork_DistributedVirtualPortgroup(): DistributedVirtualPortgroup;
		getNetwork_Network(): Network;
		getRecentTask(): Task;
		getResourcePool(): ResourcePool;
		getResourcePool_ResourcePool(): ResourcePool;
		getResourcePool_VirtualApp(): VirtualApp;
	}

	interface ClusterComputeResourceConstructor {
		new(value?:any): ClusterComputeResource;
		readonly prototype: ClusterComputeResource;
	}

	const ClusterComputeResource: ClusterComputeResourceConstructor;

	interface ClusterDasAamNodeStateDasState extends VcClusterDasAamNodeStateDasState
	{
		name: any;

	}

	interface ClusterDasAamNodeStateDasStateConstructor {
		new(value?:any): ClusterDasAamNodeStateDasState;
		readonly prototype: ClusterDasAamNodeStateDasState;
	}

	const ClusterDasAamNodeStateDasState: ClusterDasAamNodeStateDasStateConstructor;

	interface ClusterDasConfigInfoHBDatastoreCandidate extends VcClusterDasConfigInfoHBDatastoreCandidate
	{
		name: any;

	}

	interface ClusterDasConfigInfoHBDatastoreCandidateConstructor {
		new(value?:any): ClusterDasConfigInfoHBDatastoreCandidate;
		readonly prototype: ClusterDasConfigInfoHBDatastoreCandidate;
	}

	const ClusterDasConfigInfoHBDatastoreCandidate: ClusterDasConfigInfoHBDatastoreCandidateConstructor;

	interface ClusterDasConfigInfoServiceState extends VcClusterDasConfigInfoServiceState
	{
		name: any;

	}

	interface ClusterDasConfigInfoServiceStateConstructor {
		new(value?:any): ClusterDasConfigInfoServiceState;
		readonly prototype: ClusterDasConfigInfoServiceState;
	}

	const ClusterDasConfigInfoServiceState: ClusterDasConfigInfoServiceStateConstructor;

	interface ClusterDasConfigInfoVmMonitoringState extends VcClusterDasConfigInfoVmMonitoringState
	{
		name: any;

	}

	interface ClusterDasConfigInfoVmMonitoringStateConstructor {
		new(value?:any): ClusterDasConfigInfoVmMonitoringState;
		readonly prototype: ClusterDasConfigInfoVmMonitoringState;
	}

	const ClusterDasConfigInfoVmMonitoringState: ClusterDasConfigInfoVmMonitoringStateConstructor;

	interface ClusterDasFdmAvailabilityState extends VcClusterDasFdmAvailabilityState
	{
		name: any;

	}

	interface ClusterDasFdmAvailabilityStateConstructor {
		new(value?:any): ClusterDasFdmAvailabilityState;
		readonly prototype: ClusterDasFdmAvailabilityState;
	}

	const ClusterDasFdmAvailabilityState: ClusterDasFdmAvailabilityStateConstructor;

	interface ClusterDasVmSettingsIsolationResponse extends VcClusterDasVmSettingsIsolationResponse
	{
		name: any;

	}

	interface ClusterDasVmSettingsIsolationResponseConstructor {
		new(value?:any): ClusterDasVmSettingsIsolationResponse;
		readonly prototype: ClusterDasVmSettingsIsolationResponse;
	}

	const ClusterDasVmSettingsIsolationResponse: ClusterDasVmSettingsIsolationResponseConstructor;

	interface ClusterDasVmSettingsRestartPriority extends VcClusterDasVmSettingsRestartPriority
	{
		name: any;

	}

	interface ClusterDasVmSettingsRestartPriorityConstructor {
		new(value?:any): ClusterDasVmSettingsRestartPriority;
		readonly prototype: ClusterDasVmSettingsRestartPriority;
	}

	const ClusterDasVmSettingsRestartPriority: ClusterDasVmSettingsRestartPriorityConstructor;

	interface ClusterPowerOnVmOption extends VcClusterPowerOnVmOption
	{
		name: any;

	}

	interface ClusterPowerOnVmOptionConstructor {
		new(value?:any): ClusterPowerOnVmOption;
		readonly prototype: ClusterPowerOnVmOption;
	}

	const ClusterPowerOnVmOption: ClusterPowerOnVmOptionConstructor;

	interface ClusterProfileServiceType extends VcClusterProfileServiceType
	{
		name: any;

	}

	interface ClusterProfileServiceTypeConstructor {
		new(value?:any): ClusterProfileServiceType;
		readonly prototype: ClusterProfileServiceType;
	}

	const ClusterProfileServiceType: ClusterProfileServiceTypeConstructor;

	interface ClusterVmComponentProtectionSettingsStorageVmReaction extends VcClusterVmComponentProtectionSettingsStorageVmReaction
	{
		name: any;

	}

	interface ClusterVmComponentProtectionSettingsStorageVmReactionConstructor {
		new(value?:any): ClusterVmComponentProtectionSettingsStorageVmReaction;
		readonly prototype: ClusterVmComponentProtectionSettingsStorageVmReaction;
	}

	const ClusterVmComponentProtectionSettingsStorageVmReaction: ClusterVmComponentProtectionSettingsStorageVmReactionConstructor;

	interface ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared extends VcClusterVmComponentProtectionSettingsVmReactionOnAPDCleared
	{
		name: any;

	}

	interface ClusterVmComponentProtectionSettingsVmReactionOnAPDClearedConstructor {
		new(value?:any): ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
		readonly prototype: ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared;
	}

	const ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared: ClusterVmComponentProtectionSettingsVmReactionOnAPDClearedConstructor;

	interface ComplianceResultStatus extends VcComplianceResultStatus
	{
		name: any;

	}

	interface ComplianceResultStatusConstructor {
		new(value?:any): ComplianceResultStatus;
		readonly prototype: ComplianceResultStatus;
	}

	const ComplianceResultStatus: ComplianceResultStatusConstructor;

	interface ComputeResource extends VcComputeResource
	{
		id: any;
		name: any;
		vimHost: any;

		getDatastore(): Datastore;
		getHost(): HostSystem;
		getNetwork(): Network;
		getNetwork_DistributedVirtualPortgroup(): DistributedVirtualPortgroup;
		getNetwork_Network(): Network;
		getRecentTask(): Task;
		getResourcePool(): ResourcePool;
		getResourcePool_ResourcePool(): ResourcePool;
		getResourcePool_VirtualApp(): VirtualApp;
	}

	interface ComputeResourceConstructor {
		new(value?:any): ComputeResource;
		readonly prototype: ComputeResource;
	}

	const ComputeResource: ComputeResourceConstructor;

	interface ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState extends VcComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState
	{
		name: any;

	}

	interface ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseStateConstructor {
		new(value?:any): ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
		readonly prototype: ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
	}

	const ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState: ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseStateConstructor;

	interface ConfigSpecOperation extends VcConfigSpecOperation
	{
		name: any;

	}

	interface ConfigSpecOperationConstructor {
		new(value?:any): ConfigSpecOperation;
		readonly prototype: ConfigSpecOperation;
	}

	const ConfigSpecOperation: ConfigSpecOperationConstructor;

	interface CustomizationLicenseDataMode extends VcCustomizationLicenseDataMode
	{
		name: any;

	}

	interface CustomizationLicenseDataModeConstructor {
		new(value?:any): CustomizationLicenseDataMode;
		readonly prototype: CustomizationLicenseDataMode;
	}

	const CustomizationLicenseDataMode: CustomizationLicenseDataModeConstructor;

	interface CustomizationNetBIOSMode extends VcCustomizationNetBIOSMode
	{
		name: any;

	}

	interface CustomizationNetBIOSModeConstructor {
		new(value?:any): CustomizationNetBIOSMode;
		readonly prototype: CustomizationNetBIOSMode;
	}

	const CustomizationNetBIOSMode: CustomizationNetBIOSModeConstructor;

	interface CustomizationSysprepRebootOption extends VcCustomizationSysprepRebootOption
	{
		name: any;

	}

	interface CustomizationSysprepRebootOptionConstructor {
		new(value?:any): CustomizationSysprepRebootOption;
		readonly prototype: CustomizationSysprepRebootOption;
	}

	const CustomizationSysprepRebootOption: CustomizationSysprepRebootOptionConstructor;

	interface DasConfigFaultDasConfigFaultReason extends VcDasConfigFaultDasConfigFaultReason
	{
		name: any;

	}

	interface DasConfigFaultDasConfigFaultReasonConstructor {
		new(value?:any): DasConfigFaultDasConfigFaultReason;
		readonly prototype: DasConfigFaultDasConfigFaultReason;
	}

	const DasConfigFaultDasConfigFaultReason: DasConfigFaultDasConfigFaultReasonConstructor;

	interface DasVmPriority extends VcDasVmPriority
	{
		name: any;

	}

	interface DasVmPriorityConstructor {
		new(value?:any): DasVmPriority;
		readonly prototype: DasVmPriority;
	}

	const DasVmPriority: DasVmPriorityConstructor;

	interface Datacenter extends VcDatacenter
	{
		id: any;
		name: any;
		vimHost: any;

		getDatastore(): Datastore;
		getDatastoreFolder(): DatastoreFolder;
		getHostFolder(): HostFolder;
		getNetwork(): Network;
		getNetworkFolder(): NetworkFolder;
		getRecentTask(): Task;
		getVmFolder(): VmFolder;
	}

	interface DatacenterConstructor {
		new(value?:any): Datacenter;
		readonly prototype: Datacenter;
	}

	const Datacenter: DatacenterConstructor;

	interface DatacenterFolder extends VcFolder
	{
		id: any;
		name: any;
		vimHost: any;

		getDatacenter(): Datacenter;
		getFolder(): DatacenterFolder;
	}

	interface DatacenterFolderConstructor {
		new(value?:any): DatacenterFolder;
		readonly prototype: DatacenterFolder;
	}

	const DatacenterFolder: DatacenterFolderConstructor;

	interface Datastore extends VcDatastore
	{
		accessible: any;
		capacity: any;
		freeSpace: any;
		id: any;
		name: any;
		provisionedSpace: any;
		url: any;
		vimHost: any;

		getRecentTask(): Task;
		getVm(): VirtualMachine;
	}

	interface DatastoreConstructor {
		new(value?:any): Datastore;
		readonly prototype: Datastore;
	}

	const Datastore: DatastoreConstructor;

	interface DatastoreAccessible extends VcDatastoreAccessible
	{
		name: any;

	}

	interface DatastoreAccessibleConstructor {
		new(value?:any): DatastoreAccessible;
		readonly prototype: DatastoreAccessible;
	}

	const DatastoreAccessible: DatastoreAccessibleConstructor;

	interface DatastoreFolder extends VcFolder
	{
		id: any;
		name: any;
		vimHost: any;

		getDatastore(): Datastore;
		getDatastoreCluster(): StoragePod;
		getFolder(): DatastoreFolder;
	}

	interface DatastoreFolderConstructor {
		new(value?:any): DatastoreFolder;
		readonly prototype: DatastoreFolder;
	}

	const DatastoreFolder: DatastoreFolderConstructor;

	interface DatastoreSummaryMaintenanceModeState extends VcDatastoreSummaryMaintenanceModeState
	{
		name: any;

	}

	interface DatastoreSummaryMaintenanceModeStateConstructor {
		new(value?:any): DatastoreSummaryMaintenanceModeState;
		readonly prototype: DatastoreSummaryMaintenanceModeState;
	}

	const DatastoreSummaryMaintenanceModeState: DatastoreSummaryMaintenanceModeStateConstructor;

	interface DayOfWeek extends VcDayOfWeek
	{
		name: any;

	}

	interface DayOfWeekConstructor {
		new(value?:any): DayOfWeek;
		readonly prototype: DayOfWeek;
	}

	const DayOfWeek: DayOfWeekConstructor;

	interface DeviceNotSupportedReason extends VcDeviceNotSupportedReason
	{
		name: any;

	}

	interface DeviceNotSupportedReasonConstructor {
		new(value?:any): DeviceNotSupportedReason;
		readonly prototype: DeviceNotSupportedReason;
	}

	const DeviceNotSupportedReason: DeviceNotSupportedReasonConstructor;

	interface DiagnosticManagerLogCreator extends VcDiagnosticManagerLogCreator
	{
		name: any;

	}

	interface DiagnosticManagerLogCreatorConstructor {
		new(value?:any): DiagnosticManagerLogCreator;
		readonly prototype: DiagnosticManagerLogCreator;
	}

	const DiagnosticManagerLogCreator: DiagnosticManagerLogCreatorConstructor;

	interface DiagnosticManagerLogFormat extends VcDiagnosticManagerLogFormat
	{
		name: any;

	}

	interface DiagnosticManagerLogFormatConstructor {
		new(value?:any): DiagnosticManagerLogFormat;
		readonly prototype: DiagnosticManagerLogFormat;
	}

	const DiagnosticManagerLogFormat: DiagnosticManagerLogFormatConstructor;

	interface DiagnosticPartitionStorageType extends VcDiagnosticPartitionStorageType
	{
		name: any;

	}

	interface DiagnosticPartitionStorageTypeConstructor {
		new(value?:any): DiagnosticPartitionStorageType;
		readonly prototype: DiagnosticPartitionStorageType;
	}

	const DiagnosticPartitionStorageType: DiagnosticPartitionStorageTypeConstructor;

	interface DiagnosticPartitionType extends VcDiagnosticPartitionType
	{
		name: any;

	}

	interface DiagnosticPartitionTypeConstructor {
		new(value?:any): DiagnosticPartitionType;
		readonly prototype: DiagnosticPartitionType;
	}

	const DiagnosticPartitionType: DiagnosticPartitionTypeConstructor;

	interface DisallowedChangeByServiceDisallowedChange extends VcDisallowedChangeByServiceDisallowedChange
	{
		name: any;

	}

	interface DisallowedChangeByServiceDisallowedChangeConstructor {
		new(value?:any): DisallowedChangeByServiceDisallowedChange;
		readonly prototype: DisallowedChangeByServiceDisallowedChange;
	}

	const DisallowedChangeByServiceDisallowedChange: DisallowedChangeByServiceDisallowedChangeConstructor;

	interface DistributedVirtualPortgroup extends VcDistributedVirtualPortgroup
	{
		accessible: any;
		id: any;
		name: any;
		vimHost: any;

		getHost(): HostSystem;
		getRecentTask(): Task;
		getVm(): VirtualMachine;
	}

	interface DistributedVirtualPortgroupConstructor {
		new(value?:any): DistributedVirtualPortgroup;
		readonly prototype: DistributedVirtualPortgroup;
	}

	const DistributedVirtualPortgroup: DistributedVirtualPortgroupConstructor;

	interface DistributedVirtualPortgroupMetaTagName extends VcDistributedVirtualPortgroupMetaTagName
	{
		name: any;

	}

	interface DistributedVirtualPortgroupMetaTagNameConstructor {
		new(value?:any): DistributedVirtualPortgroupMetaTagName;
		readonly prototype: DistributedVirtualPortgroupMetaTagName;
	}

	const DistributedVirtualPortgroupMetaTagName: DistributedVirtualPortgroupMetaTagNameConstructor;

	interface DistributedVirtualPortgroupPortgroupType extends VcDistributedVirtualPortgroupPortgroupType
	{
		name: any;

	}

	interface DistributedVirtualPortgroupPortgroupTypeConstructor {
		new(value?:any): DistributedVirtualPortgroupPortgroupType;
		readonly prototype: DistributedVirtualPortgroupPortgroupType;
	}

	const DistributedVirtualPortgroupPortgroupType: DistributedVirtualPortgroupPortgroupTypeConstructor;

	interface DistributedVirtualSwitch extends VcDistributedVirtualSwitch
	{
		description: any;
		id: any;
		name: any;
		vimHost: any;

		getPortgroup(): DistributedVirtualPortgroup;
		getRecentTask(): Task;
	}

	interface DistributedVirtualSwitchConstructor {
		new(value?:any): DistributedVirtualSwitch;
		readonly prototype: DistributedVirtualSwitch;
	}

	const DistributedVirtualSwitch: DistributedVirtualSwitchConstructor;

	interface DistributedVirtualSwitchHostInfrastructureTrafficClass extends VcDistributedVirtualSwitchHostInfrastructureTrafficClass
	{
		name: any;

	}

	interface DistributedVirtualSwitchHostInfrastructureTrafficClassConstructor {
		new(value?:any): DistributedVirtualSwitchHostInfrastructureTrafficClass;
		readonly prototype: DistributedVirtualSwitchHostInfrastructureTrafficClass;
	}

	const DistributedVirtualSwitchHostInfrastructureTrafficClass: DistributedVirtualSwitchHostInfrastructureTrafficClassConstructor;

	interface DistributedVirtualSwitchHostMemberHostComponentState extends VcDistributedVirtualSwitchHostMemberHostComponentState
	{
		name: any;

	}

	interface DistributedVirtualSwitchHostMemberHostComponentStateConstructor {
		new(value?:any): DistributedVirtualSwitchHostMemberHostComponentState;
		readonly prototype: DistributedVirtualSwitchHostMemberHostComponentState;
	}

	const DistributedVirtualSwitchHostMemberHostComponentState: DistributedVirtualSwitchHostMemberHostComponentStateConstructor;

	interface DistributedVirtualSwitchNetworkResourceControlVersion extends VcDistributedVirtualSwitchNetworkResourceControlVersion
	{
		name: any;

	}

	interface DistributedVirtualSwitchNetworkResourceControlVersionConstructor {
		new(value?:any): DistributedVirtualSwitchNetworkResourceControlVersion;
		readonly prototype: DistributedVirtualSwitchNetworkResourceControlVersion;
	}

	const DistributedVirtualSwitchNetworkResourceControlVersion: DistributedVirtualSwitchNetworkResourceControlVersionConstructor;

	interface DistributedVirtualSwitchNicTeamingPolicyMode extends VcDistributedVirtualSwitchNicTeamingPolicyMode
	{
		name: any;

	}

	interface DistributedVirtualSwitchNicTeamingPolicyModeConstructor {
		new(value?:any): DistributedVirtualSwitchNicTeamingPolicyMode;
		readonly prototype: DistributedVirtualSwitchNicTeamingPolicyMode;
	}

	const DistributedVirtualSwitchNicTeamingPolicyMode: DistributedVirtualSwitchNicTeamingPolicyModeConstructor;

	interface DistributedVirtualSwitchOverlayClassType extends VcDistributedVirtualSwitchOverlayClassType
	{
		name: any;

	}

	interface DistributedVirtualSwitchOverlayClassTypeConstructor {
		new(value?:any): DistributedVirtualSwitchOverlayClassType;
		readonly prototype: DistributedVirtualSwitchOverlayClassType;
	}

	const DistributedVirtualSwitchOverlayClassType: DistributedVirtualSwitchOverlayClassTypeConstructor;

	interface DistributedVirtualSwitchPortConnecteeConnecteeType extends VcDistributedVirtualSwitchPortConnecteeConnecteeType
	{
		name: any;

	}

	interface DistributedVirtualSwitchPortConnecteeConnecteeTypeConstructor {
		new(value?:any): DistributedVirtualSwitchPortConnecteeConnecteeType;
		readonly prototype: DistributedVirtualSwitchPortConnecteeConnecteeType;
	}

	const DistributedVirtualSwitchPortConnecteeConnecteeType: DistributedVirtualSwitchPortConnecteeConnecteeTypeConstructor;

	interface DistributedVirtualSwitchProductSpecOperationType extends VcDistributedVirtualSwitchProductSpecOperationType
	{
		name: any;

	}

	interface DistributedVirtualSwitchProductSpecOperationTypeConstructor {
		new(value?:any): DistributedVirtualSwitchProductSpecOperationType;
		readonly prototype: DistributedVirtualSwitchProductSpecOperationType;
	}

	const DistributedVirtualSwitchProductSpecOperationType: DistributedVirtualSwitchProductSpecOperationTypeConstructor;

	interface DpmBehavior extends VcDpmBehavior
	{
		name: any;

	}

	interface DpmBehaviorConstructor {
		new(value?:any): DpmBehavior;
		readonly prototype: DpmBehavior;
	}

	const DpmBehavior: DpmBehaviorConstructor;

	interface DrsBehavior extends VcDrsBehavior
	{
		name: any;

	}

	interface DrsBehaviorConstructor {
		new(value?:any): DrsBehavior;
		readonly prototype: DrsBehavior;
	}

	const DrsBehavior: DrsBehaviorConstructor;

	interface DrsInjectorWorkloadCorrelationState extends VcDrsInjectorWorkloadCorrelationState
	{
		name: any;

	}

	interface DrsInjectorWorkloadCorrelationStateConstructor {
		new(value?:any): DrsInjectorWorkloadCorrelationState;
		readonly prototype: DrsInjectorWorkloadCorrelationState;
	}

	const DrsInjectorWorkloadCorrelationState: DrsInjectorWorkloadCorrelationStateConstructor;

	interface DrsRecommendationReasonCode extends VcDrsRecommendationReasonCode
	{
		name: any;

	}

	interface DrsRecommendationReasonCodeConstructor {
		new(value?:any): DrsRecommendationReasonCode;
		readonly prototype: DrsRecommendationReasonCode;
	}

	const DrsRecommendationReasonCode: DrsRecommendationReasonCodeConstructor;

	interface DVPortStatusVmDirectPathGen2InactiveReasonNetwork extends VcDVPortStatusVmDirectPathGen2InactiveReasonNetwork
	{
		name: any;

	}

	interface DVPortStatusVmDirectPathGen2InactiveReasonNetworkConstructor {
		new(value?:any): DVPortStatusVmDirectPathGen2InactiveReasonNetwork;
		readonly prototype: DVPortStatusVmDirectPathGen2InactiveReasonNetwork;
	}

	const DVPortStatusVmDirectPathGen2InactiveReasonNetwork: DVPortStatusVmDirectPathGen2InactiveReasonNetworkConstructor;

	interface DVPortStatusVmDirectPathGen2InactiveReasonOther extends VcDVPortStatusVmDirectPathGen2InactiveReasonOther
	{
		name: any;

	}

	interface DVPortStatusVmDirectPathGen2InactiveReasonOtherConstructor {
		new(value?:any): DVPortStatusVmDirectPathGen2InactiveReasonOther;
		readonly prototype: DVPortStatusVmDirectPathGen2InactiveReasonOther;
	}

	const DVPortStatusVmDirectPathGen2InactiveReasonOther: DVPortStatusVmDirectPathGen2InactiveReasonOtherConstructor;

	interface DvsFilterOnFailure extends VcDvsFilterOnFailure
	{
		name: any;

	}

	interface DvsFilterOnFailureConstructor {
		new(value?:any): DvsFilterOnFailure;
		readonly prototype: DvsFilterOnFailure;
	}

	const DvsFilterOnFailure: DvsFilterOnFailureConstructor;

	interface DVSIPDiscoveryMethod extends VcDVSIPDiscoveryMethod
	{
		name: any;

	}

	interface DVSIPDiscoveryMethodConstructor {
		new(value?:any): DVSIPDiscoveryMethod;
		readonly prototype: DVSIPDiscoveryMethod;
	}

	const DVSIPDiscoveryMethod: DVSIPDiscoveryMethodConstructor;

	interface DvsNetworkRuleDirectionType extends VcDvsNetworkRuleDirectionType
	{
		name: any;

	}

	interface DvsNetworkRuleDirectionTypeConstructor {
		new(value?:any): DvsNetworkRuleDirectionType;
		readonly prototype: DvsNetworkRuleDirectionType;
	}

	const DvsNetworkRuleDirectionType: DvsNetworkRuleDirectionTypeConstructor;

	interface DvsNetworkRuleRedirectActionOption extends VcDvsNetworkRuleRedirectActionOption
	{
		name: any;

	}

	interface DvsNetworkRuleRedirectActionOptionConstructor {
		new(value?:any): DvsNetworkRuleRedirectActionOption;
		readonly prototype: DvsNetworkRuleRedirectActionOption;
	}

	const DvsNetworkRuleRedirectActionOption: DvsNetworkRuleRedirectActionOptionConstructor;

	interface EntityImportType extends VcEntityImportType
	{
		name: any;

	}

	interface EntityImportTypeConstructor {
		new(value?:any): EntityImportType;
		readonly prototype: EntityImportType;
	}

	const EntityImportType: EntityImportTypeConstructor;

	interface EntityType extends VcEntityType
	{
		name: any;

	}

	interface EntityTypeConstructor {
		new(value?:any): EntityType;
		readonly prototype: EntityType;
	}

	const EntityType: EntityTypeConstructor;

	interface EventAlarmExpressionComparisonOperator extends VcEventAlarmExpressionComparisonOperator
	{
		name: any;

	}

	interface EventAlarmExpressionComparisonOperatorConstructor {
		new(value?:any): EventAlarmExpressionComparisonOperator;
		readonly prototype: EventAlarmExpressionComparisonOperator;
	}

	const EventAlarmExpressionComparisonOperator: EventAlarmExpressionComparisonOperatorConstructor;

	interface EventCategory extends VcEventCategory
	{
		name: any;

	}

	interface EventCategoryConstructor {
		new(value?:any): EventCategory;
		readonly prototype: EventCategory;
	}

	const EventCategory: EventCategoryConstructor;

	interface EventEventSeverity extends VcEventEventSeverity
	{
		name: any;

	}

	interface EventEventSeverityConstructor {
		new(value?:any): EventEventSeverity;
		readonly prototype: EventEventSeverity;
	}

	const EventEventSeverity: EventEventSeverityConstructor;

	interface EventFilterSpecRecursionOption extends VcEventFilterSpecRecursionOption
	{
		name: any;

	}

	interface EventFilterSpecRecursionOptionConstructor {
		new(value?:any): EventFilterSpecRecursionOption;
		readonly prototype: EventFilterSpecRecursionOption;
	}

	const EventFilterSpecRecursionOption: EventFilterSpecRecursionOptionConstructor;

	interface FibreChannelPortType extends VcFibreChannelPortType
	{
		name: any;

	}

	interface FibreChannelPortTypeConstructor {
		new(value?:any): FibreChannelPortType;
		readonly prototype: FibreChannelPortType;
	}

	const FibreChannelPortType: FibreChannelPortTypeConstructor;

	interface FileSystemMountInfoVStorageSupportStatus extends VcFileSystemMountInfoVStorageSupportStatus
	{
		name: any;

	}

	interface FileSystemMountInfoVStorageSupportStatusConstructor {
		new(value?:any): FileSystemMountInfoVStorageSupportStatus;
		readonly prototype: FileSystemMountInfoVStorageSupportStatus;
	}

	const FileSystemMountInfoVStorageSupportStatus: FileSystemMountInfoVStorageSupportStatusConstructor;

	interface FtIssuesOnHostHostSelectionType extends VcFtIssuesOnHostHostSelectionType
	{
		name: any;

	}

	interface FtIssuesOnHostHostSelectionTypeConstructor {
		new(value?:any): FtIssuesOnHostHostSelectionType;
		readonly prototype: FtIssuesOnHostHostSelectionType;
	}

	const FtIssuesOnHostHostSelectionType: FtIssuesOnHostHostSelectionTypeConstructor;

	interface GuestFileType extends VcGuestFileType
	{
		name: any;

	}

	interface GuestFileTypeConstructor {
		new(value?:any): GuestFileType;
		readonly prototype: GuestFileType;
	}

	const GuestFileType: GuestFileTypeConstructor;

	interface GuestInfoAppStateType extends VcGuestInfoAppStateType
	{
		name: any;

	}

	interface GuestInfoAppStateTypeConstructor {
		new(value?:any): GuestInfoAppStateType;
		readonly prototype: GuestInfoAppStateType;
	}

	const GuestInfoAppStateType: GuestInfoAppStateTypeConstructor;

	interface GuestOsDescriptorFirmwareType extends VcGuestOsDescriptorFirmwareType
	{
		name: any;

	}

	interface GuestOsDescriptorFirmwareTypeConstructor {
		new(value?:any): GuestOsDescriptorFirmwareType;
		readonly prototype: GuestOsDescriptorFirmwareType;
	}

	const GuestOsDescriptorFirmwareType: GuestOsDescriptorFirmwareTypeConstructor;

	interface GuestOsDescriptorSupportLevel extends VcGuestOsDescriptorSupportLevel
	{
		name: any;

	}

	interface GuestOsDescriptorSupportLevelConstructor {
		new(value?:any): GuestOsDescriptorSupportLevel;
		readonly prototype: GuestOsDescriptorSupportLevel;
	}

	const GuestOsDescriptorSupportLevel: GuestOsDescriptorSupportLevelConstructor;

	interface GuestRegKeyWowSpec extends VcGuestRegKeyWowSpec
	{
		name: any;

	}

	interface GuestRegKeyWowSpecConstructor {
		new(value?:any): GuestRegKeyWowSpec;
		readonly prototype: GuestRegKeyWowSpec;
	}

	const GuestRegKeyWowSpec: GuestRegKeyWowSpecConstructor;

	interface HookManagerExtensionHealthRedAction extends VcHookManagerExtensionHealthRedAction
	{
		name: any;

	}

	interface HookManagerExtensionHealthRedActionConstructor {
		new(value?:any): HookManagerExtensionHealthRedAction;
		readonly prototype: HookManagerExtensionHealthRedAction;
	}

	const HookManagerExtensionHealthRedAction: HookManagerExtensionHealthRedActionConstructor;

	interface HookManagerExtensionHookDeclResult extends VcHookManagerExtensionHookDeclResult
	{
		name: any;

	}

	interface HookManagerExtensionHookDeclResultConstructor {
		new(value?:any): HookManagerExtensionHookDeclResult;
		readonly prototype: HookManagerExtensionHookDeclResult;
	}

	const HookManagerExtensionHookDeclResult: HookManagerExtensionHookDeclResultConstructor;

	interface HookManagerExtensionHookRemovalResult extends VcHookManagerExtensionHookRemovalResult
	{
		name: any;

	}

	interface HookManagerExtensionHookRemovalResultConstructor {
		new(value?:any): HookManagerExtensionHookRemovalResult;
		readonly prototype: HookManagerExtensionHookRemovalResult;
	}

	const HookManagerExtensionHookRemovalResult: HookManagerExtensionHookRemovalResultConstructor;

	interface HookManagerMethodHookAcquisitionResult extends VcHookManagerMethodHookAcquisitionResult
	{
		name: any;

	}

	interface HookManagerMethodHookAcquisitionResultConstructor {
		new(value?:any): HookManagerMethodHookAcquisitionResult;
		readonly prototype: HookManagerMethodHookAcquisitionResult;
	}

	const HookManagerMethodHookAcquisitionResult: HookManagerMethodHookAcquisitionResultConstructor;

	interface HookManagerMethodHookReleaseResult extends VcHookManagerMethodHookReleaseResult
	{
		name: any;

	}

	interface HookManagerMethodHookReleaseResultConstructor {
		new(value?:any): HookManagerMethodHookReleaseResult;
		readonly prototype: HookManagerMethodHookReleaseResult;
	}

	const HookManagerMethodHookReleaseResult: HookManagerMethodHookReleaseResultConstructor;

	interface HookManagerPostCallbackPolicy extends VcHookManagerPostCallbackPolicy
	{
		name: any;

	}

	interface HookManagerPostCallbackPolicyConstructor {
		new(value?:any): HookManagerPostCallbackPolicy;
		readonly prototype: HookManagerPostCallbackPolicy;
	}

	const HookManagerPostCallbackPolicy: HookManagerPostCallbackPolicyConstructor;

	interface HostAccessMode extends VcHostAccessMode
	{
		name: any;

	}

	interface HostAccessModeConstructor {
		new(value?:any): HostAccessMode;
		readonly prototype: HostAccessMode;
	}

	const HostAccessMode: HostAccessModeConstructor;

	interface HostActiveDirectoryAuthenticationCertificateDigest extends VcHostActiveDirectoryAuthenticationCertificateDigest
	{
		name: any;

	}

	interface HostActiveDirectoryAuthenticationCertificateDigestConstructor {
		new(value?:any): HostActiveDirectoryAuthenticationCertificateDigest;
		readonly prototype: HostActiveDirectoryAuthenticationCertificateDigest;
	}

	const HostActiveDirectoryAuthenticationCertificateDigest: HostActiveDirectoryAuthenticationCertificateDigestConstructor;

	interface HostActiveDirectoryInfoDomainMembershipStatus extends VcHostActiveDirectoryInfoDomainMembershipStatus
	{
		name: any;

	}

	interface HostActiveDirectoryInfoDomainMembershipStatusConstructor {
		new(value?:any): HostActiveDirectoryInfoDomainMembershipStatus;
		readonly prototype: HostActiveDirectoryInfoDomainMembershipStatus;
	}

	const HostActiveDirectoryInfoDomainMembershipStatus: HostActiveDirectoryInfoDomainMembershipStatusConstructor;

	interface HostCapabilityFtUnsupportedReason extends VcHostCapabilityFtUnsupportedReason
	{
		name: any;

	}

	interface HostCapabilityFtUnsupportedReasonConstructor {
		new(value?:any): HostCapabilityFtUnsupportedReason;
		readonly prototype: HostCapabilityFtUnsupportedReason;
	}

	const HostCapabilityFtUnsupportedReason: HostCapabilityFtUnsupportedReasonConstructor;

	interface HostCapabilityVmDirectPathGen2UnsupportedReason extends VcHostCapabilityVmDirectPathGen2UnsupportedReason
	{
		name: any;

	}

	interface HostCapabilityVmDirectPathGen2UnsupportedReasonConstructor {
		new(value?:any): HostCapabilityVmDirectPathGen2UnsupportedReason;
		readonly prototype: HostCapabilityVmDirectPathGen2UnsupportedReason;
	}

	const HostCapabilityVmDirectPathGen2UnsupportedReason: HostCapabilityVmDirectPathGen2UnsupportedReasonConstructor;

	interface HostCertificateManagerCertificateInfoCertificateStatus extends VcHostCertificateManagerCertificateInfoCertificateStatus
	{
		name: any;

	}

	interface HostCertificateManagerCertificateInfoCertificateStatusConstructor {
		new(value?:any): HostCertificateManagerCertificateInfoCertificateStatus;
		readonly prototype: HostCertificateManagerCertificateInfoCertificateStatus;
	}

	const HostCertificateManagerCertificateInfoCertificateStatus: HostCertificateManagerCertificateInfoCertificateStatusConstructor;

	interface HostConfigChangeMode extends VcHostConfigChangeMode
	{
		name: any;

	}

	interface HostConfigChangeModeConstructor {
		new(value?:any): HostConfigChangeMode;
		readonly prototype: HostConfigChangeMode;
	}

	const HostConfigChangeMode: HostConfigChangeModeConstructor;

	interface HostConfigChangeOperation extends VcHostConfigChangeOperation
	{
		name: any;

	}

	interface HostConfigChangeOperationConstructor {
		new(value?:any): HostConfigChangeOperation;
		readonly prototype: HostConfigChangeOperation;
	}

	const HostConfigChangeOperation: HostConfigChangeOperationConstructor;

	interface HostCpuPackageVendor extends VcHostCpuPackageVendor
	{
		name: any;

	}

	interface HostCpuPackageVendorConstructor {
		new(value?:any): HostCpuPackageVendor;
		readonly prototype: HostCpuPackageVendor;
	}

	const HostCpuPackageVendor: HostCpuPackageVendorConstructor;

	interface HostCpuPowerManagementInfoPolicyType extends VcHostCpuPowerManagementInfoPolicyType
	{
		name: any;

	}

	interface HostCpuPowerManagementInfoPolicyTypeConstructor {
		new(value?:any): HostCpuPowerManagementInfoPolicyType;
		readonly prototype: HostCpuPowerManagementInfoPolicyType;
	}

	const HostCpuPowerManagementInfoPolicyType: HostCpuPowerManagementInfoPolicyTypeConstructor;

	interface HostDasErrorEventHostDasErrorReason extends VcHostDasErrorEventHostDasErrorReason
	{
		name: any;

	}

	interface HostDasErrorEventHostDasErrorReasonConstructor {
		new(value?:any): HostDasErrorEventHostDasErrorReason;
		readonly prototype: HostDasErrorEventHostDasErrorReason;
	}

	const HostDasErrorEventHostDasErrorReason: HostDasErrorEventHostDasErrorReasonConstructor;

	interface HostDigestInfoDigestMethodType extends VcHostDigestInfoDigestMethodType
	{
		name: any;

	}

	interface HostDigestInfoDigestMethodTypeConstructor {
		new(value?:any): HostDigestInfoDigestMethodType;
		readonly prototype: HostDigestInfoDigestMethodType;
	}

	const HostDigestInfoDigestMethodType: HostDigestInfoDigestMethodTypeConstructor;

	interface HostDisconnectedEventReasonCode extends VcHostDisconnectedEventReasonCode
	{
		name: any;

	}

	interface HostDisconnectedEventReasonCodeConstructor {
		new(value?:any): HostDisconnectedEventReasonCode;
		readonly prototype: HostDisconnectedEventReasonCode;
	}

	const HostDisconnectedEventReasonCode: HostDisconnectedEventReasonCodeConstructor;

	interface HostDiskPartitionInfoPartitionFormat extends VcHostDiskPartitionInfoPartitionFormat
	{
		name: any;

	}

	interface HostDiskPartitionInfoPartitionFormatConstructor {
		new(value?:any): HostDiskPartitionInfoPartitionFormat;
		readonly prototype: HostDiskPartitionInfoPartitionFormat;
	}

	const HostDiskPartitionInfoPartitionFormat: HostDiskPartitionInfoPartitionFormatConstructor;

	interface HostDiskPartitionInfoType extends VcHostDiskPartitionInfoType
	{
		name: any;

	}

	interface HostDiskPartitionInfoTypeConstructor {
		new(value?:any): HostDiskPartitionInfoType;
		readonly prototype: HostDiskPartitionInfoType;
	}

	const HostDiskPartitionInfoType: HostDiskPartitionInfoTypeConstructor;

	interface HostDVPortEventEventCode extends VcHostDVPortEventEventCode
	{
		name: any;

	}

	interface HostDVPortEventEventCodeConstructor {
		new(value?:any): HostDVPortEventEventCode;
		readonly prototype: HostDVPortEventEventCode;
	}

	const HostDVPortEventEventCode: HostDVPortEventEventCodeConstructor;

	interface HostFeatureVersionKey extends VcHostFeatureVersionKey
	{
		name: any;

	}

	interface HostFeatureVersionKeyConstructor {
		new(value?:any): HostFeatureVersionKey;
		readonly prototype: HostFeatureVersionKey;
	}

	const HostFeatureVersionKey: HostFeatureVersionKeyConstructor;

	interface HostFileSystemVolumeFileSystemType extends VcHostFileSystemVolumeFileSystemType
	{
		name: any;

	}

	interface HostFileSystemVolumeFileSystemTypeConstructor {
		new(value?:any): HostFileSystemVolumeFileSystemType;
		readonly prototype: HostFileSystemVolumeFileSystemType;
	}

	const HostFileSystemVolumeFileSystemType: HostFileSystemVolumeFileSystemTypeConstructor;

	interface HostFirewallRuleDirection extends VcHostFirewallRuleDirection
	{
		name: any;

	}

	interface HostFirewallRuleDirectionConstructor {
		new(value?:any): HostFirewallRuleDirection;
		readonly prototype: HostFirewallRuleDirection;
	}

	const HostFirewallRuleDirection: HostFirewallRuleDirectionConstructor;

	interface HostFirewallRulePortType extends VcHostFirewallRulePortType
	{
		name: any;

	}

	interface HostFirewallRulePortTypeConstructor {
		new(value?:any): HostFirewallRulePortType;
		readonly prototype: HostFirewallRulePortType;
	}

	const HostFirewallRulePortType: HostFirewallRulePortTypeConstructor;

	interface HostFirewallRuleProtocol extends VcHostFirewallRuleProtocol
	{
		name: any;

	}

	interface HostFirewallRuleProtocolConstructor {
		new(value?:any): HostFirewallRuleProtocol;
		readonly prototype: HostFirewallRuleProtocol;
	}

	const HostFirewallRuleProtocol: HostFirewallRuleProtocolConstructor;

	interface HostFolder extends VcFolder
	{
		id: any;
		name: any;
		vimHost: any;

		getComputeResource_ClusterComputeResource(): ClusterComputeResource;
		getComputeResource_ComputeResource(): ComputeResource;
		getFolder(): HostFolder;
	}

	interface HostFolderConstructor {
		new(value?:any): HostFolder;
		readonly prototype: HostFolder;
	}

	const HostFolder: HostFolderConstructor;

	interface HostGraphicsInfoGraphicsType extends VcHostGraphicsInfoGraphicsType
	{
		name: any;

	}

	interface HostGraphicsInfoGraphicsTypeConstructor {
		new(value?:any): HostGraphicsInfoGraphicsType;
		readonly prototype: HostGraphicsInfoGraphicsType;
	}

	const HostGraphicsInfoGraphicsType: HostGraphicsInfoGraphicsTypeConstructor;

	interface HostHardwareElementStatus extends VcHostHardwareElementStatus
	{
		name: any;

	}

	interface HostHardwareElementStatusConstructor {
		new(value?:any): HostHardwareElementStatus;
		readonly prototype: HostHardwareElementStatus;
	}

	const HostHardwareElementStatus: HostHardwareElementStatusConstructor;

	interface HostHasComponentFailureHostComponentType extends VcHostHasComponentFailureHostComponentType
	{
		name: any;

	}

	interface HostHasComponentFailureHostComponentTypeConstructor {
		new(value?:any): HostHasComponentFailureHostComponentType;
		readonly prototype: HostHasComponentFailureHostComponentType;
	}

	const HostHasComponentFailureHostComponentType: HostHasComponentFailureHostComponentTypeConstructor;

	interface HostImageAcceptanceLevel extends VcHostImageAcceptanceLevel
	{
		name: any;

	}

	interface HostImageAcceptanceLevelConstructor {
		new(value?:any): HostImageAcceptanceLevel;
		readonly prototype: HostImageAcceptanceLevel;
	}

	const HostImageAcceptanceLevel: HostImageAcceptanceLevelConstructor;

	interface HostIncompatibleForFaultToleranceReason extends VcHostIncompatibleForFaultToleranceReason
	{
		name: any;

	}

	interface HostIncompatibleForFaultToleranceReasonConstructor {
		new(value?:any): HostIncompatibleForFaultToleranceReason;
		readonly prototype: HostIncompatibleForFaultToleranceReason;
	}

	const HostIncompatibleForFaultToleranceReason: HostIncompatibleForFaultToleranceReasonConstructor;

	interface HostIncompatibleForRecordReplayReason extends VcHostIncompatibleForRecordReplayReason
	{
		name: any;

	}

	interface HostIncompatibleForRecordReplayReasonConstructor {
		new(value?:any): HostIncompatibleForRecordReplayReason;
		readonly prototype: HostIncompatibleForRecordReplayReason;
	}

	const HostIncompatibleForRecordReplayReason: HostIncompatibleForRecordReplayReasonConstructor;

	interface HostInternetScsiHbaChapAuthenticationType extends VcHostInternetScsiHbaChapAuthenticationType
	{
		name: any;

	}

	interface HostInternetScsiHbaChapAuthenticationTypeConstructor {
		new(value?:any): HostInternetScsiHbaChapAuthenticationType;
		readonly prototype: HostInternetScsiHbaChapAuthenticationType;
	}

	const HostInternetScsiHbaChapAuthenticationType: HostInternetScsiHbaChapAuthenticationTypeConstructor;

	interface HostInternetScsiHbaDigestType extends VcHostInternetScsiHbaDigestType
	{
		name: any;

	}

	interface HostInternetScsiHbaDigestTypeConstructor {
		new(value?:any): HostInternetScsiHbaDigestType;
		readonly prototype: HostInternetScsiHbaDigestType;
	}

	const HostInternetScsiHbaDigestType: HostInternetScsiHbaDigestTypeConstructor;

	interface HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType extends VcHostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType
	{
		name: any;

	}

	interface HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationTypeConstructor {
		new(value?:any): HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
		readonly prototype: HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType;
	}

	const HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType: HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationTypeConstructor;

	interface HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation extends VcHostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation
	{
		name: any;

	}

	interface HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperationConstructor {
		new(value?:any): HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
		readonly prototype: HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation;
	}

	const HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation: HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperationConstructor;

	interface HostInternetScsiHbaNetworkBindingSupportType extends VcHostInternetScsiHbaNetworkBindingSupportType
	{
		name: any;

	}

	interface HostInternetScsiHbaNetworkBindingSupportTypeConstructor {
		new(value?:any): HostInternetScsiHbaNetworkBindingSupportType;
		readonly prototype: HostInternetScsiHbaNetworkBindingSupportType;
	}

	const HostInternetScsiHbaNetworkBindingSupportType: HostInternetScsiHbaNetworkBindingSupportTypeConstructor;

	interface HostInternetScsiHbaStaticTargetTargetDiscoveryMethod extends VcHostInternetScsiHbaStaticTargetTargetDiscoveryMethod
	{
		name: any;

	}

	interface HostInternetScsiHbaStaticTargetTargetDiscoveryMethodConstructor {
		new(value?:any): HostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
		readonly prototype: HostInternetScsiHbaStaticTargetTargetDiscoveryMethod;
	}

	const HostInternetScsiHbaStaticTargetTargetDiscoveryMethod: HostInternetScsiHbaStaticTargetTargetDiscoveryMethodConstructor;

	interface HostIpConfigIpV6AddressConfigType extends VcHostIpConfigIpV6AddressConfigType
	{
		name: any;

	}

	interface HostIpConfigIpV6AddressConfigTypeConstructor {
		new(value?:any): HostIpConfigIpV6AddressConfigType;
		readonly prototype: HostIpConfigIpV6AddressConfigType;
	}

	const HostIpConfigIpV6AddressConfigType: HostIpConfigIpV6AddressConfigTypeConstructor;

	interface HostIpConfigIpV6AddressStatus extends VcHostIpConfigIpV6AddressStatus
	{
		name: any;

	}

	interface HostIpConfigIpV6AddressStatusConstructor {
		new(value?:any): HostIpConfigIpV6AddressStatus;
		readonly prototype: HostIpConfigIpV6AddressStatus;
	}

	const HostIpConfigIpV6AddressStatus: HostIpConfigIpV6AddressStatusConstructor;

	interface HostIpSecConfigEncryptionAlgorithm extends VcHostIpSecConfigEncryptionAlgorithm
	{
		name: any;

	}

	interface HostIpSecConfigEncryptionAlgorithmConstructor {
		new(value?:any): HostIpSecConfigEncryptionAlgorithm;
		readonly prototype: HostIpSecConfigEncryptionAlgorithm;
	}

	const HostIpSecConfigEncryptionAlgorithm: HostIpSecConfigEncryptionAlgorithmConstructor;

	interface HostIpSecConfigIntegrityAlgorithm extends VcHostIpSecConfigIntegrityAlgorithm
	{
		name: any;

	}

	interface HostIpSecConfigIntegrityAlgorithmConstructor {
		new(value?:any): HostIpSecConfigIntegrityAlgorithm;
		readonly prototype: HostIpSecConfigIntegrityAlgorithm;
	}

	const HostIpSecConfigIntegrityAlgorithm: HostIpSecConfigIntegrityAlgorithmConstructor;

	interface HostIpSecConfigIpSecSAMode extends VcHostIpSecConfigIpSecSAMode
	{
		name: any;

	}

	interface HostIpSecConfigIpSecSAModeConstructor {
		new(value?:any): HostIpSecConfigIpSecSAMode;
		readonly prototype: HostIpSecConfigIpSecSAMode;
	}

	const HostIpSecConfigIpSecSAMode: HostIpSecConfigIpSecSAModeConstructor;

	interface HostIpSecConfigSAKeyingType extends VcHostIpSecConfigSAKeyingType
	{
		name: any;

	}

	interface HostIpSecConfigSAKeyingTypeConstructor {
		new(value?:any): HostIpSecConfigSAKeyingType;
		readonly prototype: HostIpSecConfigSAKeyingType;
	}

	const HostIpSecConfigSAKeyingType: HostIpSecConfigSAKeyingTypeConstructor;

	interface HostIpSecConfigUpperLayerProtocolType extends VcHostIpSecConfigUpperLayerProtocolType
	{
		name: any;

	}

	interface HostIpSecConfigUpperLayerProtocolTypeConstructor {
		new(value?:any): HostIpSecConfigUpperLayerProtocolType;
		readonly prototype: HostIpSecConfigUpperLayerProtocolType;
	}

	const HostIpSecConfigUpperLayerProtocolType: HostIpSecConfigUpperLayerProtocolTypeConstructor;

	interface HostLicensableResourceKey extends VcHostLicensableResourceKey
	{
		name: any;

	}

	interface HostLicensableResourceKeyConstructor {
		new(value?:any): HostLicensableResourceKey;
		readonly prototype: HostLicensableResourceKey;
	}

	const HostLicensableResourceKey: HostLicensableResourceKeyConstructor;

	interface HostLockdownMode extends VcHostLockdownMode
	{
		name: any;

	}

	interface HostLockdownModeConstructor {
		new(value?:any): HostLockdownMode;
		readonly prototype: HostLockdownMode;
	}

	const HostLockdownMode: HostLockdownModeConstructor;

	interface HostLowLevelProvisioningManagerFileType extends VcHostLowLevelProvisioningManagerFileType
	{
		name: any;

	}

	interface HostLowLevelProvisioningManagerFileTypeConstructor {
		new(value?:any): HostLowLevelProvisioningManagerFileType;
		readonly prototype: HostLowLevelProvisioningManagerFileType;
	}

	const HostLowLevelProvisioningManagerFileType: HostLowLevelProvisioningManagerFileTypeConstructor;

	interface HostLowLevelProvisioningManagerReloadTarget extends VcHostLowLevelProvisioningManagerReloadTarget
	{
		name: any;

	}

	interface HostLowLevelProvisioningManagerReloadTargetConstructor {
		new(value?:any): HostLowLevelProvisioningManagerReloadTarget;
		readonly prototype: HostLowLevelProvisioningManagerReloadTarget;
	}

	const HostLowLevelProvisioningManagerReloadTarget: HostLowLevelProvisioningManagerReloadTargetConstructor;

	interface HostMountInfoInaccessibleReason extends VcHostMountInfoInaccessibleReason
	{
		name: any;

	}

	interface HostMountInfoInaccessibleReasonConstructor {
		new(value?:any): HostMountInfoInaccessibleReason;
		readonly prototype: HostMountInfoInaccessibleReason;
	}

	const HostMountInfoInaccessibleReason: HostMountInfoInaccessibleReasonConstructor;

	interface HostMountMode extends VcHostMountMode
	{
		name: any;

	}

	interface HostMountModeConstructor {
		new(value?:any): HostMountMode;
		readonly prototype: HostMountMode;
	}

	const HostMountMode: HostMountModeConstructor;

	interface HostNasVolumeSecurityType extends VcHostNasVolumeSecurityType
	{
		name: any;

	}

	interface HostNasVolumeSecurityTypeConstructor {
		new(value?:any): HostNasVolumeSecurityType;
		readonly prototype: HostNasVolumeSecurityType;
	}

	const HostNasVolumeSecurityType: HostNasVolumeSecurityTypeConstructor;

	interface HostNetStackInstanceCongestionControlAlgorithmType extends VcHostNetStackInstanceCongestionControlAlgorithmType
	{
		name: any;

	}

	interface HostNetStackInstanceCongestionControlAlgorithmTypeConstructor {
		new(value?:any): HostNetStackInstanceCongestionControlAlgorithmType;
		readonly prototype: HostNetStackInstanceCongestionControlAlgorithmType;
	}

	const HostNetStackInstanceCongestionControlAlgorithmType: HostNetStackInstanceCongestionControlAlgorithmTypeConstructor;

	interface HostNetStackInstanceSystemStackKey extends VcHostNetStackInstanceSystemStackKey
	{
		name: any;

	}

	interface HostNetStackInstanceSystemStackKeyConstructor {
		new(value?:any): HostNetStackInstanceSystemStackKey;
		readonly prototype: HostNetStackInstanceSystemStackKey;
	}

	const HostNetStackInstanceSystemStackKey: HostNetStackInstanceSystemStackKeyConstructor;

	interface HostNumericSensorHealthState extends VcHostNumericSensorHealthState
	{
		name: any;

	}

	interface HostNumericSensorHealthStateConstructor {
		new(value?:any): HostNumericSensorHealthState;
		readonly prototype: HostNumericSensorHealthState;
	}

	const HostNumericSensorHealthState: HostNumericSensorHealthStateConstructor;

	interface HostNumericSensorType extends VcHostNumericSensorType
	{
		name: any;

	}

	interface HostNumericSensorTypeConstructor {
		new(value?:any): HostNumericSensorType;
		readonly prototype: HostNumericSensorType;
	}

	const HostNumericSensorType: HostNumericSensorTypeConstructor;

	interface HostOpaqueSwitchOpaqueSwitchState extends VcHostOpaqueSwitchOpaqueSwitchState
	{
		name: any;

	}

	interface HostOpaqueSwitchOpaqueSwitchStateConstructor {
		new(value?:any): HostOpaqueSwitchOpaqueSwitchState;
		readonly prototype: HostOpaqueSwitchOpaqueSwitchState;
	}

	const HostOpaqueSwitchOpaqueSwitchState: HostOpaqueSwitchOpaqueSwitchStateConstructor;

	interface HostPatchManagerInstallState extends VcHostPatchManagerInstallState
	{
		name: any;

	}

	interface HostPatchManagerInstallStateConstructor {
		new(value?:any): HostPatchManagerInstallState;
		readonly prototype: HostPatchManagerInstallState;
	}

	const HostPatchManagerInstallState: HostPatchManagerInstallStateConstructor;

	interface HostPatchManagerIntegrityStatus extends VcHostPatchManagerIntegrityStatus
	{
		name: any;

	}

	interface HostPatchManagerIntegrityStatusConstructor {
		new(value?:any): HostPatchManagerIntegrityStatus;
		readonly prototype: HostPatchManagerIntegrityStatus;
	}

	const HostPatchManagerIntegrityStatus: HostPatchManagerIntegrityStatusConstructor;

	interface HostPatchManagerReason extends VcHostPatchManagerReason
	{
		name: any;

	}

	interface HostPatchManagerReasonConstructor {
		new(value?:any): HostPatchManagerReason;
		readonly prototype: HostPatchManagerReason;
	}

	const HostPatchManagerReason: HostPatchManagerReasonConstructor;

	interface HostPowerOperationType extends VcHostPowerOperationType
	{
		name: any;

	}

	interface HostPowerOperationTypeConstructor {
		new(value?:any): HostPowerOperationType;
		readonly prototype: HostPowerOperationType;
	}

	const HostPowerOperationType: HostPowerOperationTypeConstructor;

	interface HostProfileManagerAnswerFileStatus extends VcHostProfileManagerAnswerFileStatus
	{
		name: any;

	}

	interface HostProfileManagerAnswerFileStatusConstructor {
		new(value?:any): HostProfileManagerAnswerFileStatus;
		readonly prototype: HostProfileManagerAnswerFileStatus;
	}

	const HostProfileManagerAnswerFileStatus: HostProfileManagerAnswerFileStatusConstructor;

	interface HostProfileManagerTaskListRequirement extends VcHostProfileManagerTaskListRequirement
	{
		name: any;

	}

	interface HostProfileManagerTaskListRequirementConstructor {
		new(value?:any): HostProfileManagerTaskListRequirement;
		readonly prototype: HostProfileManagerTaskListRequirement;
	}

	const HostProfileManagerTaskListRequirement: HostProfileManagerTaskListRequirementConstructor;

	interface HostProtocolEndpointPEType extends VcHostProtocolEndpointPEType
	{
		name: any;

	}

	interface HostProtocolEndpointPETypeConstructor {
		new(value?:any): HostProtocolEndpointPEType;
		readonly prototype: HostProtocolEndpointPEType;
	}

	const HostProtocolEndpointPEType: HostProtocolEndpointPETypeConstructor;

	interface HostReplayUnsupportedReason extends VcHostReplayUnsupportedReason
	{
		name: any;

	}

	interface HostReplayUnsupportedReasonConstructor {
		new(value?:any): HostReplayUnsupportedReason;
		readonly prototype: HostReplayUnsupportedReason;
	}

	const HostReplayUnsupportedReason: HostReplayUnsupportedReasonConstructor;

	interface HostRuntimeInfoNetStackInstanceRuntimeInfoState extends VcHostRuntimeInfoNetStackInstanceRuntimeInfoState
	{
		name: any;

	}

	interface HostRuntimeInfoNetStackInstanceRuntimeInfoStateConstructor {
		new(value?:any): HostRuntimeInfoNetStackInstanceRuntimeInfoState;
		readonly prototype: HostRuntimeInfoNetStackInstanceRuntimeInfoState;
	}

	const HostRuntimeInfoNetStackInstanceRuntimeInfoState: HostRuntimeInfoNetStackInstanceRuntimeInfoStateConstructor;

	interface HostServicePolicy extends VcHostServicePolicy
	{
		name: any;

	}

	interface HostServicePolicyConstructor {
		new(value?:any): HostServicePolicy;
		readonly prototype: HostServicePolicy;
	}

	const HostServicePolicy: HostServicePolicyConstructor;

	interface HostSnmpAgentCapability extends VcHostSnmpAgentCapability
	{
		name: any;

	}

	interface HostSnmpAgentCapabilityConstructor {
		new(value?:any): HostSnmpAgentCapability;
		readonly prototype: HostSnmpAgentCapability;
	}

	const HostSnmpAgentCapability: HostSnmpAgentCapabilityConstructor;

	interface HostStandbyMode extends VcHostStandbyMode
	{
		name: any;

	}

	interface HostStandbyModeConstructor {
		new(value?:any): HostStandbyMode;
		readonly prototype: HostStandbyMode;
	}

	const HostStandbyMode: HostStandbyModeConstructor;

	interface HostSystem extends VcHostSystem
	{
		id: any;
		name: any;
		state: any;
		version: any;
		vimHost: any;

		getDatastore(): Datastore;
		getNetwork(): Network;
		getNetwork_DistributedVirtualPortgroup(): DistributedVirtualPortgroup;
		getNetwork_Network(): Network;
		getRecentTask(): Task;
		getVm(): VirtualMachine;
	}

	interface HostSystemConstructor {
		new(value?:any): HostSystem;
		readonly prototype: HostSystem;
	}

	const HostSystem: HostSystemConstructor;

	interface HostSystemConnectionState extends VcHostSystemConnectionState
	{
		name: any;

	}

	interface HostSystemConnectionStateConstructor {
		new(value?:any): HostSystemConnectionState;
		readonly prototype: HostSystemConnectionState;
	}

	const HostSystemConnectionState: HostSystemConnectionStateConstructor;

	interface HostSystemIdentificationInfoIdentifier extends VcHostSystemIdentificationInfoIdentifier
	{
		name: any;

	}

	interface HostSystemIdentificationInfoIdentifierConstructor {
		new(value?:any): HostSystemIdentificationInfoIdentifier;
		readonly prototype: HostSystemIdentificationInfoIdentifier;
	}

	const HostSystemIdentificationInfoIdentifier: HostSystemIdentificationInfoIdentifierConstructor;

	interface HostSystemPowerState extends VcHostSystemPowerState
	{
		name: any;

	}

	interface HostSystemPowerStateConstructor {
		new(value?:any): HostSystemPowerState;
		readonly prototype: HostSystemPowerState;
	}

	const HostSystemPowerState: HostSystemPowerStateConstructor;

	interface HostUnresolvedVmfsExtentUnresolvedReason extends VcHostUnresolvedVmfsExtentUnresolvedReason
	{
		name: any;

	}

	interface HostUnresolvedVmfsExtentUnresolvedReasonConstructor {
		new(value?:any): HostUnresolvedVmfsExtentUnresolvedReason;
		readonly prototype: HostUnresolvedVmfsExtentUnresolvedReason;
	}

	const HostUnresolvedVmfsExtentUnresolvedReason: HostUnresolvedVmfsExtentUnresolvedReasonConstructor;

	interface HostUnresolvedVmfsResolutionSpecVmfsUuidResolution extends VcHostUnresolvedVmfsResolutionSpecVmfsUuidResolution
	{
		name: any;

	}

	interface HostUnresolvedVmfsResolutionSpecVmfsUuidResolutionConstructor {
		new(value?:any): HostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
		readonly prototype: HostUnresolvedVmfsResolutionSpecVmfsUuidResolution;
	}

	const HostUnresolvedVmfsResolutionSpecVmfsUuidResolution: HostUnresolvedVmfsResolutionSpecVmfsUuidResolutionConstructor;

	interface HostVirtualNicManagerNicType extends VcHostVirtualNicManagerNicType
	{
		name: any;

	}

	interface HostVirtualNicManagerNicTypeConstructor {
		new(value?:any): HostVirtualNicManagerNicType;
		readonly prototype: HostVirtualNicManagerNicType;
	}

	const HostVirtualNicManagerNicType: HostVirtualNicManagerNicTypeConstructor;

	interface HostVmciAccessManagerMode extends VcHostVmciAccessManagerMode
	{
		name: any;

	}

	interface HostVmciAccessManagerModeConstructor {
		new(value?:any): HostVmciAccessManagerMode;
		readonly prototype: HostVmciAccessManagerMode;
	}

	const HostVmciAccessManagerMode: HostVmciAccessManagerModeConstructor;

	interface HttpNfcLeaseState extends VcHttpNfcLeaseState
	{
		name: any;

	}

	interface HttpNfcLeaseStateConstructor {
		new(value?:any): HttpNfcLeaseState;
		readonly prototype: HttpNfcLeaseState;
	}

	const HttpNfcLeaseState: HttpNfcLeaseStateConstructor;

	interface IncompatibleHostForVmReplicationIncompatibleReason extends VcIncompatibleHostForVmReplicationIncompatibleReason
	{
		name: any;

	}

	interface IncompatibleHostForVmReplicationIncompatibleReasonConstructor {
		new(value?:any): IncompatibleHostForVmReplicationIncompatibleReason;
		readonly prototype: IncompatibleHostForVmReplicationIncompatibleReason;
	}

	const IncompatibleHostForVmReplicationIncompatibleReason: IncompatibleHostForVmReplicationIncompatibleReasonConstructor;

	interface InternetScsiSnsDiscoveryMethod extends VcInternetScsiSnsDiscoveryMethod
	{
		name: any;

	}

	interface InternetScsiSnsDiscoveryMethodConstructor {
		new(value?:any): InternetScsiSnsDiscoveryMethod;
		readonly prototype: InternetScsiSnsDiscoveryMethod;
	}

	const InternetScsiSnsDiscoveryMethod: InternetScsiSnsDiscoveryMethodConstructor;

	interface InvalidDasConfigArgumentEntryForInvalidArgument extends VcInvalidDasConfigArgumentEntryForInvalidArgument
	{
		name: any;

	}

	interface InvalidDasConfigArgumentEntryForInvalidArgumentConstructor {
		new(value?:any): InvalidDasConfigArgumentEntryForInvalidArgument;
		readonly prototype: InvalidDasConfigArgumentEntryForInvalidArgument;
	}

	const InvalidDasConfigArgumentEntryForInvalidArgument: InvalidDasConfigArgumentEntryForInvalidArgumentConstructor;

	interface InvalidProfileReferenceHostReason extends VcInvalidProfileReferenceHostReason
	{
		name: any;

	}

	interface InvalidProfileReferenceHostReasonConstructor {
		new(value?:any): InvalidProfileReferenceHostReason;
		readonly prototype: InvalidProfileReferenceHostReason;
	}

	const InvalidProfileReferenceHostReason: InvalidProfileReferenceHostReasonConstructor;

	interface IoFilterOperation extends VcIoFilterOperation
	{
		name: any;

	}

	interface IoFilterOperationConstructor {
		new(value?:any): IoFilterOperation;
		readonly prototype: IoFilterOperation;
	}

	const IoFilterOperation: IoFilterOperationConstructor;

	interface IscsiPortInfoPathStatus extends VcIscsiPortInfoPathStatus
	{
		name: any;

	}

	interface IscsiPortInfoPathStatusConstructor {
		new(value?:any): IscsiPortInfoPathStatus;
		readonly prototype: IscsiPortInfoPathStatus;
	}

	const IscsiPortInfoPathStatus: IscsiPortInfoPathStatusConstructor;

	interface LatencySensitivitySensitivityLevel extends VcLatencySensitivitySensitivityLevel
	{
		name: any;

	}

	interface LatencySensitivitySensitivityLevelConstructor {
		new(value?:any): LatencySensitivitySensitivityLevel;
		readonly prototype: LatencySensitivitySensitivityLevel;
	}

	const LatencySensitivitySensitivityLevel: LatencySensitivitySensitivityLevelConstructor;

	interface LicenseAssignmentFailedReason extends VcLicenseAssignmentFailedReason
	{
		name: any;

	}

	interface LicenseAssignmentFailedReasonConstructor {
		new(value?:any): LicenseAssignmentFailedReason;
		readonly prototype: LicenseAssignmentFailedReason;
	}

	const LicenseAssignmentFailedReason: LicenseAssignmentFailedReasonConstructor;

	interface LicenseFeatureInfoSourceRestriction extends VcLicenseFeatureInfoSourceRestriction
	{
		name: any;

	}

	interface LicenseFeatureInfoSourceRestrictionConstructor {
		new(value?:any): LicenseFeatureInfoSourceRestriction;
		readonly prototype: LicenseFeatureInfoSourceRestriction;
	}

	const LicenseFeatureInfoSourceRestriction: LicenseFeatureInfoSourceRestrictionConstructor;

	interface LicenseFeatureInfoState extends VcLicenseFeatureInfoState
	{
		name: any;

	}

	interface LicenseFeatureInfoStateConstructor {
		new(value?:any): LicenseFeatureInfoState;
		readonly prototype: LicenseFeatureInfoState;
	}

	const LicenseFeatureInfoState: LicenseFeatureInfoStateConstructor;

	interface LicenseFeatureInfoUnit extends VcLicenseFeatureInfoUnit
	{
		name: any;

	}

	interface LicenseFeatureInfoUnitConstructor {
		new(value?:any): LicenseFeatureInfoUnit;
		readonly prototype: LicenseFeatureInfoUnit;
	}

	const LicenseFeatureInfoUnit: LicenseFeatureInfoUnitConstructor;

	interface LicenseManagerLicenseKey extends VcLicenseManagerLicenseKey
	{
		name: any;

	}

	interface LicenseManagerLicenseKeyConstructor {
		new(value?:any): LicenseManagerLicenseKey;
		readonly prototype: LicenseManagerLicenseKey;
	}

	const LicenseManagerLicenseKey: LicenseManagerLicenseKeyConstructor;

	interface LicenseManagerState extends VcLicenseManagerState
	{
		name: any;

	}

	interface LicenseManagerStateConstructor {
		new(value?:any): LicenseManagerState;
		readonly prototype: LicenseManagerState;
	}

	const LicenseManagerState: LicenseManagerStateConstructor;

	interface LicenseReservationInfoState extends VcLicenseReservationInfoState
	{
		name: any;

	}

	interface LicenseReservationInfoStateConstructor {
		new(value?:any): LicenseReservationInfoState;
		readonly prototype: LicenseReservationInfoState;
	}

	const LicenseReservationInfoState: LicenseReservationInfoStateConstructor;

	interface LinkDiscoveryProtocolConfigOperationType extends VcLinkDiscoveryProtocolConfigOperationType
	{
		name: any;

	}

	interface LinkDiscoveryProtocolConfigOperationTypeConstructor {
		new(value?:any): LinkDiscoveryProtocolConfigOperationType;
		readonly prototype: LinkDiscoveryProtocolConfigOperationType;
	}

	const LinkDiscoveryProtocolConfigOperationType: LinkDiscoveryProtocolConfigOperationTypeConstructor;

	interface LinkDiscoveryProtocolConfigProtocolType extends VcLinkDiscoveryProtocolConfigProtocolType
	{
		name: any;

	}

	interface LinkDiscoveryProtocolConfigProtocolTypeConstructor {
		new(value?:any): LinkDiscoveryProtocolConfigProtocolType;
		readonly prototype: LinkDiscoveryProtocolConfigProtocolType;
	}

	const LinkDiscoveryProtocolConfigProtocolType: LinkDiscoveryProtocolConfigProtocolTypeConstructor;

	interface ManagedEntityStatus extends VcManagedEntityStatus
	{
		name: any;

	}

	interface ManagedEntityStatusConstructor {
		new(value?:any): ManagedEntityStatus;
		readonly prototype: ManagedEntityStatus;
	}

	const ManagedEntityStatus: ManagedEntityStatusConstructor;

	interface MetricAlarmOperator extends VcMetricAlarmOperator
	{
		name: any;

	}

	interface MetricAlarmOperatorConstructor {
		new(value?:any): MetricAlarmOperator;
		readonly prototype: MetricAlarmOperator;
	}

	const MetricAlarmOperator: MetricAlarmOperatorConstructor;

	interface MultipathState extends VcMultipathState
	{
		name: any;

	}

	interface MultipathStateConstructor {
		new(value?:any): MultipathState;
		readonly prototype: MultipathState;
	}

	const MultipathState: MultipathStateConstructor;

	interface NetBIOSConfigInfoMode extends VcNetBIOSConfigInfoMode
	{
		name: any;

	}

	interface NetBIOSConfigInfoModeConstructor {
		new(value?:any): NetBIOSConfigInfoMode;
		readonly prototype: NetBIOSConfigInfoMode;
	}

	const NetBIOSConfigInfoMode: NetBIOSConfigInfoModeConstructor;

	interface NetIpConfigInfoIpAddressOrigin extends VcNetIpConfigInfoIpAddressOrigin
	{
		name: any;

	}

	interface NetIpConfigInfoIpAddressOriginConstructor {
		new(value?:any): NetIpConfigInfoIpAddressOrigin;
		readonly prototype: NetIpConfigInfoIpAddressOrigin;
	}

	const NetIpConfigInfoIpAddressOrigin: NetIpConfigInfoIpAddressOriginConstructor;

	interface NetIpConfigInfoIpAddressStatus extends VcNetIpConfigInfoIpAddressStatus
	{
		name: any;

	}

	interface NetIpConfigInfoIpAddressStatusConstructor {
		new(value?:any): NetIpConfigInfoIpAddressStatus;
		readonly prototype: NetIpConfigInfoIpAddressStatus;
	}

	const NetIpConfigInfoIpAddressStatus: NetIpConfigInfoIpAddressStatusConstructor;

	interface NetIpStackInfoEntryType extends VcNetIpStackInfoEntryType
	{
		name: any;

	}

	interface NetIpStackInfoEntryTypeConstructor {
		new(value?:any): NetIpStackInfoEntryType;
		readonly prototype: NetIpStackInfoEntryType;
	}

	const NetIpStackInfoEntryType: NetIpStackInfoEntryTypeConstructor;

	interface NetIpStackInfoPreference extends VcNetIpStackInfoPreference
	{
		name: any;

	}

	interface NetIpStackInfoPreferenceConstructor {
		new(value?:any): NetIpStackInfoPreference;
		readonly prototype: NetIpStackInfoPreference;
	}

	const NetIpStackInfoPreference: NetIpStackInfoPreferenceConstructor;

	interface Network extends VcNetwork
	{
		accessible: any;
		id: any;
		name: any;
		vimHost: any;

		getHost(): HostSystem;
		getRecentTask(): Task;
		getVm(): VirtualMachine;
	}

	interface NetworkConstructor {
		new(value?:any): Network;
		readonly prototype: Network;
	}

	const Network: NetworkConstructor;

	interface NetworkFolder extends VcFolder
	{
		id: any;
		name: any;
		vimHost: any;

		getDistributedVirtualSwitch_DistributedVirtualSwitch(): DistributedVirtualSwitch;
		getDistributedVirtualSwitch_VmwareDistributedVirtualSwitch(): VmwareDistributedVirtualSwitch;
		getFolder(): NetworkFolder;
		getNetwork(): Network;
		getNetwork_DistributedVirtualPortgroup(): DistributedVirtualPortgroup;
		getNetwork_Network(): Network;
	}

	interface NetworkFolderConstructor {
		new(value?:any): NetworkFolder;
		readonly prototype: NetworkFolder;
	}

	const NetworkFolder: NetworkFolderConstructor;

	interface NotSupportedDeviceForFTDeviceType extends VcNotSupportedDeviceForFTDeviceType
	{
		name: any;

	}

	interface NotSupportedDeviceForFTDeviceTypeConstructor {
		new(value?:any): NotSupportedDeviceForFTDeviceType;
		readonly prototype: NotSupportedDeviceForFTDeviceType;
	}

	const NotSupportedDeviceForFTDeviceType: NotSupportedDeviceForFTDeviceTypeConstructor;

	interface NumVirtualCpusIncompatibleReason extends VcNumVirtualCpusIncompatibleReason
	{
		name: any;

	}

	interface NumVirtualCpusIncompatibleReasonConstructor {
		new(value?:any): NumVirtualCpusIncompatibleReason;
		readonly prototype: NumVirtualCpusIncompatibleReason;
	}

	const NumVirtualCpusIncompatibleReason: NumVirtualCpusIncompatibleReasonConstructor;

	interface ObjectUpdateKind extends VcObjectUpdateKind
	{
		name: any;

	}

	interface ObjectUpdateKindConstructor {
		new(value?:any): ObjectUpdateKind;
		readonly prototype: ObjectUpdateKind;
	}

	const ObjectUpdateKind: ObjectUpdateKindConstructor;

	interface OpaqueNetwork extends VcOpaqueNetwork
	{
		accessible: any;
		id: any;
		name: any;
		vimHost: any;

		getHost(): HostSystem;
		getRecentTask(): Task;
		getVm(): VirtualMachine;
	}

	interface OpaqueNetworkConstructor {
		new(value?:any): OpaqueNetwork;
		readonly prototype: OpaqueNetwork;
	}

	const OpaqueNetwork: OpaqueNetworkConstructor;

	interface OvfConsumerOstNodeType extends VcOvfConsumerOstNodeType
	{
		name: any;

	}

	interface OvfConsumerOstNodeTypeConstructor {
		new(value?:any): OvfConsumerOstNodeType;
		readonly prototype: OvfConsumerOstNodeType;
	}

	const OvfConsumerOstNodeType: OvfConsumerOstNodeTypeConstructor;

	interface OvfCreateImportSpecParamsDiskProvisioningType extends VcOvfCreateImportSpecParamsDiskProvisioningType
	{
		name: any;

	}

	interface OvfCreateImportSpecParamsDiskProvisioningTypeConstructor {
		new(value?:any): OvfCreateImportSpecParamsDiskProvisioningType;
		readonly prototype: OvfCreateImportSpecParamsDiskProvisioningType;
	}

	const OvfCreateImportSpecParamsDiskProvisioningType: OvfCreateImportSpecParamsDiskProvisioningTypeConstructor;

	interface PerfFormat extends VcPerfFormat
	{
		name: any;

	}

	interface PerfFormatConstructor {
		new(value?:any): PerfFormat;
		readonly prototype: PerfFormat;
	}

	const PerfFormat: PerfFormatConstructor;

	interface PerformanceManagerUnit extends VcPerformanceManagerUnit
	{
		name: any;

	}

	interface PerformanceManagerUnitConstructor {
		new(value?:any): PerformanceManagerUnit;
		readonly prototype: PerformanceManagerUnit;
	}

	const PerformanceManagerUnit: PerformanceManagerUnitConstructor;

	interface PerfStatsType extends VcPerfStatsType
	{
		name: any;

	}

	interface PerfStatsTypeConstructor {
		new(value?:any): PerfStatsType;
		readonly prototype: PerfStatsType;
	}

	const PerfStatsType: PerfStatsTypeConstructor;

	interface PerfSummaryType extends VcPerfSummaryType
	{
		name: any;

	}

	interface PerfSummaryTypeConstructor {
		new(value?:any): PerfSummaryType;
		readonly prototype: PerfSummaryType;
	}

	const PerfSummaryType: PerfSummaryTypeConstructor;

	interface PhysicalNicResourcePoolSchedulerDisallowedReason extends VcPhysicalNicResourcePoolSchedulerDisallowedReason
	{
		name: any;

	}

	interface PhysicalNicResourcePoolSchedulerDisallowedReasonConstructor {
		new(value?:any): PhysicalNicResourcePoolSchedulerDisallowedReason;
		readonly prototype: PhysicalNicResourcePoolSchedulerDisallowedReason;
	}

	const PhysicalNicResourcePoolSchedulerDisallowedReason: PhysicalNicResourcePoolSchedulerDisallowedReasonConstructor;

	interface PhysicalNicVmDirectPathGen2SupportedMode extends VcPhysicalNicVmDirectPathGen2SupportedMode
	{
		name: any;

	}

	interface PhysicalNicVmDirectPathGen2SupportedModeConstructor {
		new(value?:any): PhysicalNicVmDirectPathGen2SupportedMode;
		readonly prototype: PhysicalNicVmDirectPathGen2SupportedMode;
	}

	const PhysicalNicVmDirectPathGen2SupportedMode: PhysicalNicVmDirectPathGen2SupportedModeConstructor;

	interface PlacementAffinityRuleRuleScope extends VcPlacementAffinityRuleRuleScope
	{
		name: any;

	}

	interface PlacementAffinityRuleRuleScopeConstructor {
		new(value?:any): PlacementAffinityRuleRuleScope;
		readonly prototype: PlacementAffinityRuleRuleScope;
	}

	const PlacementAffinityRuleRuleScope: PlacementAffinityRuleRuleScopeConstructor;

	interface PlacementAffinityRuleRuleType extends VcPlacementAffinityRuleRuleType
	{
		name: any;

	}

	interface PlacementAffinityRuleRuleTypeConstructor {
		new(value?:any): PlacementAffinityRuleRuleType;
		readonly prototype: PlacementAffinityRuleRuleType;
	}

	const PlacementAffinityRuleRuleType: PlacementAffinityRuleRuleTypeConstructor;

	interface PlacementSpecPlacementType extends VcPlacementSpecPlacementType
	{
		name: any;

	}

	interface PlacementSpecPlacementTypeConstructor {
		new(value?:any): PlacementSpecPlacementType;
		readonly prototype: PlacementSpecPlacementType;
	}

	const PlacementSpecPlacementType: PlacementSpecPlacementTypeConstructor;

	interface PortGroupConnecteeType extends VcPortGroupConnecteeType
	{
		name: any;

	}

	interface PortGroupConnecteeTypeConstructor {
		new(value?:any): PortGroupConnecteeType;
		readonly prototype: PortGroupConnecteeType;
	}

	const PortGroupConnecteeType: PortGroupConnecteeTypeConstructor;

	interface PoweredOnCloneNotSupportedUnsupportedOperation extends VcPoweredOnCloneNotSupportedUnsupportedOperation
	{
		name: any;

	}

	interface PoweredOnCloneNotSupportedUnsupportedOperationConstructor {
		new(value?:any): PoweredOnCloneNotSupportedUnsupportedOperation;
		readonly prototype: PoweredOnCloneNotSupportedUnsupportedOperation;
	}

	const PoweredOnCloneNotSupportedUnsupportedOperation: PoweredOnCloneNotSupportedUnsupportedOperationConstructor;

	interface PreCallbackResultResult extends VcPreCallbackResultResult
	{
		name: any;

	}

	interface PreCallbackResultResultConstructor {
		new(value?:any): PreCallbackResultResult;
		readonly prototype: PreCallbackResultResult;
	}

	const PreCallbackResultResult: PreCallbackResultResultConstructor;

	interface ProfileExecuteResultStatus extends VcProfileExecuteResultStatus
	{
		name: any;

	}

	interface ProfileExecuteResultStatusConstructor {
		new(value?:any): ProfileExecuteResultStatus;
		readonly prototype: ProfileExecuteResultStatus;
	}

	const ProfileExecuteResultStatus: ProfileExecuteResultStatusConstructor;

	interface ProfileNumericComparator extends VcProfileNumericComparator
	{
		name: any;

	}

	interface ProfileNumericComparatorConstructor {
		new(value?:any): ProfileNumericComparator;
		readonly prototype: ProfileNumericComparator;
	}

	const ProfileNumericComparator: ProfileNumericComparatorConstructor;

	interface PropertyChangeOp extends VcPropertyChangeOp
	{
		name: any;

	}

	interface PropertyChangeOpConstructor {
		new(value?:any): PropertyChangeOp;
		readonly prototype: PropertyChangeOp;
	}

	const PropertyChangeOp: PropertyChangeOpConstructor;

	interface QuiesceMode extends VcQuiesceMode
	{
		name: any;

	}

	interface QuiesceModeConstructor {
		new(value?:any): QuiesceMode;
		readonly prototype: QuiesceMode;
	}

	const QuiesceMode: QuiesceModeConstructor;

	interface RangeComparator extends VcRangeComparator
	{
		name: any;

	}

	interface RangeComparatorConstructor {
		new(value?:any): RangeComparator;
		readonly prototype: RangeComparator;
	}

	const RangeComparator: RangeComparatorConstructor;

	interface RecommendationReasonCode extends VcRecommendationReasonCode
	{
		name: any;

	}

	interface RecommendationReasonCodeConstructor {
		new(value?:any): RecommendationReasonCode;
		readonly prototype: RecommendationReasonCode;
	}

	const RecommendationReasonCode: RecommendationReasonCodeConstructor;

	interface RecommendationType extends VcRecommendationType
	{
		name: any;

	}

	interface RecommendationTypeConstructor {
		new(value?:any): RecommendationType;
		readonly prototype: RecommendationType;
	}

	const RecommendationType: RecommendationTypeConstructor;

	interface ReplicationDiskConfigFaultReasonForFault extends VcReplicationDiskConfigFaultReasonForFault
	{
		name: any;

	}

	interface ReplicationDiskConfigFaultReasonForFaultConstructor {
		new(value?:any): ReplicationDiskConfigFaultReasonForFault;
		readonly prototype: ReplicationDiskConfigFaultReasonForFault;
	}

	const ReplicationDiskConfigFaultReasonForFault: ReplicationDiskConfigFaultReasonForFaultConstructor;

	interface ReplicationVmConfigFaultReasonForFault extends VcReplicationVmConfigFaultReasonForFault
	{
		name: any;

	}

	interface ReplicationVmConfigFaultReasonForFaultConstructor {
		new(value?:any): ReplicationVmConfigFaultReasonForFault;
		readonly prototype: ReplicationVmConfigFaultReasonForFault;
	}

	const ReplicationVmConfigFaultReasonForFault: ReplicationVmConfigFaultReasonForFaultConstructor;

	interface ReplicationVmFaultReasonForFault extends VcReplicationVmFaultReasonForFault
	{
		name: any;

	}

	interface ReplicationVmFaultReasonForFaultConstructor {
		new(value?:any): ReplicationVmFaultReasonForFault;
		readonly prototype: ReplicationVmFaultReasonForFault;
	}

	const ReplicationVmFaultReasonForFault: ReplicationVmFaultReasonForFaultConstructor;

	interface ReplicationVmInProgressFaultActivity extends VcReplicationVmInProgressFaultActivity
	{
		name: any;

	}

	interface ReplicationVmInProgressFaultActivityConstructor {
		new(value?:any): ReplicationVmInProgressFaultActivity;
		readonly prototype: ReplicationVmInProgressFaultActivity;
	}

	const ReplicationVmInProgressFaultActivity: ReplicationVmInProgressFaultActivityConstructor;

	interface ReplicationVmState extends VcReplicationVmState
	{
		name: any;

	}

	interface ReplicationVmStateConstructor {
		new(value?:any): ReplicationVmState;
		readonly prototype: ReplicationVmState;
	}

	const ReplicationVmState: ReplicationVmStateConstructor;

	interface ResourcePool extends VcResourcePool
	{
		cpuReservation: any;
		id: any;
		memoryReservation: any;
		name: any;
		vimHost: any;

		getOwner(): ComputeResource;
		getRecentTask(): Task;
		getResourcePool(): ResourcePool;
		getResourcePool_ResourcePool(): ResourcePool;
		getResourcePool_VirtualApp(): VirtualApp;
		getVm(): VirtualMachine;
	}

	interface ResourcePoolConstructor {
		new(value?:any): ResourcePool;
		readonly prototype: ResourcePool;
	}

	const ResourcePool: ResourcePoolConstructor;

	interface ResourceType extends VcResourceType
	{
		name: any;

	}

	interface ResourceTypeConstructor {
		new(value?:any): ResourceType;
		readonly prototype: ResourceType;
	}

	const ResourceType: ResourceTypeConstructor;

	interface ScheduledHardwareUpgradeInfoHardwareUpgradePolicy extends VcScheduledHardwareUpgradeInfoHardwareUpgradePolicy
	{
		name: any;

	}

	interface ScheduledHardwareUpgradeInfoHardwareUpgradePolicyConstructor {
		new(value?:any): ScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
		readonly prototype: ScheduledHardwareUpgradeInfoHardwareUpgradePolicy;
	}

	const ScheduledHardwareUpgradeInfoHardwareUpgradePolicy: ScheduledHardwareUpgradeInfoHardwareUpgradePolicyConstructor;

	interface ScheduledHardwareUpgradeInfoHardwareUpgradeStatus extends VcScheduledHardwareUpgradeInfoHardwareUpgradeStatus
	{
		name: any;

	}

	interface ScheduledHardwareUpgradeInfoHardwareUpgradeStatusConstructor {
		new(value?:any): ScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
		readonly prototype: ScheduledHardwareUpgradeInfoHardwareUpgradeStatus;
	}

	const ScheduledHardwareUpgradeInfoHardwareUpgradeStatus: ScheduledHardwareUpgradeInfoHardwareUpgradeStatusConstructor;

	interface ScsiLunDescriptorQuality extends VcScsiLunDescriptorQuality
	{
		name: any;

	}

	interface ScsiLunDescriptorQualityConstructor {
		new(value?:any): ScsiLunDescriptorQuality;
		readonly prototype: ScsiLunDescriptorQuality;
	}

	const ScsiLunDescriptorQuality: ScsiLunDescriptorQualityConstructor;

	interface ScsiLunState extends VcScsiLunState
	{
		name: any;

	}

	interface ScsiLunStateConstructor {
		new(value?:any): ScsiLunState;
		readonly prototype: ScsiLunState;
	}

	const ScsiLunState: ScsiLunStateConstructor;

	interface ScsiLunType extends VcScsiLunType
	{
		name: any;

	}

	interface ScsiLunTypeConstructor {
		new(value?:any): ScsiLunType;
		readonly prototype: ScsiLunType;
	}

	const ScsiLunType: ScsiLunTypeConstructor;

	interface ScsiLunVStorageSupportStatus extends VcScsiLunVStorageSupportStatus
	{
		name: any;

	}

	interface ScsiLunVStorageSupportStatusConstructor {
		new(value?:any): ScsiLunVStorageSupportStatus;
		readonly prototype: ScsiLunVStorageSupportStatus;
	}

	const ScsiLunVStorageSupportStatus: ScsiLunVStorageSupportStatusConstructor;

	interface SdkConnection extends VcSdkConnection
	{
		displayName: any;
		instanceUuid: any;
		name: any;

		getRootFolder(): DatacenterFolder;
	}

	interface SdkConnectionConstructor {
		new(value?:any): SdkConnection;
		readonly prototype: SdkConnection;
	}

	const SdkConnection: SdkConnectionConstructor;

	interface SessionManagerHttpServiceRequestSpecMethod extends VcSessionManagerHttpServiceRequestSpecMethod
	{
		name: any;

	}

	interface SessionManagerHttpServiceRequestSpecMethodConstructor {
		new(value?:any): SessionManagerHttpServiceRequestSpecMethod;
		readonly prototype: SessionManagerHttpServiceRequestSpecMethod;
	}

	const SessionManagerHttpServiceRequestSpecMethod: SessionManagerHttpServiceRequestSpecMethodConstructor;

	interface SharesLevel extends VcSharesLevel
	{
		name: any;

	}

	interface SharesLevelConstructor {
		new(value?:any): SharesLevel;
		readonly prototype: SharesLevel;
	}

	const SharesLevel: SharesLevelConstructor;

	interface SimpleCommandEncoding extends VcSimpleCommandEncoding
	{
		name: any;

	}

	interface SimpleCommandEncodingConstructor {
		new(value?:any): SimpleCommandEncoding;
		readonly prototype: SimpleCommandEncoding;
	}

	const SimpleCommandEncoding: SimpleCommandEncodingConstructor;

	interface SlpDiscoveryMethod extends VcSlpDiscoveryMethod
	{
		name: any;

	}

	interface SlpDiscoveryMethodConstructor {
		new(value?:any): SlpDiscoveryMethod;
		readonly prototype: SlpDiscoveryMethod;
	}

	const SlpDiscoveryMethod: SlpDiscoveryMethodConstructor;

	interface StateAlarmOperator extends VcStateAlarmOperator
	{
		name: any;

	}

	interface StateAlarmOperatorConstructor {
		new(value?:any): StateAlarmOperator;
		readonly prototype: StateAlarmOperator;
	}

	const StateAlarmOperator: StateAlarmOperatorConstructor;

	interface StorageDrsPodConfigInfoBehavior extends VcStorageDrsPodConfigInfoBehavior
	{
		name: any;

	}

	interface StorageDrsPodConfigInfoBehaviorConstructor {
		new(value?:any): StorageDrsPodConfigInfoBehavior;
		readonly prototype: StorageDrsPodConfigInfoBehavior;
	}

	const StorageDrsPodConfigInfoBehavior: StorageDrsPodConfigInfoBehaviorConstructor;

	interface StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode extends VcStorageDrsSpaceLoadBalanceConfigSpaceThresholdMode
	{
		name: any;

	}

	interface StorageDrsSpaceLoadBalanceConfigSpaceThresholdModeConstructor {
		new(value?:any): StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
		readonly prototype: StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode;
	}

	const StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode: StorageDrsSpaceLoadBalanceConfigSpaceThresholdModeConstructor;

	interface StorageIORMThresholdMode extends VcStorageIORMThresholdMode
	{
		name: any;

	}

	interface StorageIORMThresholdModeConstructor {
		new(value?:any): StorageIORMThresholdMode;
		readonly prototype: StorageIORMThresholdMode;
	}

	const StorageIORMThresholdMode: StorageIORMThresholdModeConstructor;

	interface StoragePlacementSpecPlacementType extends VcStoragePlacementSpecPlacementType
	{
		name: any;

	}

	interface StoragePlacementSpecPlacementTypeConstructor {
		new(value?:any): StoragePlacementSpecPlacementType;
		readonly prototype: StoragePlacementSpecPlacementType;
	}

	const StoragePlacementSpecPlacementType: StoragePlacementSpecPlacementTypeConstructor;

	interface StoragePod extends VcStoragePod
	{
		id: any;
		name: any;
		vimHost: any;

		getDatastore(): Datastore;
		getRecentTask(): Task;
	}

	interface StoragePodConstructor {
		new(value?:any): StoragePod;
		readonly prototype: StoragePod;
	}

	const StoragePod: StoragePodConstructor;

	interface Task extends VcTask
	{
		id: any;
		name: any;
		state: any;
		vimHost: any;

	}

	interface TaskConstructor {
		new(value?:any): Task;
		readonly prototype: Task;
	}

	const Task: TaskConstructor;

	interface TaskFilterSpecRecursionOption extends VcTaskFilterSpecRecursionOption
	{
		name: any;

	}

	interface TaskFilterSpecRecursionOptionConstructor {
		new(value?:any): TaskFilterSpecRecursionOption;
		readonly prototype: TaskFilterSpecRecursionOption;
	}

	const TaskFilterSpecRecursionOption: TaskFilterSpecRecursionOptionConstructor;

	interface TaskFilterSpecTimeOption extends VcTaskFilterSpecTimeOption
	{
		name: any;

	}

	interface TaskFilterSpecTimeOptionConstructor {
		new(value?:any): TaskFilterSpecTimeOption;
		readonly prototype: TaskFilterSpecTimeOption;
	}

	const TaskFilterSpecTimeOption: TaskFilterSpecTimeOptionConstructor;

	interface TaskInfoState extends VcTaskInfoState
	{
		name: any;

	}

	interface TaskInfoStateConstructor {
		new(value?:any): TaskInfoState;
		readonly prototype: TaskInfoState;
	}

	const TaskInfoState: TaskInfoStateConstructor;

	interface TestletFaultSeverity extends VcTestletFaultSeverity
	{
		name: any;

	}

	interface TestletFaultSeverityConstructor {
		new(value?:any): TestletFaultSeverity;
		readonly prototype: TestletFaultSeverity;
	}

	const TestletFaultSeverity: TestletFaultSeverityConstructor;

	interface ThirdPartyLicenseAssignmentFailedReason extends VcThirdPartyLicenseAssignmentFailedReason
	{
		name: any;

	}

	interface ThirdPartyLicenseAssignmentFailedReasonConstructor {
		new(value?:any): ThirdPartyLicenseAssignmentFailedReason;
		readonly prototype: ThirdPartyLicenseAssignmentFailedReason;
	}

	const ThirdPartyLicenseAssignmentFailedReason: ThirdPartyLicenseAssignmentFailedReasonConstructor;

	interface UpgradePolicy extends VcUpgradePolicy
	{
		name: any;

	}

	interface UpgradePolicyConstructor {
		new(value?:any): UpgradePolicy;
		readonly prototype: UpgradePolicy;
	}

	const UpgradePolicy: UpgradePolicyConstructor;

	interface ValidateMigrationTestType extends VcValidateMigrationTestType
	{
		name: any;

	}

	interface ValidateMigrationTestTypeConstructor {
		new(value?:any): ValidateMigrationTestType;
		readonly prototype: ValidateMigrationTestType;
	}

	const ValidateMigrationTestType: ValidateMigrationTestTypeConstructor;

	interface VAppAutoStartAction extends VcVAppAutoStartAction
	{
		name: any;

	}

	interface VAppAutoStartActionConstructor {
		new(value?:any): VAppAutoStartAction;
		readonly prototype: VAppAutoStartAction;
	}

	const VAppAutoStartAction: VAppAutoStartActionConstructor;

	interface VAppCloneSpecProvisioningType extends VcVAppCloneSpecProvisioningType
	{
		name: any;

	}

	interface VAppCloneSpecProvisioningTypeConstructor {
		new(value?:any): VAppCloneSpecProvisioningType;
		readonly prototype: VAppCloneSpecProvisioningType;
	}

	const VAppCloneSpecProvisioningType: VAppCloneSpecProvisioningTypeConstructor;

	interface VAppIPAssignmentInfoAllocationSchemes extends VcVAppIPAssignmentInfoAllocationSchemes
	{
		name: any;

	}

	interface VAppIPAssignmentInfoAllocationSchemesConstructor {
		new(value?:any): VAppIPAssignmentInfoAllocationSchemes;
		readonly prototype: VAppIPAssignmentInfoAllocationSchemes;
	}

	const VAppIPAssignmentInfoAllocationSchemes: VAppIPAssignmentInfoAllocationSchemesConstructor;

	interface VAppIPAssignmentInfoIpAllocationPolicy extends VcVAppIPAssignmentInfoIpAllocationPolicy
	{
		name: any;

	}

	interface VAppIPAssignmentInfoIpAllocationPolicyConstructor {
		new(value?:any): VAppIPAssignmentInfoIpAllocationPolicy;
		readonly prototype: VAppIPAssignmentInfoIpAllocationPolicy;
	}

	const VAppIPAssignmentInfoIpAllocationPolicy: VAppIPAssignmentInfoIpAllocationPolicyConstructor;

	interface VAppIPAssignmentInfoProtocols extends VcVAppIPAssignmentInfoProtocols
	{
		name: any;

	}

	interface VAppIPAssignmentInfoProtocolsConstructor {
		new(value?:any): VAppIPAssignmentInfoProtocols;
		readonly prototype: VAppIPAssignmentInfoProtocols;
	}

	const VAppIPAssignmentInfoProtocols: VAppIPAssignmentInfoProtocolsConstructor;

	interface VFlashModuleNotSupportedReason extends VcVFlashModuleNotSupportedReason
	{
		name: any;

	}

	interface VFlashModuleNotSupportedReasonConstructor {
		new(value?:any): VFlashModuleNotSupportedReason;
		readonly prototype: VFlashModuleNotSupportedReason;
	}

	const VFlashModuleNotSupportedReason: VFlashModuleNotSupportedReasonConstructor;

	interface VirtualApp extends VcVirtualApp
	{
		cpuReservation: any;
		id: any;
		memoryReservation: any;
		name: any;
		vimHost: any;

		getDatastore(): Datastore;
		getNetwork(): Network;
		getOwner(): ComputeResource;
		getParentFolder(): VmFolder;
		getRecentTask(): Task;
		getResourcePool(): ResourcePool;
		getResourcePool_ResourcePool(): ResourcePool;
		getResourcePool_VirtualApp(): VirtualApp;
		getVm(): VirtualMachine;
	}

	interface VirtualAppConstructor {
		new(value?:any): VirtualApp;
		readonly prototype: VirtualApp;
	}

	const VirtualApp: VirtualAppConstructor;

	interface VirtualAppVAppState extends VcVirtualAppVAppState
	{
		name: any;

	}

	interface VirtualAppVAppStateConstructor {
		new(value?:any): VirtualAppVAppState;
		readonly prototype: VirtualAppVAppState;
	}

	const VirtualAppVAppState: VirtualAppVAppStateConstructor;

	interface VirtualDeviceConfigSpecFileOperation extends VcVirtualDeviceConfigSpecFileOperation
	{
		name: any;

	}

	interface VirtualDeviceConfigSpecFileOperationConstructor {
		new(value?:any): VirtualDeviceConfigSpecFileOperation;
		readonly prototype: VirtualDeviceConfigSpecFileOperation;
	}

	const VirtualDeviceConfigSpecFileOperation: VirtualDeviceConfigSpecFileOperationConstructor;

	interface VirtualDeviceConfigSpecOperation extends VcVirtualDeviceConfigSpecOperation
	{
		name: any;

	}

	interface VirtualDeviceConfigSpecOperationConstructor {
		new(value?:any): VirtualDeviceConfigSpecOperation;
		readonly prototype: VirtualDeviceConfigSpecOperation;
	}

	const VirtualDeviceConfigSpecOperation: VirtualDeviceConfigSpecOperationConstructor;

	interface VirtualDeviceConnectInfoStatus extends VcVirtualDeviceConnectInfoStatus
	{
		name: any;

	}

	interface VirtualDeviceConnectInfoStatusConstructor {
		new(value?:any): VirtualDeviceConnectInfoStatus;
		readonly prototype: VirtualDeviceConnectInfoStatus;
	}

	const VirtualDeviceConnectInfoStatus: VirtualDeviceConnectInfoStatusConstructor;

	interface VirtualDeviceFileExtension extends VcVirtualDeviceFileExtension
	{
		name: any;

	}

	interface VirtualDeviceFileExtensionConstructor {
		new(value?:any): VirtualDeviceFileExtension;
		readonly prototype: VirtualDeviceFileExtension;
	}

	const VirtualDeviceFileExtension: VirtualDeviceFileExtensionConstructor;

	interface VirtualDeviceURIBackingOptionDirection extends VcVirtualDeviceURIBackingOptionDirection
	{
		name: any;

	}

	interface VirtualDeviceURIBackingOptionDirectionConstructor {
		new(value?:any): VirtualDeviceURIBackingOptionDirection;
		readonly prototype: VirtualDeviceURIBackingOptionDirection;
	}

	const VirtualDeviceURIBackingOptionDirection: VirtualDeviceURIBackingOptionDirectionConstructor;

	interface VirtualDiskAdapterType extends VcVirtualDiskAdapterType
	{
		name: any;

	}

	interface VirtualDiskAdapterTypeConstructor {
		new(value?:any): VirtualDiskAdapterType;
		readonly prototype: VirtualDiskAdapterType;
	}

	const VirtualDiskAdapterType: VirtualDiskAdapterTypeConstructor;

	interface VirtualDiskCompatibilityMode extends VcVirtualDiskCompatibilityMode
	{
		name: any;

	}

	interface VirtualDiskCompatibilityModeConstructor {
		new(value?:any): VirtualDiskCompatibilityMode;
		readonly prototype: VirtualDiskCompatibilityMode;
	}

	const VirtualDiskCompatibilityMode: VirtualDiskCompatibilityModeConstructor;

	interface VirtualDiskDeltaDiskFormat extends VcVirtualDiskDeltaDiskFormat
	{
		name: any;

	}

	interface VirtualDiskDeltaDiskFormatConstructor {
		new(value?:any): VirtualDiskDeltaDiskFormat;
		readonly prototype: VirtualDiskDeltaDiskFormat;
	}

	const VirtualDiskDeltaDiskFormat: VirtualDiskDeltaDiskFormatConstructor;

	interface VirtualDiskDeltaDiskFormatVariant extends VcVirtualDiskDeltaDiskFormatVariant
	{
		name: any;

	}

	interface VirtualDiskDeltaDiskFormatVariantConstructor {
		new(value?:any): VirtualDiskDeltaDiskFormatVariant;
		readonly prototype: VirtualDiskDeltaDiskFormatVariant;
	}

	const VirtualDiskDeltaDiskFormatVariant: VirtualDiskDeltaDiskFormatVariantConstructor;

	interface VirtualDiskMode extends VcVirtualDiskMode
	{
		name: any;

	}

	interface VirtualDiskModeConstructor {
		new(value?:any): VirtualDiskMode;
		readonly prototype: VirtualDiskMode;
	}

	const VirtualDiskMode: VirtualDiskModeConstructor;

	interface VirtualDiskSharing extends VcVirtualDiskSharing
	{
		name: any;

	}

	interface VirtualDiskSharingConstructor {
		new(value?:any): VirtualDiskSharing;
		readonly prototype: VirtualDiskSharing;
	}

	const VirtualDiskSharing: VirtualDiskSharingConstructor;

	interface VirtualDiskType extends VcVirtualDiskType
	{
		name: any;

	}

	interface VirtualDiskTypeConstructor {
		new(value?:any): VirtualDiskType;
		readonly prototype: VirtualDiskType;
	}

	const VirtualDiskType: VirtualDiskTypeConstructor;

	interface VirtualDiskVFlashCacheConfigInfoCacheConsistencyType extends VcVirtualDiskVFlashCacheConfigInfoCacheConsistencyType
	{
		name: any;

	}

	interface VirtualDiskVFlashCacheConfigInfoCacheConsistencyTypeConstructor {
		new(value?:any): VirtualDiskVFlashCacheConfigInfoCacheConsistencyType;
		readonly prototype: VirtualDiskVFlashCacheConfigInfoCacheConsistencyType;
	}

	const VirtualDiskVFlashCacheConfigInfoCacheConsistencyType: VirtualDiskVFlashCacheConfigInfoCacheConsistencyTypeConstructor;

	interface VirtualDiskVFlashCacheConfigInfoCacheMode extends VcVirtualDiskVFlashCacheConfigInfoCacheMode
	{
		name: any;

	}

	interface VirtualDiskVFlashCacheConfigInfoCacheModeConstructor {
		new(value?:any): VirtualDiskVFlashCacheConfigInfoCacheMode;
		readonly prototype: VirtualDiskVFlashCacheConfigInfoCacheMode;
	}

	const VirtualDiskVFlashCacheConfigInfoCacheMode: VirtualDiskVFlashCacheConfigInfoCacheModeConstructor;

	interface VirtualEthernetCardLegacyNetworkDeviceName extends VcVirtualEthernetCardLegacyNetworkDeviceName
	{
		name: any;

	}

	interface VirtualEthernetCardLegacyNetworkDeviceNameConstructor {
		new(value?:any): VirtualEthernetCardLegacyNetworkDeviceName;
		readonly prototype: VirtualEthernetCardLegacyNetworkDeviceName;
	}

	const VirtualEthernetCardLegacyNetworkDeviceName: VirtualEthernetCardLegacyNetworkDeviceNameConstructor;

	interface VirtualEthernetCardMacType extends VcVirtualEthernetCardMacType
	{
		name: any;

	}

	interface VirtualEthernetCardMacTypeConstructor {
		new(value?:any): VirtualEthernetCardMacType;
		readonly prototype: VirtualEthernetCardMacType;
	}

	const VirtualEthernetCardMacType: VirtualEthernetCardMacTypeConstructor;

	interface VirtualMachine extends VcVirtualMachine
	{
		annotation: any;
		committedStorage: any;
		connectionState: any;
		cpu: any;
		guestMemoryUsage: any;
		guestOS: any;
		hostMemoryUsage: any;
		hostName: any;
		id: any;
		ipAddress: any;
		isTemplate: any;
		memory: any;
		memoryOverhead: any;
		name: any;
		overallCpuUsage: any;
		productfullVersion: any;
		productName: any;
		productVendor: any;
		state: any;
		totalStorage: any;
		unsharedStorage: any;
		vimHost: any;
		vmToolsStatus: any;
		vmToolsVersionStatus: any;
		vmVersion: any;

		getDatastore(): Datastore;
		getNetwork(): Network;
		getRecentTask(): Task;
		getResourcePool(): ResourcePool;
		getRootSnapshot(): VirtualMachineSnapshot;
		getVmSnapshot(): VirtualMachineSnapshot;
	}

	interface VirtualMachineConstructor {
		new(value?:any): VirtualMachine;
		readonly prototype: VirtualMachine;
	}

	const VirtualMachine: VirtualMachineConstructor;

	interface VirtualMachineAppHeartbeatStatusType extends VcVirtualMachineAppHeartbeatStatusType
	{
		name: any;

	}

	interface VirtualMachineAppHeartbeatStatusTypeConstructor {
		new(value?:any): VirtualMachineAppHeartbeatStatusType;
		readonly prototype: VirtualMachineAppHeartbeatStatusType;
	}

	const VirtualMachineAppHeartbeatStatusType: VirtualMachineAppHeartbeatStatusTypeConstructor;

	interface VirtualMachineBootOptionsNetworkBootProtocolType extends VcVirtualMachineBootOptionsNetworkBootProtocolType
	{
		name: any;

	}

	interface VirtualMachineBootOptionsNetworkBootProtocolTypeConstructor {
		new(value?:any): VirtualMachineBootOptionsNetworkBootProtocolType;
		readonly prototype: VirtualMachineBootOptionsNetworkBootProtocolType;
	}

	const VirtualMachineBootOptionsNetworkBootProtocolType: VirtualMachineBootOptionsNetworkBootProtocolTypeConstructor;

	interface VirtualMachineConfigInfoNpivWwnType extends VcVirtualMachineConfigInfoNpivWwnType
	{
		name: any;

	}

	interface VirtualMachineConfigInfoNpivWwnTypeConstructor {
		new(value?:any): VirtualMachineConfigInfoNpivWwnType;
		readonly prototype: VirtualMachineConfigInfoNpivWwnType;
	}

	const VirtualMachineConfigInfoNpivWwnType: VirtualMachineConfigInfoNpivWwnTypeConstructor;

	interface VirtualMachineConfigInfoSwapPlacementType extends VcVirtualMachineConfigInfoSwapPlacementType
	{
		name: any;

	}

	interface VirtualMachineConfigInfoSwapPlacementTypeConstructor {
		new(value?:any): VirtualMachineConfigInfoSwapPlacementType;
		readonly prototype: VirtualMachineConfigInfoSwapPlacementType;
	}

	const VirtualMachineConfigInfoSwapPlacementType: VirtualMachineConfigInfoSwapPlacementTypeConstructor;

	interface VirtualMachineConfigSpecNpivWwnOp extends VcVirtualMachineConfigSpecNpivWwnOp
	{
		name: any;

	}

	interface VirtualMachineConfigSpecNpivWwnOpConstructor {
		new(value?:any): VirtualMachineConfigSpecNpivWwnOp;
		readonly prototype: VirtualMachineConfigSpecNpivWwnOp;
	}

	const VirtualMachineConfigSpecNpivWwnOp: VirtualMachineConfigSpecNpivWwnOpConstructor;

	interface VirtualMachineConnectionState extends VcVirtualMachineConnectionState
	{
		name: any;

	}

	interface VirtualMachineConnectionStateConstructor {
		new(value?:any): VirtualMachineConnectionState;
		readonly prototype: VirtualMachineConnectionState;
	}

	const VirtualMachineConnectionState: VirtualMachineConnectionStateConstructor;

	interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther extends VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther
	{
		name: any;

	}

	interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOtherConstructor {
		new(value?:any): VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;
		readonly prototype: VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther;
	}

	const VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther: VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOtherConstructor;

	interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm extends VcVirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm
	{
		name: any;

	}

	interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVmConstructor {
		new(value?:any): VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
		readonly prototype: VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm;
	}

	const VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm: VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVmConstructor;

	interface VirtualMachineFaultToleranceState extends VcVirtualMachineFaultToleranceState
	{
		name: any;

	}

	interface VirtualMachineFaultToleranceStateConstructor {
		new(value?:any): VirtualMachineFaultToleranceState;
		readonly prototype: VirtualMachineFaultToleranceState;
	}

	const VirtualMachineFaultToleranceState: VirtualMachineFaultToleranceStateConstructor;

	interface VirtualMachineFaultToleranceType extends VcVirtualMachineFaultToleranceType
	{
		name: any;

	}

	interface VirtualMachineFaultToleranceTypeConstructor {
		new(value?:any): VirtualMachineFaultToleranceType;
		readonly prototype: VirtualMachineFaultToleranceType;
	}

	const VirtualMachineFaultToleranceType: VirtualMachineFaultToleranceTypeConstructor;

	interface VirtualMachineFileLayoutExFileType extends VcVirtualMachineFileLayoutExFileType
	{
		name: any;

	}

	interface VirtualMachineFileLayoutExFileTypeConstructor {
		new(value?:any): VirtualMachineFileLayoutExFileType;
		readonly prototype: VirtualMachineFileLayoutExFileType;
	}

	const VirtualMachineFileLayoutExFileType: VirtualMachineFileLayoutExFileTypeConstructor;

	interface VirtualMachineFlagInfoMonitorType extends VcVirtualMachineFlagInfoMonitorType
	{
		name: any;

	}

	interface VirtualMachineFlagInfoMonitorTypeConstructor {
		new(value?:any): VirtualMachineFlagInfoMonitorType;
		readonly prototype: VirtualMachineFlagInfoMonitorType;
	}

	const VirtualMachineFlagInfoMonitorType: VirtualMachineFlagInfoMonitorTypeConstructor;

	interface VirtualMachineFlagInfoVirtualExecUsage extends VcVirtualMachineFlagInfoVirtualExecUsage
	{
		name: any;

	}

	interface VirtualMachineFlagInfoVirtualExecUsageConstructor {
		new(value?:any): VirtualMachineFlagInfoVirtualExecUsage;
		readonly prototype: VirtualMachineFlagInfoVirtualExecUsage;
	}

	const VirtualMachineFlagInfoVirtualExecUsage: VirtualMachineFlagInfoVirtualExecUsageConstructor;

	interface VirtualMachineFlagInfoVirtualMmuUsage extends VcVirtualMachineFlagInfoVirtualMmuUsage
	{
		name: any;

	}

	interface VirtualMachineFlagInfoVirtualMmuUsageConstructor {
		new(value?:any): VirtualMachineFlagInfoVirtualMmuUsage;
		readonly prototype: VirtualMachineFlagInfoVirtualMmuUsage;
	}

	const VirtualMachineFlagInfoVirtualMmuUsage: VirtualMachineFlagInfoVirtualMmuUsageConstructor;

	interface VirtualMachineForkConfigInfoChildType extends VcVirtualMachineForkConfigInfoChildType
	{
		name: any;

	}

	interface VirtualMachineForkConfigInfoChildTypeConstructor {
		new(value?:any): VirtualMachineForkConfigInfoChildType;
		readonly prototype: VirtualMachineForkConfigInfoChildType;
	}

	const VirtualMachineForkConfigInfoChildType: VirtualMachineForkConfigInfoChildTypeConstructor;

	interface VirtualMachineGuestOsFamily extends VcVirtualMachineGuestOsFamily
	{
		name: any;

	}

	interface VirtualMachineGuestOsFamilyConstructor {
		new(value?:any): VirtualMachineGuestOsFamily;
		readonly prototype: VirtualMachineGuestOsFamily;
	}

	const VirtualMachineGuestOsFamily: VirtualMachineGuestOsFamilyConstructor;

	interface VirtualMachineGuestOsIdentifier extends VcVirtualMachineGuestOsIdentifier
	{
		name: any;

	}

	interface VirtualMachineGuestOsIdentifierConstructor {
		new(value?:any): VirtualMachineGuestOsIdentifier;
		readonly prototype: VirtualMachineGuestOsIdentifier;
	}

	const VirtualMachineGuestOsIdentifier: VirtualMachineGuestOsIdentifierConstructor;

	interface VirtualMachineGuestState extends VcVirtualMachineGuestState
	{
		name: any;

	}

	interface VirtualMachineGuestStateConstructor {
		new(value?:any): VirtualMachineGuestState;
		readonly prototype: VirtualMachineGuestState;
	}

	const VirtualMachineGuestState: VirtualMachineGuestStateConstructor;

	interface VirtualMachineHtSharing extends VcVirtualMachineHtSharing
	{
		name: any;

	}

	interface VirtualMachineHtSharingConstructor {
		new(value?:any): VirtualMachineHtSharing;
		readonly prototype: VirtualMachineHtSharing;
	}

	const VirtualMachineHtSharing: VirtualMachineHtSharingConstructor;

	interface VirtualMachineMemoryAllocationPolicy extends VcVirtualMachineMemoryAllocationPolicy
	{
		name: any;

	}

	interface VirtualMachineMemoryAllocationPolicyConstructor {
		new(value?:any): VirtualMachineMemoryAllocationPolicy;
		readonly prototype: VirtualMachineMemoryAllocationPolicy;
	}

	const VirtualMachineMemoryAllocationPolicy: VirtualMachineMemoryAllocationPolicyConstructor;

	interface VirtualMachineMetadataManagerVmMetadataOp extends VcVirtualMachineMetadataManagerVmMetadataOp
	{
		name: any;

	}

	interface VirtualMachineMetadataManagerVmMetadataOpConstructor {
		new(value?:any): VirtualMachineMetadataManagerVmMetadataOp;
		readonly prototype: VirtualMachineMetadataManagerVmMetadataOp;
	}

	const VirtualMachineMetadataManagerVmMetadataOp: VirtualMachineMetadataManagerVmMetadataOpConstructor;

	interface VirtualMachineMetadataManagerVmMetadataOwnerOwner extends VcVirtualMachineMetadataManagerVmMetadataOwnerOwner
	{
		name: any;

	}

	interface VirtualMachineMetadataManagerVmMetadataOwnerOwnerConstructor {
		new(value?:any): VirtualMachineMetadataManagerVmMetadataOwnerOwner;
		readonly prototype: VirtualMachineMetadataManagerVmMetadataOwnerOwner;
	}

	const VirtualMachineMetadataManagerVmMetadataOwnerOwner: VirtualMachineMetadataManagerVmMetadataOwnerOwnerConstructor;

	interface VirtualMachineMovePriority extends VcVirtualMachineMovePriority
	{
		name: any;

	}

	interface VirtualMachineMovePriorityConstructor {
		new(value?:any): VirtualMachineMovePriority;
		readonly prototype: VirtualMachineMovePriority;
	}

	const VirtualMachineMovePriority: VirtualMachineMovePriorityConstructor;

	interface VirtualMachineNeedSecondaryReason extends VcVirtualMachineNeedSecondaryReason
	{
		name: any;

	}

	interface VirtualMachineNeedSecondaryReasonConstructor {
		new(value?:any): VirtualMachineNeedSecondaryReason;
		readonly prototype: VirtualMachineNeedSecondaryReason;
	}

	const VirtualMachineNeedSecondaryReason: VirtualMachineNeedSecondaryReasonConstructor;

	interface VirtualMachinePowerOffBehavior extends VcVirtualMachinePowerOffBehavior
	{
		name: any;

	}

	interface VirtualMachinePowerOffBehaviorConstructor {
		new(value?:any): VirtualMachinePowerOffBehavior;
		readonly prototype: VirtualMachinePowerOffBehavior;
	}

	const VirtualMachinePowerOffBehavior: VirtualMachinePowerOffBehaviorConstructor;

	interface VirtualMachinePowerOpType extends VcVirtualMachinePowerOpType
	{
		name: any;

	}

	interface VirtualMachinePowerOpTypeConstructor {
		new(value?:any): VirtualMachinePowerOpType;
		readonly prototype: VirtualMachinePowerOpType;
	}

	const VirtualMachinePowerOpType: VirtualMachinePowerOpTypeConstructor;

	interface VirtualMachinePowerPolicyCpuMode extends VcVirtualMachinePowerPolicyCpuMode
	{
		name: any;

	}

	interface VirtualMachinePowerPolicyCpuModeConstructor {
		new(value?:any): VirtualMachinePowerPolicyCpuMode;
		readonly prototype: VirtualMachinePowerPolicyCpuMode;
	}

	const VirtualMachinePowerPolicyCpuMode: VirtualMachinePowerPolicyCpuModeConstructor;

	interface VirtualMachinePowerPolicyPowerMode extends VcVirtualMachinePowerPolicyPowerMode
	{
		name: any;

	}

	interface VirtualMachinePowerPolicyPowerModeConstructor {
		new(value?:any): VirtualMachinePowerPolicyPowerMode;
		readonly prototype: VirtualMachinePowerPolicyPowerMode;
	}

	const VirtualMachinePowerPolicyPowerMode: VirtualMachinePowerPolicyPowerModeConstructor;

	interface VirtualMachinePowerState extends VcVirtualMachinePowerState
	{
		name: any;

	}

	interface VirtualMachinePowerStateConstructor {
		new(value?:any): VirtualMachinePowerState;
		readonly prototype: VirtualMachinePowerState;
	}

	const VirtualMachinePowerState: VirtualMachinePowerStateConstructor;

	interface VirtualMachineRecordReplayState extends VcVirtualMachineRecordReplayState
	{
		name: any;

	}

	interface VirtualMachineRecordReplayStateConstructor {
		new(value?:any): VirtualMachineRecordReplayState;
		readonly prototype: VirtualMachineRecordReplayState;
	}

	const VirtualMachineRecordReplayState: VirtualMachineRecordReplayStateConstructor;

	interface VirtualMachineRelocateDiskMoveOptions extends VcVirtualMachineRelocateDiskMoveOptions
	{
		name: any;

	}

	interface VirtualMachineRelocateDiskMoveOptionsConstructor {
		new(value?:any): VirtualMachineRelocateDiskMoveOptions;
		readonly prototype: VirtualMachineRelocateDiskMoveOptions;
	}

	const VirtualMachineRelocateDiskMoveOptions: VirtualMachineRelocateDiskMoveOptionsConstructor;

	interface VirtualMachineRelocateTransformation extends VcVirtualMachineRelocateTransformation
	{
		name: any;

	}

	interface VirtualMachineRelocateTransformationConstructor {
		new(value?:any): VirtualMachineRelocateTransformation;
		readonly prototype: VirtualMachineRelocateTransformation;
	}

	const VirtualMachineRelocateTransformation: VirtualMachineRelocateTransformationConstructor;

	interface VirtualMachineScsiPassthroughType extends VcVirtualMachineScsiPassthroughType
	{
		name: any;

	}

	interface VirtualMachineScsiPassthroughTypeConstructor {
		new(value?:any): VirtualMachineScsiPassthroughType;
		readonly prototype: VirtualMachineScsiPassthroughType;
	}

	const VirtualMachineScsiPassthroughType: VirtualMachineScsiPassthroughTypeConstructor;

	interface VirtualMachineSnapshot extends VcVirtualMachineSnapshot
	{
		id: any;
		name: any;
		vimHost: any;
		virtualMachineName: any;

		getChildSnapshot(): VirtualMachineSnapshot;
		getVm(): VirtualMachine;
	}

	interface VirtualMachineSnapshotConstructor {
		new(value?:any): VirtualMachineSnapshot;
		readonly prototype: VirtualMachineSnapshot;
	}

	const VirtualMachineSnapshot: VirtualMachineSnapshotConstructor;

	interface VirtualMachineStandbyActionType extends VcVirtualMachineStandbyActionType
	{
		name: any;

	}

	interface VirtualMachineStandbyActionTypeConstructor {
		new(value?:any): VirtualMachineStandbyActionType;
		readonly prototype: VirtualMachineStandbyActionType;
	}

	const VirtualMachineStandbyActionType: VirtualMachineStandbyActionTypeConstructor;

	interface VirtualMachineTargetInfoConfigurationTag extends VcVirtualMachineTargetInfoConfigurationTag
	{
		name: any;

	}

	interface VirtualMachineTargetInfoConfigurationTagConstructor {
		new(value?:any): VirtualMachineTargetInfoConfigurationTag;
		readonly prototype: VirtualMachineTargetInfoConfigurationTag;
	}

	const VirtualMachineTargetInfoConfigurationTag: VirtualMachineTargetInfoConfigurationTagConstructor;

	interface VirtualMachineTicketType extends VcVirtualMachineTicketType
	{
		name: any;

	}

	interface VirtualMachineTicketTypeConstructor {
		new(value?:any): VirtualMachineTicketType;
		readonly prototype: VirtualMachineTicketType;
	}

	const VirtualMachineTicketType: VirtualMachineTicketTypeConstructor;

	interface VirtualMachineToolsRunningStatus extends VcVirtualMachineToolsRunningStatus
	{
		name: any;

	}

	interface VirtualMachineToolsRunningStatusConstructor {
		new(value?:any): VirtualMachineToolsRunningStatus;
		readonly prototype: VirtualMachineToolsRunningStatus;
	}

	const VirtualMachineToolsRunningStatus: VirtualMachineToolsRunningStatusConstructor;

	interface VirtualMachineToolsStatus extends VcVirtualMachineToolsStatus
	{
		name: any;

	}

	interface VirtualMachineToolsStatusConstructor {
		new(value?:any): VirtualMachineToolsStatus;
		readonly prototype: VirtualMachineToolsStatus;
	}

	const VirtualMachineToolsStatus: VirtualMachineToolsStatusConstructor;

	interface VirtualMachineToolsVersionStatus extends VcVirtualMachineToolsVersionStatus
	{
		name: any;

	}

	interface VirtualMachineToolsVersionStatusConstructor {
		new(value?:any): VirtualMachineToolsVersionStatus;
		readonly prototype: VirtualMachineToolsVersionStatus;
	}

	const VirtualMachineToolsVersionStatus: VirtualMachineToolsVersionStatusConstructor;

	interface VirtualMachineUsbInfoFamily extends VcVirtualMachineUsbInfoFamily
	{
		name: any;

	}

	interface VirtualMachineUsbInfoFamilyConstructor {
		new(value?:any): VirtualMachineUsbInfoFamily;
		readonly prototype: VirtualMachineUsbInfoFamily;
	}

	const VirtualMachineUsbInfoFamily: VirtualMachineUsbInfoFamilyConstructor;

	interface VirtualMachineUsbInfoSpeed extends VcVirtualMachineUsbInfoSpeed
	{
		name: any;

	}

	interface VirtualMachineUsbInfoSpeedConstructor {
		new(value?:any): VirtualMachineUsbInfoSpeed;
		readonly prototype: VirtualMachineUsbInfoSpeed;
	}

	const VirtualMachineUsbInfoSpeed: VirtualMachineUsbInfoSpeedConstructor;

	interface VirtualMachineVideoCardUse3dRenderer extends VcVirtualMachineVideoCardUse3dRenderer
	{
		name: any;

	}

	interface VirtualMachineVideoCardUse3dRendererConstructor {
		new(value?:any): VirtualMachineVideoCardUse3dRenderer;
		readonly prototype: VirtualMachineVideoCardUse3dRenderer;
	}

	const VirtualMachineVideoCardUse3dRenderer: VirtualMachineVideoCardUse3dRendererConstructor;

	interface VirtualMachineVMCIDeviceAction extends VcVirtualMachineVMCIDeviceAction
	{
		name: any;

	}

	interface VirtualMachineVMCIDeviceActionConstructor {
		new(value?:any): VirtualMachineVMCIDeviceAction;
		readonly prototype: VirtualMachineVMCIDeviceAction;
	}

	const VirtualMachineVMCIDeviceAction: VirtualMachineVMCIDeviceActionConstructor;

	interface VirtualMachineVMCIDeviceDirection extends VcVirtualMachineVMCIDeviceDirection
	{
		name: any;

	}

	interface VirtualMachineVMCIDeviceDirectionConstructor {
		new(value?:any): VirtualMachineVMCIDeviceDirection;
		readonly prototype: VirtualMachineVMCIDeviceDirection;
	}

	const VirtualMachineVMCIDeviceDirection: VirtualMachineVMCIDeviceDirectionConstructor;

	interface VirtualMachineVMCIDeviceProtocol extends VcVirtualMachineVMCIDeviceProtocol
	{
		name: any;

	}

	interface VirtualMachineVMCIDeviceProtocolConstructor {
		new(value?:any): VirtualMachineVMCIDeviceProtocol;
		readonly prototype: VirtualMachineVMCIDeviceProtocol;
	}

	const VirtualMachineVMCIDeviceProtocol: VirtualMachineVMCIDeviceProtocolConstructor;

	interface VirtualPointingDeviceHostChoice extends VcVirtualPointingDeviceHostChoice
	{
		name: any;

	}

	interface VirtualPointingDeviceHostChoiceConstructor {
		new(value?:any): VirtualPointingDeviceHostChoice;
		readonly prototype: VirtualPointingDeviceHostChoice;
	}

	const VirtualPointingDeviceHostChoice: VirtualPointingDeviceHostChoiceConstructor;

	interface VirtualSCSISharing extends VcVirtualSCSISharing
	{
		name: any;

	}

	interface VirtualSCSISharingConstructor {
		new(value?:any): VirtualSCSISharing;
		readonly prototype: VirtualSCSISharing;
	}

	const VirtualSCSISharing: VirtualSCSISharingConstructor;

	interface VirtualSerialPortEndPoint extends VcVirtualSerialPortEndPoint
	{
		name: any;

	}

	interface VirtualSerialPortEndPointConstructor {
		new(value?:any): VirtualSerialPortEndPoint;
		readonly prototype: VirtualSerialPortEndPoint;
	}

	const VirtualSerialPortEndPoint: VirtualSerialPortEndPointConstructor;

	interface VmDasBeingResetEventReasonCode extends VcVmDasBeingResetEventReasonCode
	{
		name: any;

	}

	interface VmDasBeingResetEventReasonCodeConstructor {
		new(value?:any): VmDasBeingResetEventReasonCode;
		readonly prototype: VmDasBeingResetEventReasonCode;
	}

	const VmDasBeingResetEventReasonCode: VmDasBeingResetEventReasonCodeConstructor;

	interface VmDVPortEventEventCode extends VcVmDVPortEventEventCode
	{
		name: any;

	}

	interface VmDVPortEventEventCodeConstructor {
		new(value?:any): VmDVPortEventEventCode;
		readonly prototype: VmDVPortEventEventCode;
	}

	const VmDVPortEventEventCode: VmDVPortEventEventCodeConstructor;

	interface VmFailedStartingSecondaryEventFailureReason extends VcVmFailedStartingSecondaryEventFailureReason
	{
		name: any;

	}

	interface VmFailedStartingSecondaryEventFailureReasonConstructor {
		new(value?:any): VmFailedStartingSecondaryEventFailureReason;
		readonly prototype: VmFailedStartingSecondaryEventFailureReason;
	}

	const VmFailedStartingSecondaryEventFailureReason: VmFailedStartingSecondaryEventFailureReasonConstructor;

	interface VmFaultToleranceConfigIssueReasonForIssue extends VcVmFaultToleranceConfigIssueReasonForIssue
	{
		name: any;

	}

	interface VmFaultToleranceConfigIssueReasonForIssueConstructor {
		new(value?:any): VmFaultToleranceConfigIssueReasonForIssue;
		readonly prototype: VmFaultToleranceConfigIssueReasonForIssue;
	}

	const VmFaultToleranceConfigIssueReasonForIssue: VmFaultToleranceConfigIssueReasonForIssueConstructor;

	interface VmFaultToleranceInvalidFileBackingDeviceType extends VcVmFaultToleranceInvalidFileBackingDeviceType
	{
		name: any;

	}

	interface VmFaultToleranceInvalidFileBackingDeviceTypeConstructor {
		new(value?:any): VmFaultToleranceInvalidFileBackingDeviceType;
		readonly prototype: VmFaultToleranceInvalidFileBackingDeviceType;
	}

	const VmFaultToleranceInvalidFileBackingDeviceType: VmFaultToleranceInvalidFileBackingDeviceTypeConstructor;

	interface VmFolder extends VcFolder
	{
		id: any;
		name: any;
		vimHost: any;

		getFolder(): VmFolder;
		getResourcePool_VirtualApp(): VirtualApp;
		getVm(): VirtualMachine;
	}

	interface VmFolderConstructor {
		new(value?:any): VmFolder;
		readonly prototype: VmFolder;
	}

	const VmFolder: VmFolderConstructor;

	interface VMotionCompatibilityType extends VcVMotionCompatibilityType
	{
		name: any;

	}

	interface VMotionCompatibilityTypeConstructor {
		new(value?:any): VMotionCompatibilityType;
		readonly prototype: VMotionCompatibilityType;
	}

	const VMotionCompatibilityType: VMotionCompatibilityTypeConstructor;

	interface VmShutdownOnIsolationEventOperation extends VcVmShutdownOnIsolationEventOperation
	{
		name: any;

	}

	interface VmShutdownOnIsolationEventOperationConstructor {
		new(value?:any): VmShutdownOnIsolationEventOperation;
		readonly prototype: VmShutdownOnIsolationEventOperation;
	}

	const VmShutdownOnIsolationEventOperation: VmShutdownOnIsolationEventOperationConstructor;

	interface VmwareDistributedVirtualSwitch extends VcVmwareDistributedVirtualSwitch
	{
		description: any;
		id: any;
		name: any;
		vimHost: any;

		getPortgroup(): DistributedVirtualPortgroup;
		getRecentTask(): Task;
	}

	interface VmwareDistributedVirtualSwitchConstructor {
		new(value?:any): VmwareDistributedVirtualSwitch;
		readonly prototype: VmwareDistributedVirtualSwitch;
	}

	const VmwareDistributedVirtualSwitch: VmwareDistributedVirtualSwitchConstructor;

	interface VmwareDistributedVirtualSwitchPvlanPortType extends VcVmwareDistributedVirtualSwitchPvlanPortType
	{
		name: any;

	}

	interface VmwareDistributedVirtualSwitchPvlanPortTypeConstructor {
		new(value?:any): VmwareDistributedVirtualSwitchPvlanPortType;
		readonly prototype: VmwareDistributedVirtualSwitchPvlanPortType;
	}

	const VmwareDistributedVirtualSwitchPvlanPortType: VmwareDistributedVirtualSwitchPvlanPortTypeConstructor;

	interface VMwareDvsLacpApiVersion extends VcVMwareDvsLacpApiVersion
	{
		name: any;

	}

	interface VMwareDvsLacpApiVersionConstructor {
		new(value?:any): VMwareDvsLacpApiVersion;
		readonly prototype: VMwareDvsLacpApiVersion;
	}

	const VMwareDvsLacpApiVersion: VMwareDvsLacpApiVersionConstructor;

	interface VMwareDvsLacpLoadBalanceAlgorithm extends VcVMwareDvsLacpLoadBalanceAlgorithm
	{
		name: any;

	}

	interface VMwareDvsLacpLoadBalanceAlgorithmConstructor {
		new(value?:any): VMwareDvsLacpLoadBalanceAlgorithm;
		readonly prototype: VMwareDvsLacpLoadBalanceAlgorithm;
	}

	const VMwareDvsLacpLoadBalanceAlgorithm: VMwareDvsLacpLoadBalanceAlgorithmConstructor;

	interface VMwareDvsMulticastFilteringMode extends VcVMwareDvsMulticastFilteringMode
	{
		name: any;

	}

	interface VMwareDvsMulticastFilteringModeConstructor {
		new(value?:any): VMwareDvsMulticastFilteringMode;
		readonly prototype: VMwareDvsMulticastFilteringMode;
	}

	const VMwareDvsMulticastFilteringMode: VMwareDvsMulticastFilteringModeConstructor;

	interface VMwareDVSTeamingMatchStatus extends VcVMwareDVSTeamingMatchStatus
	{
		name: any;

	}

	interface VMwareDVSTeamingMatchStatusConstructor {
		new(value?:any): VMwareDVSTeamingMatchStatus;
		readonly prototype: VMwareDVSTeamingMatchStatus;
	}

	const VMwareDVSTeamingMatchStatus: VMwareDVSTeamingMatchStatusConstructor;

	interface VMwareDVSVspanSessionType extends VcVMwareDVSVspanSessionType
	{
		name: any;

	}

	interface VMwareDVSVspanSessionTypeConstructor {
		new(value?:any): VMwareDVSVspanSessionType;
		readonly prototype: VMwareDVSVspanSessionType;
	}

	const VMwareDVSVspanSessionType: VMwareDVSVspanSessionTypeConstructor;

	interface VMwareUplinkLacpMode extends VcVMwareUplinkLacpMode
	{
		name: any;

	}

	interface VMwareUplinkLacpModeConstructor {
		new(value?:any): VMwareUplinkLacpMode;
		readonly prototype: VMwareUplinkLacpMode;
	}

	const VMwareUplinkLacpMode: VMwareUplinkLacpModeConstructor;

	interface VRMPolicyInfoDisksReplicated extends VcVRMPolicyInfoDisksReplicated
	{
		name: any;

	}

	interface VRMPolicyInfoDisksReplicatedConstructor {
		new(value?:any): VRMPolicyInfoDisksReplicated;
		readonly prototype: VRMPolicyInfoDisksReplicated;
	}

	const VRMPolicyInfoDisksReplicated: VRMPolicyInfoDisksReplicatedConstructor;

	interface VsanDiskIssueType extends VcVsanDiskIssueType
	{
		name: any;

	}

	interface VsanDiskIssueTypeConstructor {
		new(value?:any): VsanDiskIssueType;
		readonly prototype: VsanDiskIssueType;
	}

	const VsanDiskIssueType: VsanDiskIssueTypeConstructor;

	interface VsanHostDecommissionModeObjectAction extends VcVsanHostDecommissionModeObjectAction
	{
		name: any;

	}

	interface VsanHostDecommissionModeObjectActionConstructor {
		new(value?:any): VsanHostDecommissionModeObjectAction;
		readonly prototype: VsanHostDecommissionModeObjectAction;
	}

	const VsanHostDecommissionModeObjectAction: VsanHostDecommissionModeObjectActionConstructor;

	interface VsanHostDiskResultState extends VcVsanHostDiskResultState
	{
		name: any;

	}

	interface VsanHostDiskResultStateConstructor {
		new(value?:any): VsanHostDiskResultState;
		readonly prototype: VsanHostDiskResultState;
	}

	const VsanHostDiskResultState: VsanHostDiskResultStateConstructor;

	interface VsanHostHealthState extends VcVsanHostHealthState
	{
		name: any;

	}

	interface VsanHostHealthStateConstructor {
		new(value?:any): VsanHostHealthState;
		readonly prototype: VsanHostHealthState;
	}

	const VsanHostHealthState: VsanHostHealthStateConstructor;

	interface VsanHostNodeState extends VcVsanHostNodeState
	{
		name: any;

	}

	interface VsanHostNodeStateConstructor {
		new(value?:any): VsanHostNodeState;
		readonly prototype: VsanHostNodeState;
	}

	const VsanHostNodeState: VsanHostNodeStateConstructor;

	interface VsanUpgradeSystemUpgradeHistoryDiskGroupOpType extends VcVsanUpgradeSystemUpgradeHistoryDiskGroupOpType
	{
		name: any;

	}

	interface VsanUpgradeSystemUpgradeHistoryDiskGroupOpTypeConstructor {
		new(value?:any): VsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
		readonly prototype: VsanUpgradeSystemUpgradeHistoryDiskGroupOpType;
	}

	const VsanUpgradeSystemUpgradeHistoryDiskGroupOpType: VsanUpgradeSystemUpgradeHistoryDiskGroupOpTypeConstructor;

	interface WeekOfMonth extends VcWeekOfMonth
	{
		name: any;

	}

	interface WeekOfMonthConstructor {
		new(value?:any): WeekOfMonth;
		readonly prototype: WeekOfMonth;
	}

	const WeekOfMonth: WeekOfMonthConstructor;

	interface WillLoseHAProtectionResolution extends VcWillLoseHAProtectionResolution
	{
		name: any;

	}

	interface WillLoseHAProtectionResolutionConstructor {
		new(value?:any): WillLoseHAProtectionResolution;
		readonly prototype: WillLoseHAProtectionResolution;
	}

	const WillLoseHAProtectionResolution: WillLoseHAProtectionResolutionConstructor;

    }    
